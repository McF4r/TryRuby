{"1":{"lang":"PT-BR","title":"Tem 30 minutos? Dê uma chance ao Ruby agora!","chapter":"Y","answer":"","ok":"","error":"","text":"Ruby é uma linguagem de programação criada no Japão que está revolucionando\no desenvolvimento de software.\n\nA beleza do Ruby é encontrada em seu equilibrio entre simplicidade e poder.\n\nVocê pode digitar algum código Ruby no editor e usar estes botões para navegar:\n\n- __Run__ &rarr; Executa o código que está no editor\n- __Copy__ &rarr; Copia o código de exemplo para o editor\n- __Next__ &rarr; Vai para a próxima lição\n- __Back__ &rarr; Retorna a lição anterior\n- __Clear__ &rarr; Limpa o editor\n\nUse o botão 'mundo' <span aria-hidden=\"true\" class=\"glyphicon glyphicon-globe\"></span>\nacima para mudar o idioma do TryRuby.\n\n### Clique em __Next__ para iniciar o aprendizado.","load_code":""},
"2":{"lang":"PT-BR","title":"Usando o editor","chapter":"N","answer":"^\\d{1,}$","ok":"Ótimo! Você fez um pouco de matemática. Viu como a resposta apareceu?","error":"Digite 2 + 6 no editor","text":"A janela de edição na parte inferior é onde você digita o seu código Ruby, clique no botão __Run__\ne veja o seu código rodar!\n\nPor exemplo, tente digitar alguma expressão matemática. Como:\n\n    2 + 6\n\nA saída do seu programa será exibida na janela de saída na parte superior.\nTambém deverá ter uma linha que lhe dirá o quão bem você fez.\n\n> Alternativamente, você pode apertar o botão __Copy__ para copiar todo o exemplo para o editor.","load_code":""},
"3":{"lang":"PT-BR","title":"Numeros e Matemática","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Bom","error":"","text":"O Ruby reconhece números e símbolos matemáticos. Você pode tentar outras expressões matemáticas, como:\n\n    4 * 10\n    5 - 12\n    30 / 4","load_code":""},
"4":{"lang":"PT-BR","title":"Colocando de forma diferente","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Bem colocado","error":"","text":"Você percebeu que se você digitou mais de uma fórmula, você só viu o resultado da última?\nO que está acontecendo?\n\n> Para tornar este site mais fácil de usar, eu disse ao Ruby para copiar o resultado do seu programa\n> para a tela de saída ao topo. Então quando você digita uma fórmula, você consegue ver o resultado.\n> __Mas apenas o último resultado.__ E apenas se a saída estiver vazia.\n\nEntão, quando você entrou com 2 ou mais fórmulas, o Ruby exibiu apenas o resultado da última fórmula.\n\nÉ claro, você tem o poder de controlar a tela! Apenas digite __puts__ antes de cada fórmula\n(com um espaço entre eles). Puts significa: *'coloque (put) alguma coisa na tela'*.\n\nTente isso:\n\n    puts 4 * 10\n    puts 5 - 12\n    puts 30 / 4\n\nAgora, remova o __puts__ da última fórmula e veja o que acontece.","load_code":""},
"5":{"lang":"PT-BR","title":"Diga o seu nome","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Perfeito, você formou uma string com as letras do seu nome","error":"","text":"Claro, computadores são práticos e rápidos para operações matemáticas. Vamos continuar. Gostaria de ver o seu nome invertido?\n\nPrimeiro digite o seu nome, entre aspas, desta forma:\n\n    \"Ricardo\"","load_code":""},
"6":{"lang":"PT-BR","title":"Diga o seu nome de trás para frente","chapter":"N","answer":"\\w+","ok":"moB","error":"","text":"Uma string é um conjunto de caracteres que o computador consegue processar. Imagine que as\nletras estão em um varal de roupas, e as aspas são os pregadores segurando as extremidades.\nAs aspas marcam o ínicio e o fim da string.\n\nPara inverter o seu nome, digite:\n\n    \"Ricardo\".reverse\n\n(Não se esqueca do ponto!)","load_code":""},
"7":{"lang":"PT-BR","title":"Contando Letras","chapter":"N","answer":"^\\d+$","ok":"Sim. Length também é um 'método'","error":"","text":"Você já usou o __método__ reverse no seu nome! Ao colocar seu nome entre aspas, você criou uma string. Então você chamou o método reverse, que\nfunciona com strings e inverte a posição de todas as letras, deixando a string de trás para frente.\n\nAgora, vejamos quantas letras tem em seu nome:\n\n    \"Ricardo\".length","load_code":""},
"8":{"lang":"PT-BR","title":"Na repetição","chapter":"N","answer":"(\\w+)","ok":"É um prazer conhece-lo.É um prazer conhece-lo.É um prazer conhece-lo.","error":"","text":"Agora, você provavelmente está se perguntando qual é a utilidade disto.\n\nBem, eu tenho certeza que você já visitou alguma página que gritou: __\"Ei, sua senha é muito curta!\"__\n\nViu? Alguns programas usam este simples  código __.length__.\n\nVeja isso. Vamos múltiplicar seu nome por 5.\n\n    \"Ricardo\" * 5","load_code":""},
"9":{"lang":"PT-BR","title":"Ei, Sumário #1 Pronto","chapter":"Y","answer":"NoMethodError|undefined","ok":"Não, não é possível inverter um número. Clique em __next__ para continuar","error":"","text":"Vamos revisar o que nós aprendemos neste primeiro minuto.\n\n### O editor\nDigitando o código no editor e clicando em __run__, o resultado do seu código é exibido na tela de saída.\n(Quase) todos os códigos fornecem uma resposta.\n\n### Numeros e strings\nNúmeros e strings são os objetos matemáticos e de texto do Ruby.\n\n### Métodos\nVocê usou métodos em inglês como reverse e length. E usou métodos simbólicos como o método\nde multiplicação: \\*.\n__Métodos significam ações!__\n\nEsta é a essência do seu aprendizado. Pegando coisas simples, brincando com elas e então tornando-as\ncoisas novas.\nJá se sente confortável? Tenho certeza que você está.\n\n## Ok,\nvamos fazer algo desconfortável. Tente inverter um número:\n\n    40.reverse","load_code":""},
"10":{"lang":"PT-BR","title":"Pare, Você Está Latindo Como Um Louco!","chapter":"N","answer":"^\\d{1,}$","ok":"Apenas strings podem ser invertidas","error":"","text":"Você não pode inverter o número 40. Eu acho que você pode segurar o seu monitor em frente a um espelho, mas inverter um número\n simplesmente não faz sentido.\n\nO Ruby lançou uma mensagem de erro. O Ruby está te dizendo que não há o método reverse para números.\n\nTalvez, se você tornar o número em uma string primeiro:\n\n    40.to_s.reverse","load_code":""},
"11":{"lang":"PT-BR","title":"Garotos São Diferentes de Garotas","chapter":"N","answer":"\\[\\]","ok":"Ótimo, esta é uma lista vazia","error":"","text":"E números são diferentes de strings.\n\nEnquanto você pode usar métodos com qualquer objeto em Ruby, alguns métodos só funcionam com certos tipos de coisas.\nMas você pode sempre converter diferentes tipos em Ruby usando os métodos \"to\".\n\n- __to_s__ converte coisas para __s__trings\n- __to_i__ converte coisas para __i__ntegers (números)\n- __to_a__ converte coisas para __a__rrays\n\n__O que são arrays?!__\n\nEles são listas. Digite um par de colchetes:\n\n    []","load_code":""},
"12":{"lang":"PT-BR","title":"Ficando na Fila","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Excelente","error":"Tente incluir um quarto número na lista","text":"Listas (arrays) guardam coisas __em alguma ordem__.\n\nÉ como ficar na fila para a pipoca. Você está atrás de alguém e você nem sonharia passar a frente dele,\ncerto? E o cara atrás de você, você está de olho nele, certo?\n\nAqui está uma lista para você. Números de loteria.\n\n    [12, 47, 35]\n\nTente adicionar um número a esta lista: digite uma virgula após o 35, então digite um número. O espaço é opcional.","load_code":""},
"13":{"lang":"PT-BR","title":"Um Levanta a Mão","chapter":"N","answer":"^47$","ok":"Ok","error":"","text":"Uma lista dos números da loteria. Qual é o maior?\n\nTente: \n\n    [12, 47, 35].max","load_code":""},
"14":{"lang":"PT-BR","title":"Colocando Uma Lista de Distância","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Salvo!","error":"","text":"Bom, bom. Mas é irritante ter que ficar digitando a lista toda vez que você precisar dela, não é?\n\nVamos salvar os seus números dentro de um bilhete, assim:\n\n    bilhete = [12, 47, 35]","load_code":""},
"15":{"lang":"PT-BR","title":"Agora Digite bilhete","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Restaurado!","error":"","text":"Agora, digite:\n\n    bilhete","load_code":"bilhete = [12, 47, 35]"},
"16":{"lang":"PT-BR","title":"Salvo, Escondido","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Você ordenou a lista","error":"","text":"Você escreveu seus números de loteria, guardou-os dentro de uma __variável__ chamada bilhete.\nMas qualquer outro nome, como _listadoricardo_, teria funcionado também.\n\nProgramar, você descobrirá, é em boa parte trabalhar com variáveis.\n\nVamos ordenar os números da loteria, o que acha?\n\nUse:\n\n    bilhete.sort!\n\nVocê tem uma lista. Você ordenou uma lista. A variável bilhete agora mudou.\nVocê notou que o método _sort!_ tem uma grande e brilhante exclamação no final?\nMuitas vezes, os métodos do Ruby poderão ser chamados desta forma se eles alterarem a variável para o bem.\nIsso não é nada especial, apenas uma indicação.","load_code":"bilhete = [12, 47, 35]"},
"17":{"lang":"PT-BR","title":"Elemento","chapter":"N","answer":"^(12|35|47)$","ok":"Ok","error":"Quase","text":"Então, nós guardamos os nossos números da loteria dentro de uma variável bilhete. Como fazemos para\ncolocá-los pra fora de novo?\n\nNós já vimos que nós podemos obter o maior número com o método __max__. De forma similar, você pode obter\no primeiro, __first__, ou o último, __last__, elemento da lista.\nMas e se você quiser um elemento específico?\n\n### [ ]\nRuby usa colchetes [ ] para obter um elemento alvo.\nOs colchetes são muito comuns em Ruby.\nEles são como miras usadas para alinhar ao alvo. Exatamente.\nEsses colchetes significam: \"Eu estou olhando pelo ____\". Pronto, mire.\n\nVamos pegar todos os nossos números da loteria:\n\n    puts bilhete[0]\n    puts bilhete[1]\n    puts bilhete[2]\n\nPor que nós usamos [0], [1], [2] ?\n\nE não [1], [2] e [3] ? Isso é algum tipo de coisa zen japonesa ?\nNão, nós, pessoas-computador, apenas gostamos de contar começando do zero. Isso não é algo apenas do Ruby,\neste _índice com base zero_ é usado na maioria das linguagens de programação.\n\n> Um pequeno lembrete: você pode usar o botão __Copy__ para copiar o exemplo para o editor.","load_code":"bilhete = [12, 47, 35]"},
"18":{"lang":"PT-BR","title":"Sumário #2 Está Sobre Nós","chapter":"Y","answer":"\\w+","ok":"Isto rima ?","error":"","text":"Agora, vejamos como nosso segundo minuto foi:\n\n### Erros\nSe você tentar inverter um número, o Ruby irá lhe dizer um erro.\n\n### Arrays\nArrays são listas para guardar coisas em alguma ordem.\nNós também aprendemos como criar arrays e recuperar itens de arrays.\n\n### Variáveis\nVariáveis salvam a coisa e dão um nome pra ela. Você usou o símbolo de igual para isso. Por exemplo:\nbilhete = [14, 37, 18].\n\n### 2/8\nAo todo, há oito seções. Você está a dois oitavos do caminho para fora daqui! Isto é algo simples,\nvocê não acha? Coisas boas a frente.\n\nVamos mudar as direções por um momento. Eu coloquei um pedaço de um poema em uma certa variável.\nDê uma olhada. Digite:\n\n    puts poema","load_code":"poema = \"Minha torrada voou da minha mão\\nE minha torrada se foi para a lua.\\nMas quando eu vejo isso na televisão,\\nColocando nossa bandeira no cometa Halley,\\nMais ainda eu quero come-la.\\n\""},
"19":{"lang":"PT-BR","title":"Infelizmente, Você Odeia Poemas de Torradas","chapter":"N","answer":"(torrada){0}","ok":"Excelente","error":"Continua cheirando a torrada para mim","text":"Olha, tudo bem. Você não tem que gostar disso. Hackeie isso, seja meu convidado. Ao invés de torrada,\nvá para melão ou algo do tipo. Tente isso para ver o novo poema:\n\n    poema.gsub(\"torrada\", \"manga\")\n\nO método __gsub__ é abreviação para substituição global. Ele substitui todas as ocorrências de \"torrada\" para\n\"manga\"","load_code":"prev"},
"20":{"lang":"PT-BR","title":"Pronto, Mire","chapter":"N","answer":"^\\n.al-emoc (.+)","ok":"Ok, claro.  Então todo o poema foi invertido.","error":"","text":"Eis a questão: o que acontece quando nós invertemos todo o poema?\n\n    poema.reverse","load_code":"prev"},
"21":{"lang":"PT-BR","title":"Muita inversão","chapter":"N","answer":"^\\[\"Mais ainda (.+)","ok":"Sim, quase o que queremos","error":"","text":"Então, todo o poema foi invertido, letra por letra. Eu realmente desejo inverter apenas as linhas.\nFazer com que a última linha seja a primeira, e a primeira seja a última.\n\nDe trás para frente, mas não __este__ de trás pra frente.\n\nVeja como:\n\n    poema.lines.reverse","load_code":"prev"},
"22":{"lang":"PT-BR","title":"Cachos de Métodos Encadeados","chapter":"N","answer":"^Mais ainda eu quero (.+)","ok":"Bem mostrado, meu amigo!<br/>O método join pega este array de linhas e junta todas elas em uma string.","error":"","text":"Então, o que você vê? O que aconteceu aqui? Você digitou __poema.lines.reverse__ e o que aconteceu?\n\nDuas coisas aconteceram. Você tornou o poema em uma lista usando o método __lines__.\n__Lines__ decide a forma como a string será dividida e converte isso em um array.\n\nEntão, você inverteu esta lista. Você tinha cada linha. Você inverteu elas. É isso.\n\nVamos colocar mais um método ao final aqui:\n\n    puts poema.lines.reverse.join\n\nCombinando métodos desta forma é chamado de _encadeamento de métodos_.","load_code":"prev"},
"23":{"lang":"PT-BR","title":"De todos os sumários #3 está aqui agora","chapter":"Y","answer":"\\{\\}","ok":"Você criou um hash vazio !","error":"","text":"### Exclamações\nMétodos podem ter exclamações (e também interrogações) em seus nomes.\nIsto são apenas formas de explicar melhor qual é sua função. Nada de mais.\n\n### Manipulação de string\nBuscar e alterar strings\n\n### Encadeamento\nEncadeamento de métodos permite que você faça muito mais. Quebrar um poema, inverte-lo, remonta-lo:\n__poema.lines.reverse.join__\n\nA esta altura, talvez você queira  brincar com o poema um pouco mais. A lista completa de todos os métodos\nde String está <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">aqui</a>\n\nVá em frente e tente um pouco, coisas como: poema.downcase ou poema.swapcase\n\n## Pronto ?\nQuando se sentir pronto para continuar, digite:\n\n    livros = {}","load_code":"prev"},
"24":{"lang":"PT-BR","title":"Um Pequenino Livro em Branco","chapter":"N","answer":"^(esplendido|muito_bom|mediocre|nao_tao_bom|lixo)$","ok":"Sim, este precisa de uma análise","error":"Use um dentre esplendido, muito_bom, mediocre, nao_tao_bom, lixo.<br/>Não esqueça os dois pontos.","text":"Você criou um __hash__ vazio. Um hash é como um array, porém cada um dos seus elementos tem um nome.\n\nNós iremos adicionar algumas análises de livrinhos ao nosso hash. Aqui está nosso sistema de classificação:\n\n- :esplendido &rarr; uma obra prima\n- :muito\\_bom &rarr; gostei, é, gostei\n- :mediocre &rarr; tem partes boas e ruins\n- :nao\\_tao\\_bom &rarr; notavelmente ruim\n- :lixo &rarr; jamais recomendaria a alguém\n\nPara classificar um livro, coloque o título entre colchetes e escreva a classificação após o sinal de igual. Por exemplo:\n\n    livros[\"O Arco-Íris da Gravidade\"] = :esplendido\n\n> Agora, acho que é justo lhe dizer que todas as lições do TryRuby são separadas uma das outras.\n> Então, se você sair escrevendo loucamente análises de livros aqui, você só poderá usa-las nessa lição.\n> Se você deseja usar as suas análises na próxima lição, você deve copia-las e cola-las.\n> Não se preocupe com isso, cada lição tem uma quantidade pré definida de coisas para você brincar.","load_code":"livros = {}"},
"25":{"lang":"PT-BR","title":"Mais Pequenos Pedaços de Análises","chapter":"N","answer":"[3-9]","ok":"Veja, o método length trabalha com strings, arrays e hashes","error":"","text":"Vá em frente, preencha a lista com análises. E, se você quiser ver toda a lista, apenas digite: __puts livros__\n\nDe novo, as classificações são: :esplendido, :muito\\_bom, :mediocre, :nao\\_tao\\_bom e :lixo\n\nEssas classificações não são strings. Quando você coloca dois pontos a frente de uma simples palavra, você obtém um __symbol__ (símbolo).\nSímbolos são mais baratos que strings (em termos de custo de memória). Se você usar uma palavra várias e várias vezes no seu programa,\ntroque por um símbolo. Ao invés de ter milhares de cópias desta palavra na memória, o computador irá armazenar o símbolo apenas __uma vez__.\n\nMais importante, um símbolo diz a você que isso não é apenas uma palavra, mas algo que tem significado para o seu programa.\n\nEntre com mais duas análises de livros, use __livros.length__ para ver quantas análises já existem no hash:\n\n    livros[\"Até o Fim\"]  = :lixo\n    livros[\"Cores Vivas\"] = :mediocre\n\n    puts livros\n\n    puts livros.length","load_code":"livros = {\"O Arco-Íris da Gravidade\" => :esplendido}"},
"26":{"lang":"PT-BR","title":"Espera, Eu Gostei De Gravity's Rainbow?","chapter":"N","answer":"^(esplendido|muito_bom|mediocre|nao_tao_bom|lixo)$","ok":"Eu gostei bastante","error":"","text":"Uma grande coisa sobre o Ruby é que nomes são frequentemente reutilizados, isso significa menos nomes para você lembrar.\n\nRelembre como nós recuperamos itens de um array utilizando um número:\n__puts bilhete[1]__.\n\nPara um hash isso funciona da mesma forma, exceto que nós não usaremos um número para recuperar um elemento (mas sim um nome).\n\nEntão, se você quiser olhar uma de suas análises antigas, de novo, coloque o título entre colchetes (mas dessa vez sem o sinal de igual).\nDesta forma:\n\n    puts livros[\"O Arco-Íris da Gravidade\"]","load_code":"livros = {\"O Arco-Íris da Gravidade\" => :esplendido, \"Até o Fim\" => :lixo, \"Cores Vivas\" => :mediocre}"},
"27":{"lang":"PT-BR","title":"Hashes como pares","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Você encontrou as chaves","error":"","text":"Tenha em mente que hashes não mantém as coisas ordenadas. Este não é o trabalho dele. Ele apenas\nfaz pares, os pares são: uma __key__ (chave) e um __value__ (valor).\n\nEm suas análises, o título do livro é a __key__, e a classificação é o __value__.\n\nSe você desejar ver apenas os titulos de todos os livros que você já análisou:\n\n    livros.keys\n\nVocê também pode tentar isso com .values ao invés de .keys.","load_code":"prev"},
"28":{"lang":"PT-BR","title":"Você é Áspero (Harsh)?","chapter":"N","answer":"\"mediocre\"","ok":"Ótimo, wow! Você fez um scorecard das suas análises.","error":"","text":"Então, você está dando análises ásperas e injustas? Vamos dar uma pontuação com um novo hash __classificacoes__:\n\nOk, vamos contar nossas análises. Apenas fique comigo. Digite:\n\n    classificacoes = Hash.new {0}\n\n    livros.values.each { |classificacao|\n      classificacoes[classificacao] += 1\n    }\n\n    puts classificacoes\n\nA novidade em nosso código é o caracter pipe, provavelmente localizado a direita da tecla Shift\nno seu teclado.\n\nA linha _+= 1_ significa: some 1 ao valor.\n\nNão se preocupe se você não entender tudo o que está acontecendo aqui. Isto será revelado mais tarde.","load_code":"livros = {\"O Arco-Íris da Gravidade\" => :esplendido, \"Até o Fim\" => :lixo, \"Cores Vivas\" => :mediocre, \"Bumblebees\" => :mediocre}"},
"29":{"lang":"PT-BR","title":"Um Cálculo","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"Uma das coisas incríveis que nós acabamos de usar é o __bloco__. Nós vamos explorar mais isso\nnesta e na próxima lição. Mas, basicamente, um bloco é um pedaço de código Ruby cercado por chaves {}.\n\nVamos tentar outro bloco:\n\n    5.times { print \"Odelay! \" }\n\nBlocos são sempre associados a métodos. Como o método __times__, que pega o bloco e roda o código\ndele várias e várias vezes. (No nosso exemplo: cinco vezes).","load_code":""},
"30":{"lang":"PT-BR","title":"Você Pegou o Tempo?","chapter":"N","answer":"^[0-9]$","ok":"Seu tempo está correto!","error":"Rode o bloco de 0 a 9 vezes.","text":"Como nós vimos em nosso primeiro exemplo com um bloco (quando contamos classificações) nós podemos passar um valor para o bloco.\nQuais valores são __passados__ é determinado pelo método que está rodando o bloco.\n\nOs valores que são __recebidos__ pelo bloco são colocados em uma variável que tem o nome definido no ínicio do bloco,\nentre dois símbolos pipe: |\n\nVamos tentar isso com este bloco:\n\n    5.times { |vez|\n      puts vez\n    }\n\nAqui, o método __.times (significa vezes)__ envia o valor para a variável __|vez|__ . Porém, note que a variável vez só é conhecida dentro do bloco.\n\n> Você notou que você pode dividir o código em várias linhas? Isto torna o código um pouco mais fácil de ser lido.","load_code":""},
"31":{"lang":"PT-BR","title":"Agora Desembarcando no Sumário #4","chapter":"Y","answer":"","ok":"","error":"","text":"Esta última lição é um pouco mais longa. Você provavelmente usou três minutos aprendendo sobre:\n\n### Hashes\nO pequeno dicionário com páginas chaves: __{}__\n\n### Símbolos\nPequenos, eficientes palavras de código com dois pontos, como: __:esplendido__\n\n### Blocos\nTrechos de código que podem ser usados com muitos métodos do Ruby. Aqui o código usado para\nconstruir o scorecard:\n__livros.values.each { |classificacao| classificacoes[classificacao] += 1 }__\n\n### Próximo\nNa próxima lição nós iremos entrar um pouco mais a fundo nos métodos.","load_code":""},
"32":{"lang":"PT-BR","title":"(Ser) ou não (ser)","chapter":"N","answer":"","ok":"","error":"","text":"Outra pequena coisa que nós não falamos de forma realmente aberta: argumentos de métodos.\nLembra quando nós mudamos o poema um pouco? Nós usamos:\n__poema.gsub(\"torrada\", \"manga\")__\n\nO método gsub precisa de dois argumentos, que nós passamos para o gsub ao incluir duas strings\nentre parênteses. _Argumentos falam para o método exatamente o que fazer_\n\n### Parênteses\nAtualmente, na maior parte das vezes o Ruby não se importa se você omitir os parenteses. Então, Isto\nteria funcionado também:\n__poema.gsub \"torrada\", \"manga\"__\n\nNós já usamos outro método com parâmetro (ou argumento). Muitas vezes, de fato, isso não foi tão óbvio:\n\n    puts \"Olá!\"\n    puts(\"Olá!\")\n\nSim, __puts__ também é um método. Usar puts com ou sem parênteses é a mesma coisa para o Ruby, mas a versão\nsem parênteses é um pouco mais fácil de ler. E isso economiza seu valioso tempo digitando !\n\n> Então eu acho que a conclusão é que você pode fazer o que você quiser com parênteses desde que\n> a legibilidade do seu código seja boa.\n\n### (ser) ou não (ser)\nEntão, se _to_ (ser) é o nome de um método e _ser_ é um argumento, nós sabemos a resposta para esta questão milenar.\nÉ realmente apenas uma questão de preferência de _to be_ ou _to(be)_.\n\nVocê está no humor para mais Shakespeare? Leia.","load_code":"poema = \"Minha torrada voou das minhas mãos\\nE minha torrada foi para a lua.\\nYada yada yada\\n\""},
"33":{"lang":"PT-BR","title":"A Megera Domada","chapter":"N","answer":"^domar","ok":"Bom bom !","error":"","text":"Agora você já sabe como usar o Ruby. Quero dizer, você já viu o essencial.\nVocê só tem que continuar aprendendo mais métodos e tentar blocos mais complexos.\n\nMas tem um lado do Ruby que nós não mostramos. Escrever seus próprios métodos.\n__Aha!__ Vamos fazer isso então.\n\nAlém de utilizar métodos que já vem com o Ruby (como puts, sort, times), você pode definir\nseus próprios métodos. Por que isso é uma boa idéia? Dois motivos:\n\n### Para fazer o seu programa ficar menor\nSe você tem que fazer a mesma coisa em mais de uma parte do seu código, é mais fácil\ncolocar este código em um método separado. Seu código será menor\n\n### Para tornar o seu código mais fácil de ler\nSuponha que o seu programa precise fazer um monte de coisas diferentes.\nVocê __poderia__ colocar tudo em um pedaço longo de código. Mas isso tornaria díficil\nde ler e entender o seu código depois.\n\nAo invés disso, você deve dividir seu código em diferentes métodos e dar a cada métodos\num nome de fácil entendimento. Você irá agradecer a si mesmo depois.\n\nEntão, como definimos um método? Assim:\n\n    def domar( numero_de_megeras )\n    end","load_code":""},
"34":{"lang":"PT-BR","title":"Em Ruby, Def Leppard significa: defina o método Leppard","chapter":"N","answer":"^domar","ok":"Manso não é coxo","error":"","text":"Ei, ok, você fez isso. Você está criando seu próprio método. Você iniciou com def, seguido do nome do método.\nE a lista de argumentos que este método precisará. Isso não é tão assustador e perigoso!\nTudo o que temos que fazer é preenche-lo com Ruby e finaliza-lo com a palavra __end__.\n\nAqui está o código:\n\n    def domar( numero_de_megeras )\n      numero_de_megeras.times {\n        puts \"Megera domada\"\n      }\n    end\n\n> __P.S.__  \n> Se você não pegou o titulo deste capítulo.\n> <a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\n> é o nome de uma, famosa, banda inglesa de rock.","load_code":""},
"35":{"lang":"PT-BR","title":"O Amadurecido Fruto de Sua Própria Criação","chapter":"N","answer":"^Megera domada","ok":"Isso vai mostrar essas megeras","error":"","text":"Um novo método nasceu. Vamos usa-lo agora:\n\n    domar 5","load_code":"def domar(numero_de_megeras);numero_de_megeras.times{puts \"Megera domada\"};end;"},
"36":{"lang":"PT-BR","title":"Dar e Tomar","chapter":"N","answer":"\\d+","ok":"Certo. Bravo.","error":"","text":"Muitos métodos não só precisam de alguns parâmetros de entrada, mas também irão __devolver algo__.\nEu mudei o nosso método um pouco, assim ele irá retornar um valor para você. Tente isso:\n\n    def domar( numero_de_megeras )\n      numero_de_megeras.times {\n        puts \"Megera domada\"\n      }\n      return numero_de_megeras\n    end\n\n    puts domar(3)\n\n### Retorno (Return)\nE, uma vez que você está ficando avançado e capaz aqui, mais uma dica:\nvocê pode omitir a palavra __return__ da última linha do método.\nO Ruby irá automagicamente retornar o valor da última variável usada dentro do método.\n\nAssim, nós podemos mudar a última linha para apenas __numero\\_de\\_megeras__.\n\nMas, uma vez que o método __.times__ também retorna o _numero\\_de\\_megeras_ nós podemos\nremover a última linha inteira. De fato, nosso método original já fazia o que nós queríamos!","load_code":""},
"37":{"lang":"PT-BR","title":"Olá, Quem Está Ai? E Sumário #5 Segura o Chapéu!","chapter":"Y","answer":"","ok":"","error":"","text":"Muito bem, muito bem, muito bem, muito bem!\n\nVerdadeiramente, verdadeiramente, verdadeiramente, verdadeiramente, verdadeirameeeeeente!\n\nAqui estão os últimos minutos da nosa vida revisados:\n\n### Métodos\nMétodos podem ser definidos com __def__ e têm um nome. Métodos tornam os seus programas mais curtos\ne fáceis de ler.\n\n### Parâmetros\nMétodos podem receber parâmetros.\n\n### Retornar valores\nMétodos (quase) sempre retornam valores.\n\n## Agora\n(Ser) ou não (ser) não é mais uma dúvida para você. Você está pronto para um pouco mais de Shakespare?","load_code":""},
"38":{"lang":"PT-BR","title":"O mundo é nossa ostra","chapter":"N","answer":"^\\{\\\"William","ok":"Bom. Um pouco díficil de ler.","error":"","text":"Até agora, rodamos apenas programas que utilizam apenas coisas digitadas por nós mesmos.\nO que é bom, quero dizer que _OdeLaying_ foi épico. Mas a era da internet é sobre um tempo\nem que nos esforçamos para incluir o resto do mundo em nossos programas.\n\nMuitos, muitos, muitos sites estão disponíveis para você solicitar informação. Por exemplo, este link\nirá lhe fornecer todo o atual <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Google news feeds</a>\nsobre Ruby.\n\nSeu browser provavelmente irá exibi-lo corretamente para você. Se você olhar o código fonte\n(digite: control-U), você verá uma string longa de um texto estranhamente formatado. No exemplo do Google,\neste texto está no formato __rss__\n\n### Formatos\nExistem muitos outros formatos, com nomes estranhos, disponíveis e utilizados na web. Como:\nhtml, xml e json. Sim, mesmo este website tem um monte desses.\n\nEu preparei um método para você que lhe permitirá buscar, da internet, uma lista com os trabalhos concluídos de\nWilliam Shakespeare.\n(Não se preocupe, isto vem do mesmo webserver que este site roda, então não estamos incomodando ninguém).\n\nPegue os dados com:\n\n    get_shakey","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"PT-BR","title":"Noble Kinsmen","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Assim é bem melhor","error":"","text":"Ok, agora nós temos a lista de peças obtidas da internet. A lista está em formato json.\nFelizmente, para nós, o Ruby, gentilmente, fornece um método para converter json em Hash.\nO método _get\\_shakey_ já faz isso para nós\n\nMas, uma vez que a estrutura do json é convertida em um hash, ela se torna um pouco difícil de ler.\nVamos então escrever um método para exibir as peças de forma legível.\n\nSe você olhar a lista de peças cuidadosamente, você verá que há um tipo de estrutura identada.\nAtualmente, isso é comum em dados que você obtém da internet. Parece como isso:\n\n<ul>\n  <li>\"William Shakespeare\"\n  <ul>\n      <li>\"1\"\n      <ul>\n        <li>\"title\": \"The Two Gentlemen of Verona\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>\"2\"\n      <ul>\n        <li>\"title\": \"The Taming of the Shrew\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>...</li>\n  </ul>\n  </li>\n</ul>\n\nPara listar as peças, primeiro nós temos que acessar o elemento do topo do hash, \"William Shakespeare\", pelo seu nome.\nEm seguida, temos que __iterar__ através de cada elemento abaixo deste.\n\nO Ruby tem um método para iterar. Ele é chamado de __each__ (significa cada). Nós já o vimos antes\nquando criamos nosso sistema de avaliação de livros.\n\nTudo que o método __each__ retorna é passado para o bloco:\n\n    s = get_shakey\n\n    s[\"William Shakespeare\"].each { |key, val|\n      puts val[\"title\"]\n    }","load_code":"prev"},
"40":{"lang":"PT-BR","title":"Tudo junto agora","chapter":"N","answer":"^4$","ok":"Sim, Shakespeare escreveu 4 peças em 1591","error":"A resposta para o ano 1591 deve ser 4","text":"Agora, suponha que nós desejamos saber apenas os nomes e a quantidade de peças escritas\npor Shakespeare em um determinado ano.\n\nO Ruby nos permite selecionar (__select__) valores do hash. O método __select__ usa um bloco\npara nos deixar definir o que selecionar, e retorna o que for encontrado.\n\nNós podemos usar o resultado retornado pelo método __select__ no método __each__ simplesmente\nadicionando-o após o bloco do __select__. Este é outro exemplo de encadeamento de métodos, que nós\nvimos antes ao inverter o poema.\n\nEu preparei o método __count\\_plays__ (plays significa peças) para você. Veja se você consegue descobrir\nquantas peças foram escritas por Shakespeare no ano __1591__. Tente isso:\n\n    def count_plays(year)\n      s = get_shakey\n\n      s[\"William Shakespeare\"]\n        .select { |k, v|\n          v[\"finished\"] == year\n        }.each { |key, val|\n          puts val[\"title\"]\n        }.count\n    end\n\n    puts count_plays(0)\n\nVocê notou que eu encadeei o método __count__ ao final do método __each__? Isto nos dá o valor\nde retorno para o método __count\\_plays__.\n\nExiste uma outra possibilidade de encadeamento aqui. Veja esta linha __s = get_shakey__.\nVocê pode adicionar o __[\"William Shakespeare\"].select { |k, v|__ ao final do __get_shakey__\n(nesse caso, não é preciso colocar o ponto).","load_code":"prev"},
"41":{"lang":"PT-BR","title":"Tudo Fica Bem Quando Termina Bem","chapter":"N","answer":"All's Well That Ends Well","ok":"True","error":"Use 1605 como segundo parâmetro","text":"Ok, nós pegamos alguns dados da internet, nós selecionamos o que nós queríamos e imprimimos na tela.\nO que falta melhorar? Nós poderíamos ter impresso os resultados de forma um pouco mais bonita. Como adicionar\no ano e alinhar títulos e anos.\n\nIsso significa imprimir vários valores em uma linha. O Ruby possui um jeito puro\nde fazer isso. É exatamente como imprimir uma string: __puts \"Olá, meu nome é Ricardo\"__.\nMas, ao invés de utilizarmos o valor literal _Ricardo_, nós usaremos o valor da variável.\n\nEm primeiro lugar, substitua __Ricardo__ por __#{}__. Se o Ruby ver o símbolo hash # seguido de chaves {\nele procurará por uma variável entre a abertura e o fechamento da chave }.\nNós podemos usa-lo desta forma: __\"Olá, meu nome é \\#{nome}\"__  \n\nVamos alterar um pouco o nosso código\n\n    def print_plays(year_from, year_to)\n      get_shakey[\"William Shakespeare\"]\n        .select { |k, v|\n          year_from <= v[\"finished\"] &&\n          year_to   >= v[\"finished\"]\n        }.each { |k, v|\n          puts \"#{v[\"title\"].ljust(30)} #{v[\"finished\"]}\"\n        }\n    end\n    print_plays(1600, 1605)\n\nEu adicionei __.ljust(30)__ ao título. Desta forma o título é _justificado a esquerda_ com um minímo de\n30 caracteres (assim os anos ficam alinhados).\n\nVeja se você pode mudar a saída do programa para que ele exiba as peças desta forma: __1600 -> As You Like It__\n\n__Tudo Fica Bem Quando Termina Bem ?__ Ei, nós não terminamos ainda, mas o fim está a vista !","load_code":"prev"},
"42":{"lang":"PT-BR","title":"Se eu pelo menos soubesse como tomar uma decisão","chapter":"N","answer":"","ok":"","error":"","text":"Tomar uma decisão, na vida real isso pode ser um problema. Não para nós.\nO Ruby faz a tomada de decisões ser muito fácil.\n\n    if 1 < 2\n      puts \"É verdade: 1 é menor que 2\"\n    end\n\nA palavra chave aqui é __if__ (se). O __if__ pode ser posicionado antes de um método ou depois de um método, por exemplo:\n\n    puts \"É verdade que: 1 é menor que 2? \" if 1 < 2\n\n__If__ é um método que requer um parâmetro. Este parâmetro pode ser qualquer expressão que você queira\ntestar. A saída da expressão, no entanto, deve ser __true__ (verdadeiro) ou __false__ (falso).\nAqui estão um monte de expressões e suas saídas:\n\n    5     <= 10     # => true\n    'abc' == 'def'  # => false\n    true            # => true\n    123456          # => true\n    0               # => true\n    nil             # => false\n    'xyz'.empty?    # => false\n    'a' > 5         # => error:\n                    # comparison of String with\n                    # Numeric failed\n\nA _expressão if_ pode tomar muitas formas. Ela pode comparar valores literais (1 < 2),\nvariáveis (a < 1) e o retorno de um método ('xyz'.empty?).","load_code":""},
"43":{"lang":"PT-BR","title":"E agora para a conclusão surpreendente","chapter":"N","answer":"não é igual a 100$","ok":"Isso é melhor","error":"Isso não pode estar certo","text":"Você viu os dois sinais de igual em __'abc' == 'def'__ ?\n\nEste __==__ significa __é igual a__.\nUm único sinal de igual que nós vimos antes significa __atribua o valor a variável__.\n\nPara tornar isto um pouco mais confuso, você pode usar a atribuição após um método if, por exemplo:\n\n    a = 0\n\n    if a = 100\n      puts \"A expressão é verdadeira, mas agora a é: #{a}\"\n    else\n      puts \"#{a} não é igual a 100\"\n    end\n\nTroque o = por == e veja o que acontece.\n\nEu posso garantir que você irá esquecer de digitar o segundo sinal de igual regularmente. Eu também\nesqueço dele as vezes.\n\n### else\nNo código acima eu adicionei o else a expressão. Esta parte será executada quando a\n__expressão teste do if__ retornar false.\n\n> Existem mais variações para este tema if-then-else. Você pode ler mais\n> <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">aqui</a>.","load_code":""},
"44":{"lang":"PT-BR","title":"Mim fome","chapter":"N","answer":"^Mim sem fome","ok":"Sim","error":"De jeito nenhum eu estou com fome as 10 da manhã !","text":"Ok,\nOkay, isso, enfim, está ficando maravilhoso. Isto é uma coisa simples para você, mas tenha em mente que você\nnão sabia __nada de Ruby__ a apenas 15 minutos atrás.\n\nÚltimo passo,\nLast step. Vamos colocar tudo isso junto, sabe? Vamos colocar tudo isso para brilhar junto\ncomo reluzentes sinos na praia brilhando sob a luz do sol.\n\nNós vamos definir dois métodos primeiro, e então tomaremos uma decisão:\n\n    def fome?(hora_do_dia)\n      puts \"Mim fome\"\n      true\n    end\n\n    def comer_um(o_que)\n      puts \"Mim comer #{o_que}\\n\"\n    end\n\n    comer_um 'maçã' if fome?(14)\n\n    comer_um 'maçã' if fome?(10)\n\nAgora, veja se você consegue alterar o método __fome?__ para exibir __\"Mim sem fome\"__ e retornar falso\nquando a hora for menor que 12.","load_code":""},
"45":{"lang":"PT-BR","title":"Sumário #6 Que Significa Que Você Foi Bem Longe","chapter":"Y","answer":"\\{\\}","ok":"Ok, é um Hash vazio","error":"","text":"Você é um clérigo Ruby level 6. Quero dizer, que grande trabalho você fez. Vamos revisar:\n\n### Dados\nVocê carregou alguns dados da internet,\n\n### Iterando\nVocê iterou todos os elementos de um hash e você encadeou alguns outros métodos.\n\n### Imprimindo Bonito\nE como se isso não fosse o bastante, você formatou e imprimiu alguns valores de uma forma\nque é fácil para humanos ler. De fato, __você fez um programa real!__\n\n### IF\nVocê aprendeu a tomar o controle dos seus programas com declarações de __if__ e __else__.\n\n## Então\nO que é possível fazer em seguida? O que é possível que você ainda tenha que aprender agora?\nHa! Esta é a melhor parte. Você percorreu um caminho tão grande que agora vamos revelar as classes.\nApenas mais duas lições curtas, e acabou.\n\nMais cedo, nós criamos um Hash desta forma:\n\n    Hash.new","load_code":""},
"46":{"lang":"PT-BR","title":"Não Uma Classe de Escola, uma Classe Trabalhadora","chapter":"N","answer":"","ok":"","error":"","text":"Veja, as chaves vazias são um atalho para Hash.new. O método new é usado para criar objetos de uma determinada classe.\nPense em \"classe\" como \"classe trabalhadora\", um grupo específico de objetos que são similares,\ntem o mesmo trabalho, e usam as mesmas roupas.\nO que uso é uma classe ?\n\n### Blurbalizer<sup>TM</sup>\nVocê acabou de ter uma brilhante idéia para um novo aplicativo. Ele será __a__ nova plataforma\nde mensagens instantâneas. Você quer um aplicativo onde as pessoas possam enviar curtas mensagens para as outras.\nVocê chama isso de Blurbs<sup>TM</sup>. Os Blurbs<sup>TM</sup> permite o tamanho máximo de apenas 40 caracteres.\nVamos fazer algumas configurações de humor também.\n\n\n### Onde começar\nBem, você deve armazenar seus Blurbs<sup>TM</sup> em um arquivo json, certo?\nMas como você poderia manter o rastreamento do conteúdo e da hora em que foi postado?\nE quando o arquivo foi carregado, como isso ficaria no Ruby?\nIsto deveria ser um Hash? Ou um Array? Ou um Array de Arrays? Ou algo diferente?\n\n### Class\nEu realmente acho que você vai querer usar uma classe. Você já está familiarizado com várias classes:\nHash, Array, String.\nVamos criar uma nova classe (não tem retorno):\n\n    class Blurb\n    end","load_code":""},
"47":{"lang":"PT-BR","title":"As Coisas Das Quais Os Apps São Feitos","chapter":"N","answer":"","ok":"","error":"","text":"Você abriu a nova Blurb<sup>TM</sup> class. Do que a entrada do seu blog é feita?\nDe conteúdo, claro. Também, a hora em que o Blurb<sup>TM</sup> foi postado. E o humor.\n\nOk, então você tem a primeira linha da sua classe, aqui está o resto:\n\n    class Blurb\n      attr_accessor :conteudo, :hora, :humor\n    end\n\nNomes de classes sempre começam com letra maiúscula.\n\n(Continua sem saída na tela)","load_code":""},
"48":{"lang":"PT-BR","title":"Acessores São Os Membros Pendurados","chapter":"N","answer":"Blurb:","ok":"Meu primeiro Blurb","error":"","text":"Hey, boa classe cara. Você tem uma nova classe Blurb<sup>TM</sup>.\n\nNa definição de classe, você usou o método chamado attr\\_accessor.\nExistem vários métodos de __attr__ibutos como esse que adicionam pequenas configurações as classes.\nEsses atributos são apenas variáveis amarradas a classe.\n\nPense desta forma. A classe é uma pessoa. Aquela coisa humana em forma de estrela lá fora.\nE os atributos são os membros pendurados, as diferentes partes que mantém o corpo de pé e\nque permitem que as pessoas apertem as mãos umas das outras.\n\n### Agora\nPara criar um Blurb<sup>TM</sup> e definir seu conteúdo:\n\n    blurb1 = Blurb.new\n    puts blurb1\n    blurb1.conteudo = \"Hoje, Mount Hood foi roubado!\"","load_code":"class Blurb;attr_accessor :conteudo,:tempo,:humor;end"},
"49":{"lang":"PT-BR","title":"Um Objeto, Este Pequeno Pacote Puro","chapter":"N","answer":"Blurb:","ok":"Blurb Atualizado","error":"","text":"Vá em frente e defina o tempo e o humor do seu Blurb<sup>TM</sup>:\n\n    blurb1.tempo = Time.now\n    blurb1.humor = :doente\n\n    puts blurb1","load_code":"prev;blurb1=Blurb.new;blurb1.conteudo=\"Hoje, Mount Hood foi Roubado!\""},
"50":{"lang":"PT-BR","title":"Apressando as Coisas","chapter":"N","answer":"^\\d{4}","ok":"Notável","error":"","text":"Legal, seu app é sensacional. Ei, vamos tornar as coisas um pouco mais fáceis para você.\nVocê não quer definir a hora desta forma toda vez que você postar um Blurb<sup>TM</sup>.\n\nVocê quer apenas digitar o conteúdo e definir o humor, certo?\n\nVamos adicionar um método __initialize__ na nossa classe. Este método é chamado sempre que um novo Blurb<sup>TM</sup> é criado.\nAo mesmo tempo, nós queremos limitar o tamanho do conteúdo do BLurb<sup>TM</sup> para apenas 40 caracteres.\n\n    class Blurb\n      attr_accessor :conteudo, :tempo, :humor\n\n      def initialize(humor, conteudo=\"\")\n        @tempo    = Time.now\n        @conteudo = conteudo[0..39]\n        @humor    = humor\n      end\n    end\n\n    Blurb.new.tempo\n\n(Este parâmetro conteudo=\"\"__ está aqui para garantirmos que o conteúdo é uma string,\nmesmo se nenhum conteúdo for passado como parâmetro para o método initialize)","load_code":""},
"51":{"lang":"PT-BR","title":"Você Ensinou Seu App a Desprezar Coisas Sem Valor","chapter":"N","answer":"Blurb:","ok":"Blurb adicionado","error":"","text":"Você viu como usamos os simbolos arroba dentro da classe (@tempo)?\n\n__Fora__ da classe, nós usamos o acessor:\n\n> __blurb.tempo = Time.now__\n\nmas __dentro__ nós usamos __a variável objeto__:\n\n> __@tempo = Time.now__\n\nEles são exatamente a mesma coisa, mas são representados em dois locais diferentes do programa.\n\n### Crie outro Blurb<sup>TM</sup>\nQuando um novo Blurb<sup>TM</sup> é criado, o método initialize é usado para verificar\npor algum argumento para o new.\n\nUh, nós precisamos de dois argumentos:\n\n    Blurb2 = Blurb.new :confuso, \"Eu não posso acreditar que Mt. Hood foi roubado!\"","load_code":"class Blurb;attr_accessor :conteudo,:tempo,:humor;def initialize(humor, conteudo=\"\");@tempo=Time.now;@conteudo=conteudo[0..39];@humor=humor;end;end;blurb1=Blurb.new(:doente,\"Hoje, Mount Hood foi roubado!\")"},
"52":{"lang":"PT-BR","title":"Uma Girafa Não Roubou o Sumário #7","chapter":"Y","answer":"","ok":"","error":"","text":"Aha! Você está aqui. E inteiro. Nós vamos continuar a fazer o seu app real, mas enquanto isso,\nvamos revisar ok?\n\n### Classes\nTudo em Ruby é algum tipo de objeto. Classes explicam objetos, como um certo tipo de objeto funciona.\nPor exemplo, você criou alguns objetos Blurb<sup>TM</sup> e esses objetos são explicados na classe Blurb.\nEm outras palavras: você os chama de objetos Blurb.\nVocê pode usar classes (meio que) para modelar objetos da vida real\n\n### Acessores\nAcessores são variáveis atreladas a um objeto que podem ser usadas __fora__ do objeto.\n(blurb2.tempo = Time.now)\n\n### Variáveis de objeto\nVariáveis de objeto são as mesmas variáveis que você está utilizando com os acessores, porém, __dentro__ do objeto.\n(@tempo = Time.now)","load_code":"prev;blurb2=Blurb.new :confuso, \"Eu não posso acreditar que Mt. Hood foi roubado!\""},
"53":{"lang":"PT-BR","title":"Seu próprio gramado","chapter":"N","answer":"Blurbalizer:","ok":"Meu app foi criado","error":"","text":"Ok, vamos embrulhar as coisas, garoto. Este é o último capítulo da EMOCIONANTE e épica história do Try Ruby!\nAgora que você já sentiu o gostinho de como tudo funciona, como nós vamos usar isso em volta da casa e no freezer\nda sua mercearia?\nVocê é uma grande pessoa (uma das minhas favoritas), mas você precisa de orientação.\n\n### Vamos finalizar seu app\nSeu app tem entradas, mas não está completo.\nEle ainda precisa de um título, algum lugar para armazenar todos os Blurbs<sup>TM</sup> e uma timeline para funcionar adequadamente.\n\nTente advinhar, nós vamos usar outra classe. Eu estou lhe dando todo o código da nova classe de uma vez.\nEstude-a __no seu tempo__, sem pressa.\nEu não estou com pressa, eu irei esperar você para a sua próxima lição.\n\n    class Blurbalizer\n      def initialize(titulo)\n        @titulo  = titulo\n        @blurbs = [] # Um array fresquinho e limpo\n                     # para armazenar os Blurbs\n      end\n\n      def adicionar_um_blurb(humor, conteudo)\n        # O << significa adicionar ao array\n        @blurbs << Blurb.new(humor, conteudo)\n      end\n\n      def exibir_timeline\n        puts \"Blurbify: #{@titulo} tem #{@blurbs.count} Blurbs\"\n\n        @blurbs.sort_by { |t|\n          t.tempo\n        }.reverse.each { |t|\n          puts \"#{t.conteudo.ljust(40)} #{t.tempo}\"\n        }\n      end\n    end\n\n    meuApp = Blurbalizer.new \"O Grande Blurb\"","load_code":"class Blurb;attr_accessor :conteudo,:tempo,:humor;def initialize(humor, conteudo=\"\");@tempo=Time.now;@conteudo=conteudo[0..39];@humor=humor;end;end"},
"54":{"lang":"PT-BR","title":"Sobre o que Blurb's são?","chapter":"N","answer":"Hoje","ok":"Que venham os blurbs","error":"","text":"Aqui está você. Você percebeu tudo que o código da classe Blurbalizer<sup>TM</sup> faz?\n\n> Na classe Blurbalizer<sup>TM</sup> existem dois __métodos__ (adicionar\\_um\\_blurb e exibir\\_timeline)\n> Você pode usar um método fora da classe, da mesma forma como fizemos com os acessores.\n\nHora de começar a usar o Blurbalizer<sup>TM</sup>. Eu já carreguei alguns Blurbs<sup>TM</sup> para você,\nmas sinta-se a vontade para adicionar os seus próprios.\n\nNós não estamos mais criando Blurbs<sup>TM</sup> diretamente, ao invés disso nós estamos usando o __método__\nadicionar\\_um\\_blurb da classe Blurbalizer<sup>TM</sup>. Desta forma, nós podemos ter certeza que todos os Blurbs<sup>TM</sup>\nsão armazenados no objeto meuApp.\n\n    meuApp.adicionar_um_blurb :temperamental, \"Adicione um Blurb aqui\"\n\n    meuApp.exibir_timeline","load_code":"prev;class Blurbalizer;attr_reader :titulo;def initialize(titulo);@titulo=titulo;@blurbs=[];end;def adicionar_um_blurb(humor, conteudo);@blurbs << Blurb.new(humor, conteudo);@blurbs.each {|t| t.tempo -= 73};end;def exibir_timeline;puts \"Blurbalizer: #{@titulo} tem #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.tempo}.reverse.each { |t| puts \"#{t.conteudo.ljust(40)} #{t.tempo}\"};end;end;meuApp = Blurbalizer.new \"O Grande Blurb\";meuApp.adicionar_um_blurb :doente,\"Hoje Mount Hood Foi Roubado!\";meuApp.adicionar_um_blurb :confuso,\"Eu não posso acreditar que Mount Hood Foi Roubado!\";meuApp.adicionar_um_blurb :atordoado,\"Estou sem palavras!\";meuApp.adicionar_um_blurb :enlouquecido,\"Ele foi roubado por uma GIRAFA !!\";meuApp.adicionar_um_blurb :triste,\"Eu deixei meu chapéu na montanha!\";meuApp.adicionar_um_blurb :enlouquecido,\"Eu nunca mais voltarei as montanhas.\""},
"55":{"lang":"PT-BR","title":"Isto é tudo sobre combinar","chapter":"N","answer":":-","ok":"Temperamental !","error":"","text":"Algumas coisas maravilhosas podem ser feitas com simples partes de Ruby, especialmente quando você combina\nelas em coisas novas.\nAqui nós temos um app feito de uma classe, que contém outra classe. E, atualmente, Ruby realmente lida direito com\neste tipo de criatura. Isto é chamado de programação orientada a objetos.\n\nEnfim chegamos ao __último exercício de programação__ do TryRuby. Se você quiser, você pode adicionar mais\nfuncionalidades ao Blurbalizer<sup>TM</sup>.\n\nTalvez você deseje imprimir o humor como um smiley e exibi-lo no método __exibir\\_timeline__. Você também pode\nadicionar o método _modificar_ a sua classe Blurb<sup>TM</sup> e então usa-lo dentro do método __exibir\\_timeline__:\n\n    class Blurb\n      attr_accessor :conteudo, :tempo, :humor\n\n      def initialize(humor, conteudo=\"\")\n        @tempo    = Time.now\n        @conteudo = conteudo[0..39]\n        @humor    = humor\n      end\n\n      def modificar\n        if    @humor == :triste\n          return \":-(\"\n        elsif @mood == :feliz\n          return \":-)\"\n        # E outros humores aqui\n        end\n\n        # O humor padrão\n        \":-|\"\n      end\n    end\n\n    class Blurbalizer\n      def initialize(titulo)\n        @titulo  = titulo\n        @blurbs = []\n      end\n\n      def adicionar_um_blurb(humor, conteudo)\n        @blurbs << Blurb.new(humor, conteudo)\n      end\n\n      def exibir_timeline\n        puts \"Blurbalizer: #{@titulo} tem #{@blurbs.count} Blurbs\"\n\n        @blurbs.sort_by { |t|\n          t.tempo\n        }.reverse.each { |t|\n          puts \"#{t.conteudo.ljust(40)} #{t.tempo}\"\n        }\n      end\n    end\n\n    meuApp.exibir_timeline","load_code":"prev"},
"56":{"lang":"PT-BR","title":"Sumário #8, O Sumário do Ei-Relaxa-Você-Foi-Bem","chapter":"Y","answer":"","ok":"","error":"","text":"Esta última sessão é um momento para relaxar, para lhe dar alguma direção sobre como você pode usar o Ruby.\n\nSe você gostou, você pode continuar com o <a href=\"/playground\">TryRuby Playground</a> ou baixar e instalar o Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a>\n\nUma vez que você tenha o Ruby instalado, você poderá criar um arquivo, digamos _meu\\_primeiro\\_programa.rb_, usando um editor de texto,\nescrever algum código Ruby e então roda-lo. Para roda-lo abra o prompt de comando e digite:\n\n    ruby meu_primeiro_programa.rb\n\nExistem várias ferramentas (gratuitas) de desenvolvimento disponíveis para combinar um editor, explorador de arquivos\ne um 'ruby-runner'.\n\n## Comemore\nVocê realmente merece comer um bolo de camada dupla, com duplo sorvete, enquanto um cara toca uma daquelas guitarras que na verdade são guitarras duplas.\nQuero dizer, você terminou. Você realmente terminou! Não há duvidas sobre isso, você é um __sangue-vermelho espertão certificado!__\n\n## Mais informações\nExistem um monte de ótimos artigos neste site. Eles podem lhe dar um norte sobre para onde ir a partir daqui.","load_code":"def ruby(f);puts \"Vá para www.ruby-lang.org para baixar o Ruby\";end;class K;attr_reader :rb;end;meu_primeiro_programa=K.new"}}