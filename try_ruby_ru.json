{"1":{"lang":"RU","title":"Есть 30 минут? Дай Ruby шанс, и он тебя удивит!","chapter":"Y","answer":"","ok":"","error":"","text":"Ruby - это язык программирования из Японии, который произвел революцию в веб-разработке.\n\nПрелесть Ruby в балансе между простотой и возможностями.\n\nТы можешь ввести код на Ruby в редакторе и использовать кнопки для навигации:\n\n\n- __Run__ &rarr; Выполнить код, находящийся в редакторе\n- __Copy__ &rarr; Вставить/скопировать пример кода в редактор\n- __Next__ &rarr; Перейти к следующему уроку\n- __Back__ &rarr; Вернуться к предыдущему уроку\n- __Clear__ &rarr; Очистить редактор\n\nИспользуй кнопку 'world' button <span aria-hidden=\"true\" class=\"glyphicon glyphicon-globe\"></span>\nчтобы изменить язык TryRuby.\n\n### Нажми __Next__ для начала обучения.","load_code":""},
"2":{"lang":"RU","title":"Использование редактора","chapter":"N","answer":"^\\d{1,}$","ok":"Отлично! Вы немного попрактиковались в математике.<br/>Видите полученный результат?","error":"Наберите 2 + 6 в редакторе","text":"Набирайте свой код на Ruby в окне редактора снизу, затем нажмите кнопку __Run__ и посмотрите его работу!\n\nНапример, попробуем посчитать простое выражение:\n\n    2 + 6\n\nРезультат вашей программы должен отображаться в окне вывода вверху.\nНа следующей строке будет отображаться, настолько хорошо Вы справились.\n\n\n> Также Вы можете нажать кнопку __Copy__, чтобы скопировать код из примера в редактор.","load_code":""},
"3":{"lang":"RU","title":"Числа и математика","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Хорошо!","error":"","text":"Ruby понимает числа и математические операции. Попробуйте их использовать, как в примере:\n\n    4 * 10\n    5 - 12\n    30 / 4","load_code":""},
"4":{"lang":"RU","title":"Выводим результат иначе","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Отлично!","error":"","text":"Вы заметили, что если Вы набираете более одного выражения, выводится результат только последнего.\nЧто же происходит?\n\n> Для более удобного использования этого сайта, я указал Ruby копировать результат вашей программы\n> в поле вывода вверху. Так когда Вы набираете выражение, результат выводится на экран.\n> __Но только последний результат.__ И только если до этого ничего не выводилось\n\nТак когда Вы вводите несколько выражений, Ruby показывает результат только последнего\n\nКонечно, Вам хочется увидеть результат всех! Добавьте __puts__ перед каждым выражением\n(разделяя пробелом). Puts означает: *'вывести что-то на экран'*.\n\nПопробуйте:\n\n    puts 4 * 10\n    puts 5 - 12\n    puts 30 / 4\n\nА теперь удалите __puts__ из последней формулы и посмотрите, что произойдет.","load_code":""},
"5":{"lang":"RU","title":"Скажи свое имя!","chapter":"N","answer":"[a-zA-Zа-яА-Я]{1,1}","ok":"Отлично, Вы сформировали строку из букв Вашего имени.","error":"","text":"Конечно, компьютеры удобны для расчетов. Но давайте попробуем что-то еще. А хотите вывести свое имя задом наперед?\n\nДля начала наберите свое имя в кавычках как тут:\n\n    \"Иван\"","load_code":""},
"6":{"lang":"RU","title":"Скажи свое имя наоборот","chapter":"N","answer":"\\w+","ok":"!отурК","error":"","text":"Строка представляет собой набор символов, которые компьютер может обрабатывать. Представьте, что буквы, находящиеся в строке, - это \nбелье на верёвке, а кавычки - прищепки, держащие концы этой веревки. Кавычки обозначают начало и конец.\n\nЧтобы получить имя задом наперед, наберите: \n\n    \"Ivan\".reverse\n\n(И не забудьте про точку!)","load_code":""},
"7":{"lang":"RU","title":"Подсчет букв","chapter":"N","answer":"^\\d+$","ok":"Ага! length - это тоже метод!","error":"","text":"Вы уже попробовали использовать __method__ reverse на своем имени! Заключив имя в кавычки, Вы создали строку. Затем Вы вызвали метод reverse, который работает со строками и разворачивает ее задом наперед.\n\nА теперь давайте посмотрим, сколько букв в Вашем имени:\n\n    \"Ivan\".length","load_code":""},
"8":{"lang":"RU","title":"На повторе","chapter":"N","answer":"(\\w+)","ok":"Рад Вас видеть. Рад Вас видеть. Рад Вас видеть.","error":"adfadsfadsf","text":"Сейчас Вам, наверное, интересно, зачем это нужно.\n\nЧто ж, я уверен, Вы хоть раз замечали на сайте надпись: __Эй, твой пароль слишком короткий!__\n\nСмотрите, некоторые программы используют код __.length__.\n\nА теперь рассмотрим это. Давайте выведем Ваше имя 5 раз\n\n    \"Ivan\" * 5","load_code":""},
"9":{"lang":"RU","title":"Подводим итоги #1 Уже","chapter":"Y","answer":"NoMethodError|undefined","ok":"Неа, нельзя использовать метод reverse с числом. Жми 'next'","error":"","text":"Давайте посмотрим, что Вы уже изучили.\n\n### Редактор кода\nМожно набирать код в редакторе и получать ответ в окне вывода.\nБольшинство программ выдают ответ.\n\n### Числа и строки\nЧисла и строки это математические и текстовые объекты в Ruby.\n\n### Методы\nВы попробовали использовать методы из слов на английском языке reverse и length. А также символьный\nметод умножения: \\*  \n__Метод значит действие!__\n\nВ этом суть Вашего обучения. Берем базовые вещи, играем с ними и превращаем их в\nнечто новое. Понравилось? Я надеюсь, что да!\n\n## Хорошо\nА давайте попробуем кое-что необычное. Попробуйте применить метод reverse к числу:\n\n    40.reverse","load_code":""},
"10":{"lang":"RU","title":"Остановись, ты сумасшедший!","chapter":"N","answer":"^\\d{1,}$","ok":"Только строки могут быть развернуты задом наперед","error":"","text":"Ты не можешь развернуть число задом наперед.  Я думаю, Вы, конечно можете держать монитор перед зеркалом, но разворачивание числа просто не имеет смысла.\n\nRuby выведет сообщение с ошибкой. Ruby говорит Вам, что не существует метода reverse для чисел.\n\n\nНо можно попробовать преобразовать число 40 в строку для начала:\n\n    40.to_s.reverse","load_code":""},
"11":{"lang":"RU","title":"Яблоки отличаются от апельсинов","chapter":"N","answer":"\\[\\]","ok":"Отлично. Это пустой список.","error":"","text":"И числа отличаются от строк.\n\nВ то время как использование методов применимо ко всем типам, некоторые методы работают только с определенными типами данных.\nНо Вы всегда можете преобразовать один тип в другой, используя методы вида \"to\"\n\n- __to_s__ преобразует в строки\n- __to_i__ преобразует в число\n- __to_a__ преобразует в массив\n\n__Что такое массив?!__\n\nМассив - это всего лишь список. Наберите 2 квадратные скобки:\n\n    []","load_code":""},
"12":{"lang":"RU","title":"Очередь за попкорном","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Прекрасно!","error":"Попробуйте добавить четвертое число в массив.","text":"Списки (массивы) хранят элементы __в определенной последовательности__.\n\nПохоже на очередь за попкорном. Вы стоите за кем-то и не пытаетесь его оттолкнуть или передвинуть, верно?\nТакже человек за Вами \n\nВот список для Вас. Номера лотерейных билетов: \n\n    [12, 47, 35]\n\nПопробуйте добавить число в массив. Наберите запятую и число после 35. Пробел не обязательно.","load_code":""},
"13":{"lang":"RU","title":"Первый поднимает руку","chapter":"N","answer":"^47$","ok":"Хорошо","error":"","text":"Список номеров лотерейных билетов. А какой номер максимальный?\n\nПопробуйте: \n\n    [12, 47, 35].max","load_code":""},
"14":{"lang":"RU","title":"Спрячем список","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Сохранено!","error":"","text":"Хорошо, хорошо. Но неудобно же набирать каждый раз, когда он может понадобиться, не так ли?\n\nДавайте сохраним наши номера лотерейного билета вот так:\n\n    ticket = [12, 47, 35]","load_code":""},
"15":{"lang":"RU","title":"А теперь наберите ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Восстановлен!","error":"","text":"А сейчас наберите:\n\n    ticket","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"RU","title":"Сохранен и спрятан","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Вы отсортировали список!","error":"","text":"Вы положили список номеров в __переменную__, называющуюся ticket.\nНо любое другое имя, такое как _ivanslist_, по-прежнему свободно.\n\nЗанимаясь программированием, Вы заметите, что основная работа связана с переменными\n\nА давайте упорядочим список лотерейных билетов?\n\nИспользуйте: \n\n    ticket.sort!\n    \nУ Вас есть список. Вы отсортировали список. Переменная ticket изменилась.\nА Вы заметили, что у метода __sort!__ на конце стоит восклицательный знак?\nТак Ruby сообщает нам, что переменная ticket будет изменена.\nНичего необычного, просто запомните!","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"RU","title":"Элементы","chapter":"N","answer":"^(12|35|47)$","ok":"Хорошо","error":"Почти","text":"Мы сохранили номера в переменную, а как их получить обратно ?\n\nМы уже видели, как мы можем получить максимальный элемент, используя метод __max__. Также Вы можете\nполучить __first__(первый) или __last__(последний) элемент списка.\nА что если Вы хотите получить какой-то конкретный элемент?\n\n### [ ]\nRuby использует [ ], чтобы нацелиться на элемент.\nКвадратные скобки очень распространены в Ruby.\nОни означают: \"Я ищу ____ \", Готов, целься! \n\nДавайте получим все номера из списка:\n\n    puts ticket[0]\n    puts ticket[1]\n    puts ticket[2]\n\nПочему мы используем [0], [1], [2]?\n\nА не [1], [2] and [3]? Это какой-то японский дзен?\nНет, во многих языках программирования отсчет идет с нуля. Это не только особенность Ruby.\n\n> Небольшое напоминание: Вы можете использовать кнопку copy.","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"RU","title":"Итоги #2 Что тут у нас?","chapter":"Y","answer":"(\\W+|\\w+)","ok":"В рифму?","error":"","text":"Сейчас посмотрим.\n\n### Ошибки\nЕсли вы попробуете сделать число наоборот или другое что-то странное, Ruby скажет об этом.\n\n### Массивы\nМассивы - это списки, хранящие элементы в определенной последовательности.\nМы уже знаем, как создать массив и получить элементы из него.\n\n### Переменные\nПеременные сохраняют значения и дают им имена. Мы используем символ равенства, \nчтобы проделать это. Как тут:\nticket = [14, 37, 18].\n\n### 2/8\nВсего тут 8 разделов. 2 уже позади! Не так-то и сложно, да?\n\nДавайте немного сменим направление. Я практиковался в поэзии и положил\nрезультат в переменную poem. Взгляните. Наберите:\n\n    puts poem","load_code":"poem = \"Мой тост вылетел из моей руки. \\nИ мой тост отправился на луну. \\nНо когда я увидел это по телевизору, \\nЗаправляя наш флаг на комету Галлея, \\nПосле того, как я все-таки захотел съесть его\\n\""},
"19":{"lang":"RU","title":"К сожалению, Вам не понравилась поэзия :(","chapter":"N","answer":"(toast){0}","ok":"Прекрасно!","error":"","text":"Все в порядке. Это не обязательно должно было понравиться Вам. Попробуйте его, будьте моим гостем. Вместо тоста может быть\nпирог или что угодно. Попробуйте это, чтобы увидеть новый вариант поэмы:\n\n    poem.gsub(\"тост\", \"медовик\")\n\nМетод __gsub__  это сокращение global substitute (заменитель). Он заменяет все совпадения \"тост\" на\n\"медовик\".","load_code":"prev"},
"20":{"lang":"RU","title":"Готов, целься!","chapter":"N","answer":"^\\nоге ьтсеъс летохаз (.+)","ok":"Конечно, все стихотворение развернуло задом наперед.","error":"","text":"Вот вопрос, что произойдет:\n\n    poem.reverse","load_code":"prev"},
"21":{"lang":"RU","title":"Слишком много слов наоборот","chapter":"N","answer":"^\\[\"После того, как я (.+)","ok":"Да, то что нужно!","error":"","text":"Что ж, все стихотворение стало задом наперед. Слово за словом! Но я хочу всего лишь сделать это для строк.\nПереместим первую строку в конец, а последнюю в начало.\n\nТеперь делаем так:\n\n    poem.lines.reverse","load_code":"prev"},
"22":{"lang":"RU","title":"Еще немного методов","chapter":"N","answer":"^После того, как я (.+)","ok":"Отлично, мой друг!<br/>Метод join взял строки из этого массива и соединил их в строку.","error":"","text":"Что Вы видите? Что произошло? Вы набрали __poem.lines.reverse__ и что случилось?\n\nДва события произошло. Первое: вы разбили стихотворения на строки, используя метод lines, \nи получили массив из них.\n\nЗатем Вы развернули этот лист задом наперед. Вот и все!\n\nДавайте добавим еще один метод в конец:\n\n    puts poem.lines.reverse.join\n\nКомбинирование методов называется: цепочка методов.","load_code":"prev"},
"23":{"lang":"Ru","title":"Итоги #3 Здесь и сейчас","chapter":"Y","answer":"\\{\\}","ok":"Вы создали пустой hash (словарь)!","error":"","text":"### Восклицательный знак\nМетоды могут иметь восклицательные знаки(и также вопросительные) в своем имени.\nОни для более понятного объяснения, что они делают. Ничего страшного.\n\n### Манипуляции со строками\nПоиск и изменение строк\n\n### Цепочки\nЦепочки методов позволяют сделать намного больше. Разбить стихотворение, развернуть его, воссоединить в строку:\n__poem.lines.reverse.join__\n\n\nНа этом этапе, Вы можете посмотреть про ВСЕ методы для строк <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">тут</a>.\n\nВернитесь и попробуйте например это:\npoem.downcase или poem.swapcase\n\n## Готовы?\nКогда вы будете готовы двигаться дальше, наберите:\n\n    books = {}","load_code":"prev"},
"24":{"lang":"RU","title":"Пустой hash","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Вот и новый отзыв.","error":"Используйте один из: splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>Не забывайте про двоеточие.","text":"Мы создали пустой __hash__. Hash - это как массив, только у каждого элемента есть имя.\n> Примечание переводчика: в русскоязычном сообществе слово hash никак не переводится. Если Array переводят как массив, то Hash остается хэш.\n> Название hash идет от hash-функции, на основе которой работает hash, и которая позволяет очень быстро находить элемент по ключу(имени). Но для того, чтобы использовать hash, нам не обязательно этого знать.\n\nМы собираемся написать несколько миниатюрных отзывов в новый hash. Вот наша рейтинговая система:\n\n- :splendid &rarr; ШЕДЕВР!\n- :quite\\_good &rarr; Понравилась!\n- :mediocre &rarr; На троечку!\n- :quite\\_not\\_good &rarr; Плохо!\n- :abysmal &rarr; УЖАСНО!\n\nЧтобы оценить книгу, добавьте название в квадратных скобках и поставьте оценку после знака равно.\nПример:\n\n    books[\"Война и мир\"] = :splendid\n\n> Сейчас, я считаю необходимым сказать, что все уроки в TryRuby отделены друг от друга.\n> Так, если вы решили сделать очень много отзывов, то использовать их все равно сможете только в этом уроке.\n> Если вы хотите использовать свои отзывы в следующем уроке, вы должны скопировать их и вставить.\n> Не беспокойтесь об этом слишком сильно, у каждого урока есть много предопределенных вещей для вас, чтобы поиграть.","load_code":"books = {}"},
"25":{"lang":"RU","title":"Еще несколько простых отзывов","chapter":"N","answer":"[3-9]","ok":"Отлично, смотрите: метод length работает на строках, словарях и массивах.","error":"","text":"Продолжайте, заполните его отзывами. И, если вы хотите увидеть весь список, просто введите: __puts books__\n\nОпять же, возможные оценки: :splendid, :quite\\_good, :mediocre, :quite\\_not\\_good and :abysmal.\n\nЭти оценки не являются строками. Когда вы помещаете двоеточие перед простым словом, вы получаете __Symbol__.\nSymbol дешевле строк (с точки зрения компьютерной памяти). Если вы используете слово снова и снова в своей программе,\nиспользуйте Symbol. Вместо того, чтобы иметь тысячи копий этого слова в памяти, Ruby будет хранить Symbol только\n__один раз__.\n\nЧто еще более важно, Symbol говорит вам, что это не просто старое слово, но и то, что оно имеет смысл в вашей программе.\n> Примечание переводчика: в английском языке есть два слова: Symbol и Chars, и оба переводятся на русский как символ(ы).  \n> В контексте Ruby Symbol правильно было бы перевести как \"идентификатор\", но в разговоре используют слово символ. \n> Поэтому если в контексте Ruby вы услышите \"символ\", то скорее всего это Symbol, идентификатор, который записывается как :good, и является оптимизированной для памяти строкой\n\nВведите еще 2 отзыва, используйте __books.length__, чтобы узнать, сколько отзывов в hash:\n\n    books[\"The deep end\"]  = :abysmal\n    books[\"Living colors\"] = :mediocre\n    \n    puts books\n    \n    puts books.length","load_code":"books = {\"Gravitys Rainbow\" => :splendid}"},
"26":{"lang":"RU","title":"Погодите, я не хуже Войны и мир?","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Мне нравится","error":"","text":"Одна особенность Ruby заключается в том, что имена часто используются повторно, что означает меньшее количество имен, которые вам нужно запомнить.\n\nПомните, как мы извлекали элементы из массива с помощью числа:\n__puts ticket [1] __.\n\nДля hash это работает одинаково, за исключением того, что мы не используем число, чтобы получить элемент, а имя(ключ, key, прим. переводчика).\n\nИтак, если вы хотите посмотреть один из своих старых отзывов, снова введите название в квадратных скобках. Но не пишите равенство.\nИменно так:\n\n    puts books[\"Война и мир\"]","load_code":"books = {\"Война и мир\" => :splendid, \"Отцы и дети\" => :abysmal, \"Идиот\" => :mediocre}"},
"27":{"lang":"RU","title":"Словари это пары","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Вы нашли ключи","error":"","text":"Помните, что словари не хранят элементы в последовательности. Это не их задача.\nОни создают пару: ключ(key) : значение(value) \n\nВ ваших отзывах, название книги - это ключ, а оценка - значение.\n\nЕсли вы хотите увидеть все названия книг, введите:\n\n    books.keys\n\nТакже попробуйте использовать .values вместо .keys.","load_code":"prev"},
"28":{"lang":"RU","title":"А ты суров?","chapter":"N","answer":"\"mediocre\"","ok":"Отлично, круто! Вы создали таблицу своих оценок","error":"","text":"Вы выдаете суровые, несправедливые отзывы? Давайте посчитаем их в новом hash __ratings__:\nСледуя за мной, наберите:\n\n    ratings = Hash.new {0}\n    \n    books.values.each { |rate|\n      ratings[rate] += 1\n    }\n    \n    puts ratings\n\nПрямой линией в коде является символ pipe , вероятно, расположенный над клавишей Enter\nна клавиатуре.\n\nЭта строка _ + = 1_ означает: увеличить значение на 1.\n\nНе беспокойтесь, если вы не понимаете все, что здесь происходит. Это будет показано позже.","load_code":"books = {\"Война и мир\" => :splendid, \"Отцы и дети\" => :abysmal, \"Идиот\" => :mediocre, \"Евгений Онегин\" => :amazing}"},
"29":{"lang":"RU","title":"Подсчет","chapter":"N","answer":"\\w+","ok":"Ура!","error":"","text":"Одна из потрясающих вещей, которую мы использовали это __block(блок)__. Мы изучим подробнее в\nэтом и следующем уроке. Но, в основном, блок - это немного кода на Ruby, окруженного фигурными\nскобками.\n\nДавайте попробуем создать другой блок:\n\n    5.times { print \"Ура! \" }\n\nБлоки всегда привязаны к методам. Как метод __times__, который берет блок и запускает\nкод снова и снова. (В нашем примере: пять раз.)","load_code":""},
"30":{"lang":"RU","title":"Есть минутка?","chapter":"N","answer":"[0-9]$","ok":"Ты сделал все верно!","error":"Выполните блок 0-9 раз","text":"Как мы видели в первом примере с блоком (при подсчете оценок), мы можем передать значение блоку. Значение, которое\nвставляется определяется методом, который запускает блок.\n\nЗначения, которые __принимает__ блок, помещаются в имя переменной в начале блока,\nмежду двумя символами pipe: |\n\nПопробуем это с помощью этого блока:\n\n    5.times { |time|\n        puts time\n    }\n\nЗдесь метод __.times__ отдает значение переменной __|time|__. Но имейте в виду, что эта переменная известна\nтолько внутри блока\n\n> Заметили, что вы можете писать код на нескольких строках?","load_code":""},
"31":{"lang":"RU","title":"Подводя итоги #4","chapter":"Y","answer":"","ok":"","error":"","text":"Этот урок был немного длиннее. Вы, вероятно, потратили на три минуты больше на его изучение:\n### Словари\nСамый простой пример словаря: __{}__\n\n### Символы\nКрошечные, эффективные кодовые слова с двоеточием, например: __:splendid__\n\n### Блоки\nКуски кода, которые можно привязать ко многим методам Ruby. Вот код, который вы использовали для\nсоздания таблицы оценок:\n    __books.values.each { |rate| ratings[rate] += 1 }__\n\n### Далее\nВ следующих уроках мы еще глубже погрузимся в методы","load_code":""},
"32":{"lang":"RU","title":"Быть или не быть","chapter":"N","answer":"","ok":"","error":"","text":"Одна маленькая деталь, которую мы не обсудили - это аргументы методов. Помните,\nкак мы меняли содержимое поэмы, используя этот метод:\n__poem.gsub(\"тост\", \"медовик\")__\n\nМетод gsub требует 2 аргумента, которые мы вставили как строки между двух круглых\nскобок. Аргументы сообщают методу, что именно ему делать.\n\n### Круглые скобки\nНа самом деле, в большинстве случаев Ruby не против, если вы опустите скобки. Таким образом, это\nтоже сработает:\n\n__poem.gsub \"toast\", \"honeydew\"__\n\nМы также уже использовали и другой метод с параметром. Много раз. Но это не так очевидно.\n\n    puts \"Hello\"\n    puts(\"Hello\")\n\nАга, __puts__ тоже метод. Использование puts с круглыми скобками или без Ruby не важно, но\nвариант без скобок проще читать и немного экономит время набора кода!\n\n> Поэтому я предполагаю, что вывод состоит в том, что вы можете делать все, что угодно, с круглыми скобками, пока\n> код читается красиво.\n\nХотите немного Шекспира? Читайте дальше.","load_code":"poem = \"Мой тост вылетел из моей руки\\n И мой тост отправился на Луну. \\n Ура, Ура, Ура \\n\""},
"33":{"lang":"RU","title":"Укрощение строптивого","chapter":"N","answer":"tame","ok":"Хорошо, хорошо!","error":"","text":"Вы уже знаете, как использовать Ruby. Я имею в виду, что ты уже постиг основы.\nДалее тебе нужно изучить больше методов и попробовать более сложные блоки.\n\nНо мы кое-что еще не обсудили. Создание собственных методов.\n__Хм!__ Давайте займемся этим.\n\nВ то время, как Ruby имеет встроенные методы (такие, как puts, sort, times), вы можете определить\nсвои собственные методы. Зачем? Вот 2 причины.\n\n### Сделать свою программу короче\nЕсли вы используете одно и тоже более чем в одном месте кода, то будет намного проще, если\nвыделить это в новый метод. Это сделает код короче.\n\n### Сделать свой код более читаемым\nПредположим, что ваша программа должна делать много разных вещей.\nВы __можете__ записать весь код в один длинный кусок. Но было бы очень сложно\nпрочитать и понять этот код позже.\n\nВместо этого вы должны разбить свой код на методы и дать каждому из них\nпонятное английское имя. Вы поблагодарите себя позже.\n\nИтак, как мы определяем метод? Вот так:\n\n    def tame( number_of_shrews )\n    end","load_code":""},
"34":{"lang":"RU","title":"В Ruby, Def Leppard означает: определить метод Leppard *","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"Эй, хорошо, ты это сделал. Вы создали свой собственный метод. Вы начали с def, за которым следует имя метода.\nИ список аргументов, которые будут нужны методу. Это не слишком страшно и опасно!\nВсе, что нам нужно сделать, это заполнить его кодом на Ruby и закончить с ним.\n\nВот код:\n    \n    def tame( number_of_shrews )\n      number_of_shrews.times {\n        puts \"Tamed a shrew\"\n      }\n    end\n    \n> __P.S.__  \n> Если вы не знаете это название, то прочтите\n> <a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\n> это название известной Британской группы.","load_code":""},
"35":{"lang":"RU","title":"Плод вашего собственного творения","chapter":"N","answer":"^Tamed a shrew","ok":"Вот и все!","error":"","text":"Новый метод рожден. Попробуем его использовать:\n\n    tame 5","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"RU","title":"Давай и бери","chapter":"N","answer":"\\d+","ok":"На уровне! Браво!","error":"","text":"Большинство методов не только требуют ввода некоторых параметров, но и возвращают что-то обратно.\nЯ немного изменил наш метод, чтобы он вернул вам значение. Попробуй:\n\n    def tame( number_of_shrews )\n      number_of_shrews.times {\n        puts \"Tamed a shrew\"\n      }\n      return number_of_shrews\n    end\n\n    puts tame(3)\n\n### Возвращаемое значение\nИ, поскольку вы настолько продвинуты и способны, еще один совет:\nвы можете опустить слово __return__ из последней строки метода.\nRuby автоматически вернет последнее значение, которое использовалось внутри метода.\n\nТак мы можем изменить последнюю строку на это: __number\\_of\\_shrews__.\n\nНо по-прежнему метод __.times__ также может справиться с этой задачей.\nТак что наш новый метод делает то, что мы уже давно можем и без него!","load_code":""},
"37":{"lang":"RU","title":"Кто здесь? Итоги #5 Снимите шляпу!","chapter":"Y","answer":"","ok":"","error":"","text":"Отлично, Отлично, Отлично!\n\nКруто! Круто! Круууууто! \n\nВот что мы еще узнали:\n\n### Методы\nМетоды могут быть определены с помощью __def__ и у них есть имя. Методы\nделают вашу программу короче и проще для чтения.\n\n### Параметры\nУ методов могут быть параметры\n\n### Возвращаемое значение\nМетоды зачастую возвращают какое-то значение\n\n## А сейчас\nГотовы почитать немного Шекспира?","load_code":""},
"38":{"lang":"RU","title":"Мир - наша устрица","chapter":"N","answer":"^\\{\\\"Уильям","ok":"Хорошо, но читать тяжело!","error":"","text":"До сих пор мы запускали программы, которые используют только те вещи, которые мы набрали сами.\nЭто классно, но сейчас эпоха интернета, а значит можно использовать эти данные.\n\nМного, много веб-сайтов в сети, а значит у всех них можно запросить информацию. Например:\nэта ссылка даст вам  все последние <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Новости из Гугла</a>\nо Ruby.\n\nВаш браузер скорее всего отобразит это красиво. Но если вы посмотрите на исходный код,\n(нажмите: control-U) вы увидите сложный текст в формате __rss__.\n\n### Форматы\nВсего очень много форматов со сложными названиями в сети, такие как:\nhtml, xml and json. Ага, многие веб-сайты используют их.\n\nЯ подготовил для вас метод, который выберет список полных работ Уильяма\nШекспира из Интернета.\n(Не волнуйтесь, что на самом деле это происходит с того же сервера, на котором работает этот веб-сайт, поэтому\nмы никого не беспокоим.)\n\nПолучите данные с помощью:\n\n    get_shakey","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"RU","title":"Благородные родственники","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Так намного лучше.","error":"","text":"Итак, теперь у нас есть список пьес из Интернета. Список был в формате json.\nК счастью для нас Ruby любезно предоставляет метод преобразования данных json в hash Ruby.\nМетод _get\\_shakey_ сделает это за нас.\n\nНо так как структура json-данных сохраняется в hash, ее все-таки трудно читать.\nДавайте напишем метод для показа игр.\n\nЕсли вы внимательно изучите список пьес, вы увидите, что у него есть своего рода вложенный\nсостав. (Это действительно довольно распространено в данных, которые вы получаете из Интернета.)\nВыглядит так:\n\n<ul>\n  <li>\"William Shakespeare\"\n  <ul>\n      <li>\"1\"\n      <ul>\n        <li>\"title\": \"The Two Gentlemen of Verona\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>\"2\"\n      <ul>\n        <li>\"title\": \"The Taming of the Shrew\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>...</li>\n  </ul>\n  </li>\n</ul>\n\nЧтобы перечислить пьесы, нам сначала нужно получить доступ к верхнему элементу словаря «Уильям Шекспир» по его названию.\nЗатем мы должны __iterate(\"шагать\")__ по каждому элементу за ним.\n\nRuby имеет метод для итерации. Он называется __each__. Мы видели это раньше, когда\nсоздавали нашу систему рейтинга книг.\n\nВсе, что возвращает метод __each__, передается блоку:\n\n    s = get_shakey\n    \n    s[\"William Shakespeare\"].each { |key, val|\n      puts val[\"title\"]\n    }","load_code":"prev"},
"40":{"lang":"RU","title":"Все вместе","chapter":"N","answer":"^4$","ok":"Ага, Шекспир написал 4 пьесы в 1591","error":"Ответ должен быть 4. Проверьте аргумент метода count_plays","text":"Теперь предположим, что мы хотим знать имена и количество пьес, написанных Шекспиром\nв течение определенного года.\n\nRuby позволяет нам выводить значения из словаря. Метод select использует блок, который позволяет нам\nопределить, что выбрать и вернуть найденное.\n\nЗатем мы можем использовать результаты, возвращаемые __select__ в методе __each__, как и раньше,\nпросто добавляя его после блока выбора. Это еще один пример цепочки методов, который мы видели\nраньше, когда делали стихотворение задом наперед.\n\nЯ подготовил метод __count\\_plays__ для вас. Посмотрим, сможете ли\nвы посчитать количество пьес, написанных Шекспиром в 1591:\n\n    def count_plays(year)\n      s = get_shakey\n      \n      s[\"William Shakespeare\"]\n        .select { |k, v|\n          v[\"finished\"] == year\n        }.each { |key, val|\n          puts val[\"title\"]\n        }.count\n    end\n    \n    puts count_plays(0)\n\nВы заметили, что я добавил метод count в самом конце всего метода. Так мы получим \nвозвращаемое значение метода __count\\_plays__.\n\nЕсть и другой способ выстраивания цепочки. Видите одинокую строчку __s = get_shakey__.\nВы можете добавить __[\"William Shakespeare\"].select { |k, v|__ в конец get_shakey\n(не обязательно здесь).","load_code":"prev"},
"41":{"lang":"RU","title":"Все хорошо, что хорошо кончается","chapter":"N","answer":"All's Well That Ends Well","ok":"Верно","error":"Используйте 1605 как 2 параметр","text":"Хорошо, мы получили некоторые данные из Интернета, мы выбрали то, что хотели, и распечатали это.\nЧто нужно улучшить? Мы могли бы напечатать результаты немного красивее. Как добавить год\nи выровнять названия и годы?\n\nЭто значит требуется печать нескольких значений на одной строке. Ruby имеет удобный способ сделать\nэто. Это похоже на печать строки типа: __puts «Привет, меня зовут Джимми» __.\nНо вместо буквенного значения _Джимми_ мы используем значение переменной.\n\nСначала замените __Джимми__ на __#{}__. Если Ruby видит символ #, а за ним символ {,\nто это означает,что до символа } идет имя переменной. \nТак, мы можем использовать: __\"Привет, меня зовут \\#{name}\"__.\n\nИзменим наш код немного:\n\n    def print_plays(year_from, year_to)\n      get_shakey[\"William Shakespeare\"]\n        .select { |k, v|\n          year_from <= v[\"finished\"] &&\n          year_to   >= v[\"finished\"]\n        }.each { |k, v|\n          puts \"#{v[\"title\"].ljust(30)} #{v[\"finished\"]}\"\n        }\n    end\n    print_plays(1600, 1605)\n\nЯ добавил __.ljust(30)__ к заголовку. В таком случае заголовок _имеет отступ_ минимум\n30 символов. Так год выглядит опрятнее =)\n\nПосмотрите, изменится ли выход программы так, чтобы она показывала такие игры: 1600 -> Как вам нравится\nВсе хорошо, что хорошо кончается? \nЭй, мы еще не закончили, но конец близок!","load_code":"prev"},
"42":{"lang":"RU","title":"Если бы я знал, как принять решение","chapter":"N","answer":"","ok":"","error":"","text":"Делать выбор в жизни бывает трудно, но не в Ruby. Тут есть удобные способы принять решение.\n\n    if 1 < 2\n      puts \"Это правда: 1 меньше 2\"\n    end\n\nКлючевое слово __if(если)__. If может быть поставлен и до, и после метода. Как тут:\n\n    puts \"Это правда: 1 меньше 2\" if 1 < 2\n\n__If__ это метод, который требует 1 параметр. Этим параметром может быть любое выражение, которое\nвы хотите проверить. Результат выражения  __true(правда)__ or __false(ложь)__.\nВот немного примеров:\n\n    5     <= 10     # => true\n    'abc' == 'def'  # => false\n    true            # => true\n    123456          # => true\n    0               # => true\n    nil             # => false\n    'xyz'.empty?    # => false\n    'a' > 5         # => error:\n                    # comparison of String with\n                    # Numeric failed\n\n_if выражение_ может иметь много видов: сравнивать значения (1 < 2),\nпеременные (a < 1) и возвращаемые значения методов('xyz'.empty?).","load_code":""},
"43":{"lang":"RU","title":"И напоследок","chapter":"N","answer":"не равно 100$","ok":"Так лучше","error":"Это неправильно","text":"Видите двойное равно __'abc' == 'def'__?\n\nЭто __==__ означает __проверка на равенство__.\nОдиночное равно используется для присваивания значения переменной.\n\nЧтобы немного вас запутать: вы можете использовать присваивание как аргумент метода if:\n\n    a = 0\n    \n    if a = 100\n      puts \"Выражение верно, но а сейчас : #{a}\"\n    else\n      puts \"#{a} не равно 100\"\n    end\n\nПоменяйте = на == и посмотрите, что произойдет.\n\nЯ вам гарантирую, что вы будете часто забывать поставить двойное равенство.\n\n### Иначе(else)\nВ коде я использовал else, это выполняется в случае\n__if тестовое_выражение__ вычисляется как ложь(false).\n\n> Больше информации вы можете почерпнуть\n> <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">здесь</a>.","load_code":""},
"44":{"lang":"RU","title":"Я голоден","chapter":"N","answer":"^Я не голоден","ok":"Да","error":"Без вариантов, я голоден в 10 утра!","text":"Это прекрасно, но имей ввиду, что ты не знал Ruby всего 15 минут назад!\n\nДавай теперь объединим все наши полученные навыки:\nДавайте определим 2 метода: \n\n    def hungry?(time_of_day_in_hours)\n      puts \"Я голоден\"\n      true\n    end\n\n    def eat_an(what)\n      puts \"Я ем #{what}\\n\"\n    end\n\n    eat_an 'яблоко' if hungry?(14)\n\n    eat_an 'яблоко' if hungry?(10)\n\nПопробуйте изменить  метод __hungry?__ так, чтобы он печатал __\"Я не голоден\"__ и возвращал false\nкогда время меньше 10.","load_code":""},
"45":{"lang":"RU","title":"Итоги #6 Что значит издалека?","chapter":"Y","answer":"\\{\\}","ok":"Ага, это пустой словарь","error":"","text":"Вы 6-го уровня Ruby клирик. Я имею ввиду, что проделана отличная работа. Давайте подведем итоги:\n\n\n### Данные\nТы загрузил немного данных из интернета и организовал их в структуру.\n\n### Iterating (шагание)\nВы прошли по всем элементам словаря, а также создали цепочку методов\n\n### Красивый вывод\nИ если этого недостаточно, то вы научились делать красивый вывод.\nЭто ведь настоящая программа!\n\n### Если(IF)\nНаучились использовать if и else\n\n## Итак\nЧто может быть дальше? Что вы, возможно, должны узнать сейчас?\nХа, это лучшая часть. Вы прошли столь долгий путь, что мы собираемся\nизучить классы. Еще два коротких урока, и все готово.\n\nРанее мы создавали словарь так:\n\n    Hash.new","load_code":""},
"46":{"lang":"RU","title":"Не школьный класс, а работающий","chapter":"N","answer":"","ok":"","error":"","text":"Вы уже видели пустые фигурные скобки. {} это сокращение Hash.new. Метод new используется, чтобы создавать объекты\nопределенного класса. Воспринимайте \"class\" в смысле \"работающий класс\" &mdash; какая-то особенная группа,\nделающая одну работу и в одинаковых футболках.\nЧто используется в классах?\n\n### Blurbalizer<sup>TM</sup>\nПрикольная идея для нового приложения. Это будет новая платформа для обмена сообщениями.\nВы хотите приложение, где люди могут обмениваться короткими сообщениями. Вы называете эти сообщения Blurbs<sup>TM</sup>.\nBlurb<sup>TM</sup> имеет максимальную длину 40. Давайте сделаем еще настроение сообщения.\n\n<!---Интернет действительно привел нас к тому, что даже в банкротстве люди отправляют улыбки, используя смайлики -->\n\n### Где начать?\nНу, вы можете сохранить записи Blurbs<sup>TM</sup> в json-файле, верно?\nНо как бы вы отслеживали содержание записи и время ее публикации?\nИ когда вы загрузите файл, как он будет выглядеть в Ruby?\nЭто будет словарь? Или массив? Или массив массивов? Или что-то другое?\n\n### Класс\nЯ уверен, что вы должны использовать класс. Вы уже знаете некоторые из них:\nсловарь, массив, строка.\n\nСоздадим новый класс:\n\n    class Blurb\n    end","load_code":""},
"47":{"lang":"RU","title":"Приложения делаются","chapter":"N","answer":"","ok":"","error":"","text":"Мы открыли новый Blurb<sup>TM</sup> класс. Чем наполнен ваш блог?\nВерно, контентом. Также временем, когда Blurb<sup>TM</sup> был опубликован. И настроением.\n\nХорошо, так что у вас есть первая строка класса, вот и все:\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n    end\n\nИмена классов всегда с большой буквы.","load_code":""},
"48":{"lang":"RU","title":"Аксессоры это обособленные элементы","chapter":"N","answer":"Blurb:","ok":"Мой первый Blurb","error":"","text":"Привет. У тебя есть новый Blurb<sup>TM</sup> класс.\n\nВ определении класса вы использовали метод, называющийся attr\\_accessor(аксессор).\nВообще много атрибутов класса, которые так или иначе его меняют.\nАтрибуты - это всего лишь переменные связанные с классом.\n\nДумайте так. Класс - это человек. Это звездное человеческое существо.\nА атрибуты - это его конечности, разные части собираются в тело, а другие люди могут взять этого человека за руку и поздороваться.\n\n### Сейчас\nЧтобы создать Blurb<sup>TM</sup> и наполнить данными напишите:\n\n    blurb1 = Blurb.new\n    puts blurb1\n    blurb1.content = \"Today Mount Hood Was Stolen!\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"RU","title":"Объект, этот аккуратный маленький пакет","chapter":"N","answer":"Blurb:","ok":"Blurb обновлен","error":"","text":"А теперь поменяй атрибуты нашего Blurb<sup>TM</sup>:\n\n    blurb1.time = Time.now\n    blurb1.mood = :sick\n    \n    puts blurb1","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"RU","title":"Ускоряемся","chapter":"N","answer":"^\\d{4}","ok":"Запомнили :)","error":"","text":"Круто, новое приложение потрясающее. Хей, давай немного упростим?\nВы всегда хотите ставить время вашему Blurb<sup>TM</sup> так?.\n\nВы всего лишь хотите писать контент?\n\nДобавим метод __инициализации__ в наш класс. Этот метод будет всегда вызываться, когда новый Blurb<sup>TM</sup>\nсоздается.\nТакже мы можем установить максимальную длину Blurb<sup>TM</sup> контента в 40 символов.\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n\n      def initialize(mood, content=\"\")\n        @time    = Time.now\n        @content = content[0..39]\n        @mood    = mood\n      end\n    end\n    \n    Blurb.new.time\n\n(Этот параметр __content=\"\"__ используется, чтобы было известно, что это строка и никакой другой параметр не мог инициализировать его.)","load_code":""},
"51":{"lang":"RU","title":"Вы научили ваше приложение отвергать бесполезные вещи","chapter":"N","answer":"Blurb:","ok":"Blurb добавлен","error":"","text":"Вы заметили, что мы используем символ \"собаки\" внутри класса? (@time).\n\n__Снаружи__ класса мы используем аксессоры:\n\n> __blurb.time = Time.now__\n\nно __внутри__ мы используем __переменные объекта__:\n\n> __@time = Time.now__\n\nЭто одно и тоже, но может использоваться в разных местах вашей программы.\n\n### Создадим другой Blurb<sup>TM</sup>\nКогда другой Blurb<sup>TM</sup> создан, метод инициализации используется для проверки любого\nаргумента к методу new.\n\nОх, нужно еще 2 аргумента:\n\n    blurb2 = Blurb.new :confused, \"Не могу поверить, Маунт-Худ был украден!\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"RU","title":"А жирафы на месте ИТОГИ #7","chapter":"Y","answer":"","ok":"","error":"","text":"Ага, ты здесь. И все еще учишься. Мы по-прежнему будем делать ваше приложение реальным,\nно пока давайте посмотрим результаты, хорошо?\n\n### Классы\nВсе в Ruby - это объекты. Классы объясняют объекты как независимые рабочие элементы.\nНапример, вы создали несколько Blurb<sup>TM</sup> объектов, а эти объекты ведут себя так же  \nкак любой объект класса Blurb.\n\nДругими словами: Вы называете их Blurb объекты.\nВы можете использовать классы как в реальной жизни.\n\n### Аксессоры\nАксессоры - это переменные, связанные с классом, но используются __снаружи__ объекта.\n(blurb2.time = Time.now)\n\n### Переменные объекта\nЭто то же самое, что и аксессоры, но используются __внутри__ объекта.\n(@time = Time.now)","load_code":"prev;blurb2=Blurb.new :confused, \"Не могу поверить, Маунт-Худ был украден!\""},
"53":{"lang":"RU","title":"Ваш собственный сад","chapter":"N","answer":"Blurbalizer:","ok":"Приложение создано","error":"","text":"Ладно, давай обернемся, малыш. Вот последняя глава эпической истории познания «Try Ruby»!\nТеперь, когда у вас есть понимание, как все это работает, как вы собираетесь использовать это?\nТы отличный человек (один из моих любимых), но тебе нужно руководство.\n\n### Давай закончим наше приложение\nУ вас есть записи приложений, но нет приложения.\nПо-прежнему нужно место, где хранить все Blurbs<sup>TM</sup> и упорядочить их.\n\nУгадайте что, мы собираемся использовать другой класс. Я дал весь код для нового класса за один раз.\nТолько потрать время, чтобы изучить его.\nЯ не тороплюсь, я буду ждать тебя на следующем уроке.\n\n    class Blurbalizer\n      def initialize(title)\n        @title  = title\n        @blurbs = [] # Пустой массив\n                     # для хранения Blurbs\n      end\n      \n      def add_a_blurb(mood, content)\n        # << означают добавить в конец массива\n        @blurbs << Blurb.new(mood, content)\n      end\n      \n      def show_timeline\n        puts \"Blurbify: #{@title} has #{@blurbs.count} Blurbs\"\n        \n        @blurbs.sort_by { |t|\n          t.time\n        }.reverse.each { |t|\n          puts \"#{t.content.ljust(40)} #{t.time}\"\n        }\n      end\n    end\n    \n    myapp = Blurbalizer.new \"The Big Blurb\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"RU","title":"Про что это Blurb?","chapter":"N","answer":"Today","ok":"Ок!","error":"","text":"И вот результат. Вы поняли, что в коде класс Blurbalizer<sup>TM</sup> делает?\n\n> В Blurbalizer<sup>TM</sup> есть 2  __метода__ (add\\_a\\_blurb and show\\_timeline).\n> Вы можете использовать метод вне класса, также как и с аксессорами.\n\nСамое время, чтобы начать использовать Blurbalizer<sup>TM</sup>. Я уже загрузил несколько Blurbs<sup>TM</sup> для тебя,\nно добавь еще свой сам.\n\nМы больше не создаем Blurbs<sup>TM</sup> напрямую, но мы используем метод add\\_a\\_blurb из класса \nBlurbalizer<sup>TM</sup>. Теперь мы можем быть уверены, что все наши Blurbs<sup>TM</sup> хранятся в\nобъекте myapp.\n\n    myapp.add_a_blurb :moody, \"Добавь Blurb сюда\"\n\n    myapp.show_timeline","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"RU","title":"Это все про комбинирование","chapter":"N","answer":":-|","ok":"Угрюмо!","error":"","text":"Некоторые интересные вещи можно сделать с помощью простых частей Ruby, особенно когда вы их объединяете\nвместе в нечто новое.\n\nЗдесь у нас есть приложение, состоящее из класса, содержащего другой класс.\nЭто называется объектно-ориентированное программирование (ООП)\n\nМы приступаем к  __последнему заданию__ на TryRuby. Если хотите, то можете добавить\nбольше интересного в Blurbalizer<sup>TM</sup>.\n\nМожет вы захотите выводить улыбающийся смайлик в методе __show_timeline__. Вы должны добавить\n_модифицированный_ метод в класс Blurb<sup>TM</sup> и затем использовать это в методе _show\\_timeline_:\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n\n      def initialize(mood, content=\"\")\n        @time    = Time.now\n        @content = content[0..39]\n        @mood    = mood\n      end\n\n      def moodify\n        if    @mood == :sad\n          return \":-(\"\n        elsif @mood == :happy\n          return \":-)\"\n        # Добавь другой смайлик сюда\n        end\n\n        # Смайлик по умолчанию\n        \":-|\"\n      end\n    end\n\n    class Blurbalizer\n      def initialize(title)\n        @title  = title\n        @blurbs = []\n      end\n\n      def add_a_blurb(mood, content)\n        @blurbs << Blurb.new(mood, content)\n      end\n\n      def show_timeline\n        puts \"Blurbalizer: #{@title} содержит #{@blurbs.count} Blurbs\"\n\n        @blurbs.sort_by { |t|\n          t.time\n        }.reverse.each { |t|\n          puts \"#{t.content.ljust(40)} #{t.time}\"\n        }\n      end\n    end\n\n    myapp.show_timeline","load_code":"prev"},
"56":{"lang":"RU","title":"ИТОГИ #8","chapter":"Y","answer":"","ok":"","error":"","text":"Этот последний раздел потребовался, чтобы дать вам несколько указаний о том, как вы можете использовать Ruby.\n\nЕсли вам понравилось, то можете продолжить в <a href=\"/playground\">TryRuby Playground</a>\nили скачать и установить Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a>\n\nКогда Ruby будет установлен, создайте новый файл _my\\_first\\_program.rb_, используя\nтекстовый редактор, добавьте немного кода на Ruby code и затем открыв терминал или командную строку наберите:\n\n    ruby my_first_program.rb\n\n## Празднуйте\nВы действительно заслуживаете двухслойный торт с двойной двойной глазурью и парня, играющего на одной из этих крутых гитар, которая является двойной гитарой.\nЯ имею в виду, что ты закончил, ты действительно сделал это! Не сомневайтесь в этом!\n\n## Больше информации\nНа этом сайте есть еще <a href=\"/articles\">статьи</a>, в которых вы можете почерпнуть что-то полезное\nдля себя.","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_program=K.new"}}