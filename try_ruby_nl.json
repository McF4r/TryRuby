{"1":{"lang":"NL","title":"Heb je 30 minuten over ? Probeer Ruby eens uit !","chapter":"Y","answer":"","ok":"","error":"","text":"Ruby is een programmeertaal uit Japan die software ontwikkeling op zijn kop zet !\n\nHet mooie van Ruby is de balans tussen eenvoud en kracht.\n\nType wat Ruby code in de editor en gebruik de knoppen om TryRuby te bedienen:\n\n- __Run__ &rarr; Voert de code in de editor uit\n- __Copy__ &rarr; Kopieert de voorbeeld code naar de editor\n- __Next__ &rarr; Naar de volgende les\n- __Back__ &rarr; Ga terug naar de vorige les\n- __Clear__ &rarr; Wis inhoud van de editor\n\nMet de 'wereld' knop <span aria-hidden=\"true\" class=\"glyphicon glyphicon-globe\"></span>\nhierboven kan je kiezen welke taal je voor TryRuby wilt gebruiken.\n\n### Klik op __Next__ om te beginnen","load_code":""},
"2":{"lang":"NL","title":"De editor","chapter":"N","answer":"^\\d{1,}$","ok":"Heel goed! Je hebt Ruby laten rekenen. Zag je het antwoord verschijnen ?","error":"Type 2 + 6 in de editor","text":"Het editor venster, rechtonder, is de plek om Ruby code in te voeren, tik daarna op de\n__Run__ knop om de resultaten te bekijken.\n\nLaten we eens beginnen met wat rekenwerk. Typ bijvoorbeeld dit in:\n\n    2 + 6\n\nDe uitvoer van je programma zou in het 'output' venster rechtsboven moeten\nverschijnen.\nAls het goed is staat er ook een regel bij die je vertelt of je het goed hebt gedaan.\n\n> Je kunt trouwens ook op de __Copy__ knop klikken om de voorbeeldcode naar de editor te\n> kopiëren.\n\nKlik op __Next__ om naar de volgende les te gaan.","load_code":""},
"3":{"lang":"NL","title":"Nummers en symbolen","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Klinkt goed","error":"Type 2 of 3 sommetjes","text":"Ruby herkent numbers en allerlei rekenkundige symbolen.\n\nProbeer nog eens wat sommetjes uit:\n\n    4 * 10\n    5 - 12\n    30 / 4","load_code":""},
"4":{"lang":"NL","title":"Anders gezegd","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Goed gezegd","error":"Euh","text":"Zag je dat ! Je geeft 3 sommetjes op maar je krijgt alleen het antwoord van de laatste\nsom. Hoe kan dat ?\n\n> Om deze website zo handig mogelijk te maken heb ik Ruby de opdracht gegeven om het\n> resultaat van jouw programma in het output venster te zetten.  \n> Maar alleen het __laatste resultaat__ en alleen als er nog geen andere output is.\n\nDus toen je 3 sommetjes opgaf liet Ruby alleen het antwoord van de laatste zien.\n\nMaar, jij hebt het in je om de uitvoer naar je hand te zetten. Ik voel het gewoon.\n\nTyp __puts__ voor iedere som (met een spatie ertussen).\n\nPuts betekent in het Engels: '_put something on the screen_'. Oftwel zet _iets op\nhet scherm_.\n\nProbeer dit eens:\n\n    puts 4 * 10\n    puts 5 - 12\n    puts 30 / 4\n\nHaal de _puts_ bij de laatste regel weg. Wat gebeurt er dan?","load_code":""},
"5":{"lang":"NL","title":"Hoe heet je ?","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Mooi, je hebt een string gemaakt met alle letters van jouw naam","error":"","text":"Ja ja, computers zijn heel handig om mee te rekenen, maar dat kan mijn rekenmachine ook.  \nLaten we eens wat anders doen. Wat dacht je van het verdraaien van je naam ?\n\nType eerst je voornaam in de editor. Zet je naam wel tussen aanhalingstekens, bijvoorbeeld\nzoiets:\n\n    \"Jantje\"","load_code":""},
"6":{"lang":"NL","title":"Achterstevoren","chapter":"N","answer":"\\w+","ok":"deoG","error":"","text":"Een string is het Engelse woord voor reeks. Een string is dus gewoon een reeks tekens\nwaar een computer iets mee kan.\n\n> Strings doen mij vaak denken aan een wasdrooglijn waaraan kleren hangen. De\n> aanhalingstekens aan het begin en einde zijn de wasknijpers.\n\nOm je naam om te draaien typ je: \n\n    \"Jantje\".reverse\n\n(Vergeet de punt niet)","load_code":""},
"7":{"lang":"NL","title":"Tellen maar","chapter":"N","answer":"^\\d+$","ok":"Ja, 'length' is ook een methode","error":"","text":"Je hebt net je eerste __methode__ gebruikt.\n_Method_ op zijn Engels.\n\nEerst maakte je een string door je naam tussen aanhalingstekens te zetten.\nDaarna gebruikte je de _reverse_ (omdraai) methode om de volgorde van alle\nletters van je naam om te draaien.\n\nHoeveel letters zitten er eigenlijk in jouw naam ?\n\n    \"Jantje\".length","load_code":""},
"8":{"lang":"NL","title":"Op herhaling","chapter":"N","answer":"(\\w+)","ok":"Aangenaam. Aangenaam. Aangenaam. Aangenaam. Aangenaam.","error":"","text":"Je vraagt je misschien af waar dit allemaal goed voor is.\n\nJe hebt vast wel eens ergens een wachtwoord moeten opgeven, om\nals antwoord te krijgen:  \n__\"Hee, je wachtwoord is te kort !\"__\n\nHet programma van die website of app gebruikt ook zo'n simpele\n__lengte__ methode.\n\nHeb ik een leuk trucje voor. Vermenigvuldig je naam maar eens met vijf:\n\n    \"Jantje\" * 5","load_code":""},
"9":{"lang":"NL","title":"Je hebt samenvatting 1 bereikt","chapter":"Y","answer":"NoMethodError|undefined","ok":"Nee, nummers kan je niet omdraaien. Klik 'next'","error":"","text":"Je bent net 1 minuut bezig en kijk eens wat je allemaal al weet.\n\n### De editor\nCode intypen in de editor en op run klikken geeft je een antwoord het output\nvenster. (Bijna) alle code geeft een antwoord. Met _puts_ bepaal je zelf wat\nje wilt tonen.\n\n### Nummers en strings\nNumbers en strings zijn Ruby's reken en tekst objecten.\n\n### Methodes\nJe hebt Engelstalige methodes gebruikt als _reverse_ en _length_.  \nEn symbolische methoden zoals vermenigvuldigen: \\*  \n__Methodes betekenen actie!__\n\n\nZo leer je programmeren. Je neemt een simpel voorbeeld, je speelt\ner wat mee en ontdekt nieuwe mogelijkheden.\nVoel je je al een beetje op je gemak ? Vast wel.\n\n## Okee,\nlaten we dan nu maar eens iets ongemakkelijks proberen zoals het omdraaien\nvan een nummer:\n\n    40.reverse","load_code":""},
"10":{"lang":"NL","title":"Doe niet zo gek","chapter":"N","answer":"^\\d{1,}$","ok":"Zie je, we kunnen alleen strings omdraaien","error":"","text":"Een nummer kan je niet omdraaien. Misschien kan je een spiegel naast je monitor houden,\nmaar een nummer omdraaien kan echt niet.\n\nRuby gaf daarom een foutmelding. Ruby wil je duidelijk maken dat er geen __reverse methode__\nbestaat voor nummers.\n\nMaar als je het nummer eerst eens om zou zetten naar een string:\n\n    40.to_s.reverse","load_code":""},
"11":{"lang":"NL","title":"Wat naar","chapter":"N","answer":"\\[\\]","ok":"Ja, dat is een mooie nieuwe, maar nog lege, lijst","error":"","text":"Appels zijn anders dan peren. En nummers zijn anders dan strings.\n\nAlle Ruby objecten hebben methoden, maar sommige methoden werken alleen voor\nspecifieke objecten.\nJe kunt objecten van de ene soort meestal omzetten naar een andere soort.\nDaarvoor kent Ruby een aantal \"to\" methoden. In het Nederlands zouden we dat \"naar\"\nnoemen.\n\n- __to_s__ verandert een object in een __s__tring\n- __to_i__ verandert een object in een __i__nteger  \n  (geheel getal)\n- __to_a__ verandert een object in een __a__rray\n\n### Wat is array nu weer ?!\n\nDat is een soort lijst. Type maar deze (vierkante) teksthaakjes in: \n\n    []","load_code":""},
"12":{"lang":"NL","title":"In de rij","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Bingo","error":"Probeer een vierde getal toe te voegen","text":"In een lijst (_list_ of _array_ op z'n Engels) kan je Ruby objecten opslaan.\n\nNet als een lijstje op papier, kent een Ruby lijst ook een bepaalde volgorde.\n\n> Het is net als in de rij staan voor een frietkraam. Je staat achter iemand en\n> jij zou nooit proberen om voor te piepen. Toch ?  \n> En je houd goed in de gaten of die gast achter je niet voordringt.\n\nIk heb hier een lijstje met 3 bingo getallen:\n\n    [12, 47, 35]\n\nProbeer zelf een vierde getal toe te voegen aan de lijst.\nType een komma achter getal 35, daarna eventueel een spatie, gevolgd door een door\njou gekozen getal.","load_code":""},
"13":{"lang":"NL","title":"Kan ik mijn hand al opsteken ?","chapter":"N","answer":"^47$","ok":"Okee","error":"","text":"Ok, we hebben een lijst met bingo getallen. Wat is hoogste getal ?\n\nProbeer: \n\n    [12, 47, 35].max","load_code":""},
"14":{"lang":"NL","title":"Wie wat bewaart voor later","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Bewaard!","error":"","text":"Ok we hebben een lijst. Maar het is best wel irritant om die lijst iedere keer\nin te moeten typen als we 'em nodig hebben.\n\nWe kunnen de lijst met bingo getallen bewaren op een kaart:\n\n    kaart = [12, 47, 35]","load_code":""},
"15":{"lang":"NL","title":"Tiep kaart","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Opgehaald!","error":"","text":"En als je nu eens kaart intypt:\n\n    kaart","load_code":"kaart = [12, 47, 35]"},
"16":{"lang":"NL","title":"Opgeslagen","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Dat is een gesorteerde lijst","error":"","text":"We kunnen dus ons lijstje met bingo getallen bewaren door deze in een __variabele__\nte stoppen. Een variabele met de naam _kaart_. Maar als je een andere naam had willen\ngebruiken, _jantjeslijst_ of zo, was dat ook prima geweest.\n\nAls je je wat langer verdiept in programmeren zal je zien dat het werken met variablen\néén van de belangrijkste dingen is.\n\nZullen we onze bingo getallen nu eens op volgorde zetten?\n\n    kaart.sort!\n    \nWe hadden dus een lijst. Die lijst is nu gesorteerd van klein naar groot.\nDe waarde van de variable kaart is nu veranderd.  \n\n> Zag je dat uitroepteken achter de _sort!_ methode?  \n> Ruby methodes hebben vaak zo'n uitroepteken. Dat betekent:\n> \"_Hee jij daar opletten, ik ga de waarde van de variabele veranderen_\".","load_code":"kaart = [12, 47, 35]"},
"17":{"lang":"NL","title":"Elementair","chapter":"N","answer":"^(12|35|47)$","ok":"Ok","error":"Bijna","text":"We hebben ons lijstje met bingo getallen in variabele kaart staan. Hoe krijgen we\nde getallen er weer één voor één uit?\n\nWe hebben __max__ al gebruikt om het hoogste getal te bepalen. Je kunt ook __first__\nof __last__ gebruiken voor het eerste en laatste element van de lijst.\nMaar hoe haal je er één specifiek element uit?\n\n### [ ]\nRuby gebruikt hiervoor de vierkant teksthaken.\nDeze worden trouwens heel vaak gebruikt in Ruby.\n\nOk, we halen de bingo getallen één voor één op:\n\n    puts kaart[0]\n    puts kaart[1]\n    puts kaart[2]\n\nMaar waarom [0], [1], [2] ? En niet [1], [2] and [3] ?\n\nHeeft dat met dat Japanse Zen gedoe te maken?  \nNee hoor, computer programmeurs beginnen nou eenmaal graag met tellen vanaf\nnul. En niet alleen Ruby programmeurs maar alle programmeurs. Het heeft\nzelfs een naam: _zero based indexing_.\n\n> Tip: mocht je het vergeten zijn, je kunt de __Copy__ knop gebruiken om de\n> voorbeeldcode over te nemen in de editor.","load_code":"kaart = [12, 47, 35]"},
"18":{"lang":"NL","title":"We zijn bij samenvatting 2","chapter":"Y","answer":"\\w+","ok":"Rijmt het ?","error":"","text":"Kijk eens wat we in het tweede deel hebben geleerd:\n\n### Foutmeldingen\nProbeer je een nummer om te draaien of doe je iets anders verdachts, dan vertelt\nRuby dat met een foutmelding.\n\n### Array's\nEen array is een lijst om dingen in een bepaalde volgorde in op te slaan.\n\n### Variabelen\nIn een variabele kan je dingen bewaren. En je kunt een variable een naam geven.\nMet het = teken geef je een waarde aan een variabele. Bijvoorbeeld:  \nkaart = [14, 37, 18].\n\n### 2/8\nDeze cursus bevat acht delen. Je bent dus al op een kwart!\nEigenlijk best wel simpel allemaal. Er komen nog veel leuke dingen langs.\n\n## Maar,\nnu eerst even wat anders. Hou je een beetje van poëzie? Ik heb een versje\ngemaakt en in een variabele gestopt. Kijk maar:\n\n    puts vers","load_code":"vers = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"NL","title":"Helaas, je houd niet van toast","chapter":"N","answer":"(toast){0}","ok":"Heerlijk","error":"","text":"Ik snap het helemaal als je niet van versjes over toast houdt. Ik zou zeggen pas het maar\naan. Leef je uit. Verander de toast maar in een boterham of zo. Begin zo:\n\n    vers.gsub(\"toast\", \"stroopwafel\")\n\nDe __gsub__ methode staat voor: _global substitute_. Daarmee vervang je iedere\n\"toast\" door \"stroopwafel\".\n\n> Voetnoot van de vertaler: ik vond de Engelse versie van het gedicht te leuk en te\n> lastig om te vertalen. Heb het dus maar zo gelaten.  \n> Je zult al wel gemerkt hebben dat veel dingen helemaal niet te vertalen zijn.\n> Zoals de taal Ruby zelf.  \n> In de praktijk is Engels de voertaal voor programmeurs. Wen er maar vast aan.","load_code":"prev"},
"20":{"lang":"NL","title":"Ready, Aim","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"Lijkt wel Latijn","error":"","text":"Even een vraagje: wat gebeurt er als we het hele gedicht omdraaien?\n\n    vers.reverse","load_code":"prev"},
"21":{"lang":"NL","title":"Te veel van het goede","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"Ja, we zijn er bijna","error":"","text":"We hebben het hele vers omgedraaid, letter voor letter.\nIk wilde eigenlijk alleen maar de volgorde van de regels omdraaien.\n\nDus de regels achterstevoren. Niet de letters, dat zou achterlijk zijn.\n\nZoiets:\n\n    vers.lines.reverse","load_code":"prev"},
"22":{"lang":"NL","title":"De schakels van de ketting","chapter":"N","answer":"^More still did (.+)","ok":"Goed gedaan hoor!<br/>De join methode heeft dat array weer aan elkaar geplakt.","error":"","text":"Wat gebeurde daar ? Je voerde __vers.lines.reverse__ uit en toen?\n\nTwee dingen. Eerst zette je het versje om in losse regels met de _lines_\nmethode. _Lines_ (regels in het Nederlands) zet een string om naar een array.\nIedere regel wordt één element in het array.\n\nVervolgens heb je het array omgedraaid. Regel voor regel.\n\nWe voegen nog één methode toe aan het einde:\n\n    puts vers.lines.reverse.join\n\n> Als we meerdere methodes op deze manier aan elkaar koppelen, als een soort\n> ketting van methoden, noemen we dit in het Engels: __method chaining__.","load_code":"prev"},
"23":{"lang":"NL","title":"O nee, samenvatting 3","chapter":"Y","answer":"\\{\\}","ok":"Je hebt een haspel gemaakt !","error":"","text":"### Uitroeptekens\nMethodes kunnen gevolgd worden door een uitroepteken (soms ook een vraagteken).\nDeze zijn er alleen maar om goed duidelijk te maken wat de functie is van de\nmethode. Dat is alles.\n\n### String manipulatie\nWijzigen van strings.\n\n### Chaining\nDoor methoden aaneen te rijgen, als de schakels van een ketting, kan je heel veel\ndoen met heel weinig code. Een versje splitsen, omdraaien en weer in elkaar zetten:  \nvers.lines.reverse.join\n\nMisschien vind je het leuk om nog wat meer met het gedicht to spelen. Bijvoorbeeld met\n_vers.downcase_ of _vers.swapcase_. De complete lijst met string methoden is\n<a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">hier</a>\nte vinden.\n\n## Klaar ?\nAls je door wilt gaan typ dan:\n\n    boeken = {}","load_code":"prev"},
"24":{"lang":"NL","title":"Een boekenlijst","chapter":"N","answer":"^(uitstekend|best_goed|matig|best_wel_slecht|vreselijk)$","ok":"Dank je voor je boekverslag","error":"Gebruik: uitstekend, best_goed, matig, best_wel_slecht of vreselijk.<br/>Vergeet de dubbele punt niet","text":"Je hebt net een lege haspel gemaakt. Een wat ?\n\nIn het Engels heet dit een __hash__. En ik stel voor dat we dat woord voortaan gebruiken.\nHash betekent zoiets als verhaspelen, het bij elkaar en door elkaar gooien van de letters\nvan een woord zodat het korter wordt. Het heeft te maken met de manier waarop Ruby\neen hash opslaat in het geheugen van de computer. Is verder niet belangrijk om te weten.\n \n> Wel belangrijk om te weten is dat een hash hetzelfde is als een array, alleen\n> heeft ieder element van de hash een naam. Een array element heeft alleen een nummer.\n\nWe gaan onze hash gebruiken om er wat boekverslagen in op te slaan. Dit zijn de waarderingen:\n\n- :uitstekend &rarr; een meesterwerk\n- :best\\_goed &rarr; amusant\n- :matig &rarr; goed en slecht tegelijk\n- :best\\_wel\\_slecht &rarr; vooral slecht\n- :vreselijk &rarr; hopeloos geval\n\nOm een boekverslag toe te voegen zetten we de titel van het boek tusen [ ] haakjes en\nomdat de titel een string is ook tussen aanhalingstekens. Bijvoorbeeld:\n\n    boeken[\"De regenboog\"] = :uitstekend\n\n> Het is misschien wel handig om te weten dat alle TryRuby lessen los van elkaar\n> staan. Dus als je hier tig boekverslagen intypt kan je die alleen in deze les gebruiken.\n> Je kan ze natuurlijk wel kopieëren en plakken in de volgende les.  \n> Ik heb iedere les voldoende dingen meegegeven waar je mee kunt spelen.","load_code":"boeken = {}"},
"25":{"lang":"NL","title":"Meer reviews","chapter":"N","answer":"[3-9]","ok":"De length methode werkt zowel voor een string, array als hash","error":"","text":"Ok, ga maar door met toevoegen van boekverslagen. Als je de hele lijst wilt zien\nkan je __puts boeken__ gebruiken.\n\nDe beoordelingen zijn: :uitstekend, :best\\_goed, :matig, :best\\_wel\\_slecht, :vreselijk.\n\n> De hier getoonde beoordelingen zijn geen strings. Als je een dubbele punt voor een woord\n> zet krijg je een __symbool__.  \n\nSymbolen kosten de computer minder geheugenruimte. Maar belangrijker:\nals je een symbool in een programma ziet staan geeft dat aan dat dat symbool een bepaalde\nbetekenis heeft en niet zomaar een willekeurig gekozen woord is.\n\nVoeg nog 2 boekverslagen toe. Gebruik __boeken.length__ om te zien hoeveel verslagen\ner al in de hash zitten:\n\n    boeken[\"Het puffertje\"] = :vreselijk\n    boeken[\"Kleurenblind\"] = :matig\n    \n    puts boeken\n    \n    puts boeken.length","load_code":"boeken = {\"De regenboog\" => :uitstekend}"},
"26":{"lang":"NL","title":"Eh, wat vond ik ook al weer van De regenboog?","chapter":"N","answer":"^(uitstekend|quite_good|mediocre|quite_not_good|abysmal)$","ok":"O ja, ik vond het een meesterwerk","error":"","text":"Weet je nog hoe we een waarde uit een array haalden:  \n__puts ticket[1]__.\n\nBij een hash werkt dit hetzelfde, alleen gebruiken we geen nummer om een element op te zoeken\nmaar een naam.\n\nDus als je een oud boekverslag op wilt zoeken zet je nu de naam van het boek tussen de [ ]\nhaken. En het = teken laten we weg:\n\n    boeken[\"De regenboog\"]","load_code":"boeken = {\"De regenboog\" => :uitstekend, \"Het puffertje\" => :vreselijk, \"Kleurenblind\" => :matig}"},
"27":{"lang":"NL","title":"De hash als paar","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Je hebt de sleutels gevonden","error":"","text":"In tegenstelling tot een array kent een hash geen volgorde van zijn elementen. Daar\nis een hash ook niet voor gemaakt.\n\nEen hash bevat alleen maar paren. Ieder paar bestaat uit een __sleutel__ en een\n__waarde__ (_key_ en _value_ in het Engels).\n\nIn jouw boekverslagen is de titel van het boek de sleutel en de beoordeling is de waarde.\n\nAls je alle boektitels wilt zien kan je alle hash sleutels opvragen:\n\n    boeken.keys\n\nProbeer dit ook eens met .values in plaats van .keys.","load_code":"prev"},
"28":{"lang":"NL","title":"Hoe streng ben jij?","chapter":"N","answer":"\"matig\"","ok":"Wow! Je hebt een scorelijst gemaakt.","error":"","text":"Misschien geef jij wel gemene boek beoordelingen ? We gaan de score eens bijhouden.\nDat doen we in een nieuwe hash __scores__:\n\nIk heb wat code geschreven om de beoordelingen te tellen. Geen paniek als je de code\nniet meteen begrijpt. In de volgende lessen wordt het allemaal uitgelegd.\n\nTyp:\n\n    scores = Hash.new {0}\n    \n    boeken.values.each { |beoordeling|\n      scores[beoordeling] += 1\n    }\n    \n    puts scores\n\nDat verticale streepje | zit op de meeste toetsenborden boven de enter toets.\n\nDie regel met _+= 1_ betekent: verhoog de waarde met 1.","load_code":"boeken = {\"De regenboog\" => :uitstekend, \"Het puffertje\" => :vreselijk, \"Kleurenblind\" => :matig, \"Bloemetjes en bijtjes\" => :matig}"},
"29":{"lang":"NL","title":"Een blokje om","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"We hebben net een mooie en handige eigenschap van Ruby gebruikt, namelijk een __blok__.\nDaar gaan we in deze en de volgende les eens beter naar kijken.\n\nHeel simpel gezegd is een blok gewoon een stukje Ruby code dat tussen accolades { } staat.\n\nHier heb ik nog een blok voor je:\n\n    5.times { print \"Odelay! \" }\n\nEen blok zit altijd vast aan een methode. In dit voorbeeld de __times__ methode.  \nTimes (keer) voert een blok meerdere keren uit. In dit geval 5 keer.","load_code":""},
"30":{"lang":"NL","title":"Ben je bij de tijd?","chapter":"N","answer":"^[0-9]$","ok":"Goed getimed!","error":"Voer het blok 0 tot 9 keer uit.","text":"In het eerste voorbeeld van een blok (bij het maken van de scorelijst) zagen we al dat\nwe een waarde kunnen doorgeven aan het blok.\nWelke waarden worden __doorgegeven__ wordt bepaald door de methode die het blok uitvoert.\n\nDe waarden die worden __ontvangen__ door het blok, worden in de variabele gezet die\naan het begin van het blok tussen 2 verticale streepjes | staat.\n\nWe kunnen dit uitproberen met het volgende blok:\n\n    5.times { |tijd|\n      puts tijd\n    }\n\nMethode __.times__ geeft een waarde door aan variabele __|tijd|__.  \nDe _tijd_ variabele is alleen maar binnen het blok bekend !\n\n> Zie je dat je code over meerdere regels uit kunt splitsen? Dit maakt code\n> makkelijker te lezen.","load_code":""},
"31":{"lang":"NL","title":"Samenvatting 4 is hier","chapter":"Y","answer":"","ok":"","error":"","text":"Deel 3 duurde wat langer om door te nemen. Je hebt dit allemaal geleerd:\n\n### Hash\nEen soort woordenboek met sleutels en waarden, die je maakt met: __{}__\n\n### Symbolen\nKorte, duidelijke, efficiente woorden, die beginnen met een dubbele punt: __:uitstekend__\n\n### Blokken\nStukjes code die je aan allerlei Ruby methoden kunt hangen. Hiermee maakte je een\nscorelijst:  \n__boeken.values.each { |beoordeling|  \n&nbsp;&nbsp;scores[beoordeling] += 1  \n}__\n\n### En nu\nIn de volgende lessen gaan we ons verder verdiepen in methoden.","load_code":""},
"32":{"lang":"NL","title":"To (be) or not to (be)","chapter":"N","answer":"Hello","ok":"Hoi","error":"","text":"Er is iets waar we het nog niet over hebben gehad: parameters voor methoden.\nIn het Engels vaak ook \"arguments\" genoemd.\n\nToen we het gedicht een beetje veranderden gebruikten we:\n__vers.gsub(\"toast\", \"stroopwafel\")__\n    \nDe gsub methode heeft 2 parameters nodig. Deze gaven we door met de twee strings tussen haakjes\nachter de methode.\n_Parameters zorgen er voor dat een methode precies weet wat 'ie moet doen._\n\n\n### Haakjes\nMeestal maakt het Ruby niets uit of je de haakjes wel of niet gebuikt. Dit zou ook werken:  \n__vers.gsub \"toast\", \"stroopwafel\"__\n\nWe hebben al een andere methode gebruikt met een parameter. Heel vaak zelfs, maar het viel niet\necht op:\n\n    puts \"Hello\"\n    puts(\"Hello\")\n    \nJa, __puts__ is ook een methode. Puts met of zonder haakjes voor de parameter maakt voor Ruby\nniets uit. De versie zonder is wel iets makkelijker te lezen.\nEn het scheelt jou natuurlijk een hoop kostbare toetsaanslagen!\n\n> Ik denk dat de conclusie hier is dat met haakjes alles mag, als het maar goed leesbaar is.\n\n### to (be) or not to (be)\nDus als _to_ een methode is, en _be_ een parameter dan weten wij het antwoord nu wel op deze\neeuwenoude vraag. Het is gewoon een kwestie van voorkeur voor _to be_ of voor _to(be)_\n\nWil je meer weten van Shakespeare ? Klik op _Next_.","load_code":"vers = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nEnz. enz. enz.\\n\""},
"33":{"lang":"NL","title":"The Taming of the Shrew","chapter":"N","answer":"^tem","ok":"Goed goed !","error":"","text":"Je hebt Ruby inmiddels al aardig onder de knie. De basis in ieder geval.\nHet enige wat je nog moet doen is het leren kennen van meer methoden en\ngrotere blokken code uitproberen.\n\nÉén ding wat ik je nog uit moet leggen is het zelf maken van methoden.\n__Ahum!__ Geen getreuzel meer, we beginnen:\n\nBehalve de in Ruby ingebakken methoden (zoals puts, sort, times) kan je ook\nzelf methoden definiëren. Maar waarom zou je dat eigenlijk willen. Twee redenen:\n\n### Om je programma korter te maken\nAls je dezelfde functionaliteit nodig hebt op meer dan één plek in je code,\nkan je die functionaliteit beter in een methode stoppen. De code wordt hierdoor\nkorter.\n\n### Beter leesbare code\nStel je voor dat je code heel veel verschillende dingen moet doen. Je __zou__\nal die code als één lang stuk kunnen intypen. Maar de code zou hierdoor moeilijk\nte lezen en te begrijpen zijn. Vooral als je het een tijd later weer bekijkt.\n\nHet is beter om die lange code over meerdere methoden te verdelen. Geef iedere\nmethode een begrijpelijk naam. Je zal jezelf later dankbaar zijn.\n\nHoe definieer je een methode ? Zo:\n\n    def tem( aantal_heksen )\n    end\n\nP.S. \"The Taming of the Shrew\" (Het temmen van de heks) is een toneelstuk van Shakespeare.","load_code":""},
"34":{"lang":"NL","title":"In Ruby betekent Def Leppard definieer methode Leppard","chapter":"N","answer":"^tem","ok":"Tem is niet tam","error":"","text":"Goed zo, je hebt zelf een methode gemaakt. Je begon met __def__ (afkorting van definieer)\ngevolgd door de naam van de nieuwe methode.  \nVervolgens gaf je op dat de methode één parameter heeft.\nJe beëindigde de definitie met het woordje __end__.\n\nNu hoeven alleen nog maar wat code aan de nieuwe methode toe te voegen.\n\nDeze code:\n    \n    def tem( aantal_heksen )\n      aantal_heksen.times {\n        puts \"Een heks is getemd\"\n      }\n    end\n    \n> __P.S.__  \n> Als je de titel van deze les niet begrijpt snap ik dat wel.\n> <a href=\"http://nl.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\n> is de naam van een, ooit beroemde, Engelse rock band.","load_code":""},
"35":{"lang":"NL","title":"De zoete vruchten van je eigen creatie","chapter":"N","answer":"^Een heks is getemd","ok":"Dat zal ze leren","error":"","text":"En zo worden nieuwe methodes geboren.\n\nIk wil 'em meteen gebruiken:\n\n    tem 5","load_code":"def tem( aantal_heksen );aantal_heksen.times{puts \"Een heks is getemd\"};end;"},
"36":{"lang":"NL","title":"Geven en nemen","chapter":"N","answer":"\\d+","ok":"Ja. Super.","error":"","text":"De meeste methoden willen niet alleen één of meer parameters als invoer, maar __geven ook\nweer iets terug__. Ik heb onze methode een beetje aangepast zodat we een waarde terug krijgen.\nRuby gebruikt hiervoor het woordje __return__.\n\nProbeer maar:\n\n    def tem( aantal_heksen )\n      aantal_heksen.times {\n        puts \"Een heks is getemd\"\n      }\n      return aantal_heksen\n    end\n    \n    puts tem(3)\n\n### Return\nEn omdat je zo leergierig bent heb ik nog een extra tip voor je:\nje mag in Ruby het woordje __return__ weglaten. Ruby geeft automatisch de laatste\nwaarde waar in de methode iets mee gedaan is terug.\n\nDe laatste regel van de methode kunnen we veranderen in: __aantal\\_heksen__.\nProbeer maar.\n\nMaar. Methode __.times__ geeft ook al _aantal\\_heksen_ terug. Dus we kunnen die hele\nlaatste regel weglaten.  \nEigenlijk deed de oorspronkelijke versie van de methode al precies wat we wilden!","load_code":""},
"37":{"lang":"NL","title":"Ben je er nog? Samenvatting 5 groet u","chapter":"Y","answer":"","ok":"","error":"","text":"Goed gedaan! Echt. Serieus. Ik meen het.\n\nDit heb je in de afgelopen minuten geleerd:\n\n### Methoden\nMethoden kan je definiëren met __def__ en een naam. Methodes zorgen ervoor dat je\nprogramma's korter en beter leesbaar zijn.\n\n### Parameters\nMethodes kunnen parameters hebben.\n\n### Return waarde\nMethodes geven (bijna) altijd een waarde terug.\n\n## En verder\nTo be or not to (be) weten we nu het antwoord wel op.  \nNog maar 3 delen te gaan.  \nInteresse in meer Shakespeare?","load_code":""},
"38":{"lang":"NL","title":"We kunnen de hele wereld aan","chapter":"N","answer":"^\\{\\\"William","ok":"Goed. Wel lastig te lezen zo.","error":"","text":"Tot op heden hebben we programma's uitgevoerd die we zelf hebben ingetypt. En dat is\nharstikke leuk. Vooral dat _Odelayen_ vond ik een hoogtepunt.\nMaar dit is wel het internet tijdperk. Het wordt dus tijd om de rest van de wereld\nbij ons programmeerwerk te betrekken!\n\nEr zijn heel veel websites beschikbaar die je om informatie kunt vragen. Deze link geeft\nje bijvoorbeeld al het\n<a href=\"http://news.google.nl/news/section?q=ruby&output=rss\" target=\"_blank\">actuele nieuws</a>\nover Ruby.\n\nJouw web browser toont dit waarschijnlijk in een goed leesbaar formaat. Maar kijk eens naar\nde broncode van die webpagina (met control-U). Dan zie een lange regel met vreemd opgemaakte\ntekst. In het Google news voorbeeld is dit het __rss__ formaat.\n\n### Formaten\nEr zijn heel veel verschillende formaten in gebruik op het grote internet. Met\nrare namen als: html, xml en json. Ook deze website gebruikt dit soort formaten.\n\nIk ben zo vrij geweest een methode voor te bereiden waarmee je de volledige lijst\nmet toneelstukken van William Shakespeare van het internet haalt.\n(Stiekum komt deze lijst van de server waar deze website op draait, we vallen dus\nniemand lastig.)\n\nHaal de gegevens op met:\n\n    get_shakey","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"NL","title":"The Two Noble Kinsmen","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Dat is beter!","error":"","text":"Okee, we hebben nu een lijst met toneelstukken. Deze lijst was in het json formaat.\nGelukkig kent Ruby een methode om json om te zetten naar een hash.\nDe _get\\_shakey_ methode heeft dat al voor ons gedaan.\n\nHelaas is de structuur van het json bestand wel overgenomen in de hash. Nog steeds vrij\nlastig te lezen dus. Als we nou eens een methode maken die alles netjes uitprint.\n\nKijk nog eens naar de lijst van de vorige les. Ziet er ongeveer zo uit:\n\n<ul>\n  <li>\"William Shakespeare\"\n  <ul>\n      <li>\"1\"\n      <ul>\n        <li>\"title\": \"The Two Gentlemen of Verona\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>\"2\"\n      <ul>\n        <li>\"title\": \"The Taming of the Shrew\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>...</li>\n  </ul>\n  </li>\n</ul>\n\nOm alle toneelstukken te zien moeten we eerst het \"William Shakespeare\" hash element\nbenaderen. Daarna moeten we door alle elementen daaronder bladeren. __Itereren__\nheet dat.  \nRuby heeft hier een methode voor: __each__. We zijn 'em al even tegengekomen bij\nhet maken van de boeken scores.\n\nWe gaan alles wat methode __each__ vindt doorgeven aan een blok:\n\n    s = get_shakey\n    \n    s[\"William Shakespeare\"].each { |key, val|\n      puts val[\"title\"]\n    }","load_code":"prev"},
"40":{"lang":"NL","title":"En nu in één keer","chapter":"N","answer":"^4$","ok":"Idd, Shakespeare schreef 4 toneelstukken in 1591. Druk baasje.","error":"Nee, in 1591 schreef hij er 4","text":"Okee, maar stel dat we alleen geïnteresseerd zijn in de namen en het aantal toneelstukken\ndat door Shakespeare in één jaar is geschreven?\n\nMet __select__ kunnen we waarden selecteren uit een hash. De _select_ methode gebruikt een\nblok om aan te geven wat we precies willen selecteren.  \nWe kunnen de door _select_ teruggegeven waarden gebruiken in de __each__ methode. Dit hebben\nwe al eerder gezien en is weer een voorbeeld van _method chaining_.\n\n> Ik heb een __tel\\_toneelstukken__ methode voor je gemaakt.\n> Probeer jij eens uit te zoeken hoeveel toneelstukken Shakespeare in __1591__ heeft geschreven:\n\n    def tel_toneelstukken(jaar)\n      s = get_shakey\n      \n      s[\"William Shakespeare\"]\n        .select { |k, v|\n          v[\"finished\"] == jaar\n        }.each { |key, val|\n          puts val[\"title\"]\n        }.count\n    end\n    \n    puts tel_toneelstukken(0)\n\nViel het je op dat ik _count_ aan de _each_ methode heb vastgeplakt.\nDit zorgt voor de return waarde van de __tel\\_toneelstukken__ methode.\n\nEr is nog een mogelijkheid voor _method chaining_. Zie je dat regeltje\n__s = get_shakey__ eenzaam en alleen staan?\nJe zou __[\"William Shakespeare\"].select { |k, v|__ achter _get\\_shakey_\nkunnen zetten (zonder punt in dit geval).","load_code":"prev"},
"41":{"lang":"NL","title":"Eind Goed Al goed","chapter":"N","answer":"All's Well That Ends Well","ok":"Eind Goed Al goed","error":"Gebruik 1605 als tweede parameter","text":"We hebben nu dus wat data van het internet gehaald, we hebben geselecteerd wat we wilden\nhebben en dit uitgeprint.\nWat nu nog ? We zouden de resultaten wat mooier kunnen printen. Met het jaar er bij en\nalles netjes uitgelijnd.\n\nHiervoor moeten we twee waarden op één regel zetten. Ruby heeft daar een mooie truuk\nvoor. Het werkt net als het printen van een gewone string. Bijvoorbeeld:\n__puts \"Hallo, ik ben Jantje\"__.\nMaar in plaats van _Jantje_ gebruiken we de waarde van een variabele.\n\nEerst vervangen we __Jantje__ door __#{}__. Ruby weet dan dat er een variable aankomt.\nDe string wordt nu:  \n__\"Hallo, ik ben \\#{naam}\"__.\n\nWe passen onze code een beetje aan:\n\n    def print_toneelstukken(jaar_van, jaar_tot)\n      get_shakey[\"William Shakespeare\"]\n        .select { |k, v|\n          jaar_van <= v[\"finished\"] &&\n          jaar_tot >= v[\"finished\"]\n        }.each { |k, v|\n          puts \"#{v[\"title\"].ljust(30)} #{v[\"finished\"]}\"\n        }\n    end\n    print_toneelstukken(1600, 1605)\n\nDat __.ljust(30)__ heb ik toegevoegd om te zorgen dat de titel altijd minimaal 30\nletters lang is. Hierdoor is het jaartal mooi links uitgelijnd (_left justified_).\n\nKan jij de code zo aanpassen dat de uitvoer er zo uitziet:  \n__1600 -> As You Like It__\n\n### Eind Goed Al goed ?\nHé we zijn er nog niet. Maar het eind is in zicht!","load_code":"prev"},
"42":{"lang":"NL","title":"Kon ik toch maar beslissen","chapter":"N","answer":"","ok":"","error":"","text":"Beslissingen nemen kan in het dagelijks leven soms een probleem zijn.\nVoor ons gelukkig niet. In Ruby is dit namelijk heel gemakkelijk.\n\n    if 1 < 2\n      puts \"Het is waar: 1 is kleiner dan 2\"\n    end\n\nHet belangrijkste woord is hier: __if__. If (als) kan voor of achter een methode worden\ngeplaatst. Zo:\n\n    puts \"Het is waar: 1 is kleiner dan 2\" if 1 < 2\n\n__If__ is een methode met één parameter. Die parameter is een Ruby uitdrukking\ndie je wilt testen.\nDe te testen uitdrukking (expression in het Engels) moet of __true__ (waar) zijn\nof __false__ (niet waar).\n\nDit zijn wat voorbeeld uitdrukkingen:\n\n    5     <= 10     # => true\n    'abc' == 'def'  # => false\n    true            # => true\n    123456          # => true\n    0               # => true\n    nil             # => false\n    'xyz'.empty?    # => false\n    'a' > 5         # => error:\n                    # comparison of String with\n                    # Numeric failed\n\nDe te testen uitdrukking kan vele vormen aannemen. Je kan bijvoorbeeld\nletterlijk waarden opgeven (1 < 2) of variabelen (a < 1) of de waarde\nvan een methode gebruiken ('xyz'.empty?).","load_code":""},
"43":{"lang":"NL","title":"is == is ?","chapter":"N","answer":"is niet gelijk aan 100$","ok":"Dat is beter","error":"Dit kan niet kloppen","text":"Zag je dat dubbele is teken in __'abc' == 'def'__?\n\nZo'n dubbele is __==__ betekent __is gelijk aan ???__  \nHet enkele is-teken die we hiervoor al vaak hebben gezien betekent:\n__ken een waarde toe aan een variabele__ (dit heet assigment in het Engels).\n\nEn om je nog verder in verwarring te brengen: je mag de assignment gebruiken\nbij een __if__ methode. Een voorbeeld:\n\n    a = 0\n    \n    if a = 100\n      puts \"De uitdrukking is waar, maar a is nu: #{a}\"\n    else\n      puts \"#{a} is niet gelijk aan 100\"\n    end\n\nWijzig de __=__ in __==__ en kijk wat er gebeurt.\n\nGegarandeerd zal je af en toe vergeten de tweede = in te typen. Overkomt mij ook\nnog wel eens.\n\n### else\nIn de voorbeeld code staat ook een __else__. Deze hoort bij de __if__. De regel\nna de _else_ zal worden uitgevoerd als de _if test uitdrukking_ niet waar is.\n\n> Er zijn nog meer variaties op dit als-dan-anders thema. Lees er meer over in de Ruby\n> <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">documentatie</a>.","load_code":""},
"44":{"lang":"NL","title":"Ik ben hongerig","chapter":"N","answer":"^Ik ben niet hongerig","ok":"Klopt","error":"Om 10 uur heb ik nog geen trek !","text":"Dit gaat echt goed. Gaat jou gemakkelijk af allemaal, en dat terwijl je een kwartier\ngeleden nog helemaal __niets van Ruby wist !__\n\nLaatste stap van dit onderdeel. We laten nu alles samenwerken als één soepele machine.\n\nEerst definiëren we twee methoden. Dan nemen we een beslissing:\n\n    def hongerig?(tijdstip_in_uren)\n      puts \"Ik ben hongerig\"\n      true\n    end\n    \n    def eet_een(wat)\n      puts \"Ik eet een #{wat}\\n\"\n    end\n    \n    eet_een 'appel' if hongerig?(14)\n    \n    eet_een 'appel' if hongerig?(10)\n\nKan jij de methode __hongerig?__ zo aanpassen dat er __\"Ik ben niet hongerig.\"__\ngetoond wordt en __false__ teruggeeft als het tijdstip kleiner is dan 12.  \n(Dit is de lastigste TryRuby opgave !)","load_code":""},
"45":{"lang":"NL","title":"Samenvatting 6 We zijn er bijna","chapter":"Y","answer":"\\{\\}","ok":"Okee, een lege hash","error":"","text":"Je hebt level 6 bereikt !!! Goed hoor.  \nEerst nog even een samenvatting:\n\n### Data\nJe hebt data van het internet gehaald, een data structuur gelezen en waarden geselecteerd.\n\n### Iteratie\nJe bent door alle waarden van een hash gegaan met __each__. En je hebt meer __methodes\ngechained__.\n\n### Netjes printen\nEn alsof dat allemaal nog niet genoeg was heb je ook nog wat variabelen heel netjes\nen leesbaar uitgeprint. Je hebt in feite al __een echt programma gemaakt !__\n\n### Als\nJe hebt jouw programma's naar jouw hand gezet met __if__ en __else__.\n\n## Dus\nWat zou er nu nog kunnen komen ? Wat valt er nu nog te leren ?\nHa, dat is het mooie. Je hebt nu al zoveel kennis opgedaan dat we de laatste stap\nook kunnen zetten. We gaan _klassen_ bekijken. Nog 2 korte onderdelen en dan ben\nje volleerd.\n\nEen aantal lessen terug hebben we een nieuwe hash gemaakt:\n\n    Hash.new","load_code":""},
"46":{"lang":"NL","title":"Geen Schoolklas, maar de Werkende Klasse","chapter":"N","answer":"","ok":"","error":"","text":"De accolades __{}__ die we eerder hebben gebruikt is gewoon een afkorting voor __Hash.new__.\nDe __new__ methode wordt gebruikt om nieuwe objecten te maken van een bepaalde klasse.\nIn dit geval de Hash klasse.\n\nBij klasse moet je bijvoorbeeld denken aan de \"werkende klasse\". Een groep objecten met\ndezelfde eigenschappen: zelfde banen, huizen, kledingstijl. Wat heb je aan klassen ?\n\n### Blurbalizer<sup>TM</sup>\nJe hebt net een geniaal idee plan voor een nieuwe _app_ bedacht. Jouw app wordt __het__\nnieuwe instant messaging platform. Met jouw app kunnen mensen elkaar korte berichten\nsturen. Je noemt zo'n bericht een Blurb<sup>TM</sup>.\nEen Blurb<sup>TM</sup> mag 40 tekens bevatten. Je kan er ook een stemming in opnemen.\n\n### Hoe ga je beginnen\nJe zou de Blurbs<sup>TM</sup> misschien op kunnen slaan in een json bestand.\nMaar hoe houd je dan bij wanneer de Blurb<sup>TM</sup> is gemaakt?\nEn als je het bestand laadt hoe ga je er dan mee om in Ruby? Stop je de Blurbs<sup>TM</sup>\nin een hash? Of een array? of een array van array's? Of nog iets anders?\n\n### Klasse\nIk kan je hiervoor van harte een klasse aanbevelen (class in het Engels).\nJe kent eigenlijk al een hoop Ruby klassen: Hash, Array, String.  \nWe kunnen zelf ook een klasse maken (geeft geen output):\n\n    class Blurb\n    end","load_code":""},
"47":{"lang":"NL","title":"Bouwstenen","chapter":"N","answer":"","ok":"","error":"","text":"Je hebt een nieuwe Blurb<sup>TM</sup> klasse gemaakt.\n\nWat gaan we daar allemaal in bijhouden? De Blurb<sup>TM</sup> tekst uiteraard.\nEn de datum en tijd van posten. En de stemming van de poster.\n\nWe hebben de eerste regel van de klasse, dit is de rest:\n\n    class Blurb\n      attr_accessor :tekst, :tijd, :stemming\n    end\n\nDe naam van een klasse begint altijd met een hoofdletter.\n\n(Nog steeds geen output)","load_code":""},
"48":{"lang":"NL","title":"Accessors, De Toegangspoorten","chapter":"N","answer":"Blurb:","ok":"Mijn eerste Blurb","error":"","text":"Hee, grote klasse die Blurb<sup>TM</sup> klasse!\n\nIn de klasse definitie staat een methode: __attr\\_accessor__.\nEr zijn allerlei __attr__ibute methoden. Deze voegen wat eigenschappen toe aan je klasse.\nAttributen zijn gewoon variabelen die bij een klasse horen.\n\nDe attr\\_accessor methode die wij gebruikten betekent: iedereen heeft toegang (access)\ntot de klasse variabelen: tekst, tijd, en stemming.\n\n### Dus\nOm een Blurb<sup>TM</sup> maken:\n\n    blurb1 = Blurb.new\n    puts blurb1\n    blurb1.tekst = \"Today Mount Hood Was Stolen!\"","load_code":"class Blurb;attr_accessor :tekst,:tijd,:stemming;end"},
"49":{"lang":"NL","title":"Een Object, Een Pakketje","chapter":"N","answer":"Blurb:","ok":"Blurb updated","error":"","text":"Maak de Blurb<sup>TM</sup> maar af. Voeg een tijd en stemming toe:\n\n    blurb1.tijd = Time.now\n    blurb1.stemming = :verdrietig\n    \n    puts blurb1","load_code":"prev;blurb1=Blurb.new;blurb1.tekst=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"NL","title":"Dat kan sneller","chapter":"N","answer":"^\\d{4}","ok":"Genoteerd","error":"","text":"Je app is nu al cool. Wat dacht je er van om jezelf wat werk uit handen te nemen.\nIedere keer dat er een Blurb<sup>TM</sup> gemaakt wordt moet je de tijd van posten\ninstellen. Best vervelend niet waar?\n\nWe kunnen een __initialize__ (initialiseer) methode aan onze klasse toevoegen.\nDeze methode wordt uitgevoerd zodra je een nieuwe Blurb<sup>TM</sup> maakt.\n\nDan kunnen we ook meteen instellen dat de maximale Blurb<sup>TM</sup> tekst lengte\n40 tekens is:\n\n    class Blurb\n      attr_accessor :tekst, :tijd, :stemming\n\n      def initialize(stemming, tekst=\"\")\n        @tijd     = Time.now\n        @tekst    = tekst[0..39]\n        @stemming = stemming\n      end\n    end\n    \n    Blurb.new.tijd\n\n(Parameter __tekst=\"\"__ zorgt er voor dat we zeker weten dat _tekst_ een string is.\nOok als _Blurb.new_ wordt aangeroepen zonder parameters.)","load_code":""},
"51":{"lang":"NL","title":"Binnenste Buiten","chapter":"N","answer":"Blurb:","ok":"Blurb toegevoegd","error":"","text":"Zag je dat er in de klasse voor de variabelen een @ teken stond (@tijd) ?\n\n__Buiten__ de klasse, gebruiken we accessors:\n\n> __blurb.tijd = Time.now__,\n\nmaar __binnenin__ de klasse gebruiken we __object variabelen__:\n\n> __@tijd = Time.now__.\n\nHet gaat om precies dezelfde variabelen maar benaderd vanuit twee verschillende delen\nvan het programma.\n\n### Maak nog maar eens een Blurb<sup>TM</sup>\nAls je nu een nieuwe Blurb<sup>TM</sup> maakt wordt de initialize methode aangeroepen\nom de opgegeven parameters te controleren.\n\nUh, we hebben 2 parameters nodig:\n\n    blurb2 = Blurb.new :verward, \"I can not believe Mt. Hood was stolen!\"","load_code":"class Blurb;attr_accessor :tekst,:tijd,:stemming;def initialize(stemming, tekst=\"\");@tijd=Time.now;@tekst=tekst[0..39];@stemming=stemming;end;end;blurb1=Blurb.new(:verdrietig,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"NL","title":"Even pauze voor samenvatting 7","chapter":"Y","answer":"","ok":"","error":"","text":"Ah daar ben je. En nog helemaal heel. We gaan zo verder met het af maken van jouw app,\nmaar eerst even reviewen, okee ?\n\n### Klassen\nAlles in Ruby is een object. Objecten worden beschreven door een klasse definitie.\nJe hebt bijvoorbeeld wat Blurbs<sup>TM</sup> gemaakt en het gedrag van deze\nobjecten staat in de Blurb klasse.  \nIn andere woorden: je noemt ze Blurb objecten.  \nKlassen kan je gebruiken om een model te maken van echte tastbare objecten.\n\n### Accessors\nAccessors zijn variabelen die bij een object horen en die je buiten de klasse\ndefinitie kunt gebruiken.  \n(blurb1.tijd = Time.now)\n\n### Object variabelen\nObject variabelen zijn dezelfde variabelen als de accessors, maar dan __binnenin__\nde klasse.  \n(@tijd = Time.now)","load_code":"prev;blurb2=Blurb.new :verward, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"NL","title":"Op eigen benen","chapter":"N","answer":"Blurbalizer:","ok":"Mijn app is gemaakt","error":"","text":"Okee, de laatste loodjes. Nu begint het laatste hoofdstuk van het _aangrijpende,\nheroïsche_ verhaal over Ruby.  \nJe weet al heel goed hoe alles werkt en hoe je het moet toepassen.\nMaar nog een klein beetje begeleiding kan vast geen kwaad.\n\n### Af maken die app\nJe hebt nu wel losse Blurbs<sup>TM</sup>, maar nog geen complete app.\nEen app heeft een titel nodig, een plek om Blurbs<sup>TM</sup> te bewaren\nen een tijdbalk kan ook geen kwaad.\n\nÉén keer raden. We hebben nog een klasse nodig. Ik heb hieronder alle code gezet\ndie je nodig hebt.  \nNeem __rustig de tijd__ om het door te nemen. Kijk of je alles snapt.  \nIk heb geen haast. Ik wacht op je bij de volgende les.\n\n    class Blurbalizer\n      def initialize(titel)\n        @titel  = titel\n        @blurbs = [] # Een schoon nieuw array\n                     # om Blurbs in op te slaan\n      end\n      \n      def voeg_blurb_toe(stemming, tekst)\n        # De << betekent: voeg iets toe aan het einde van een array\n        @blurbs << Blurb.new(stemming, tekst)\n      end\n      \n      def toon_timeline\n        puts \"Blurbalizer: #{@titel} heeft #{@blurbs.count} Blurbs\"\n        \n        @blurbs.sort_by { |t|\n          t.tijd\n        }.reverse.each { |t|\n          puts \"#{t.tekst.ljust(40)} #{t.tijd}\"\n        }\n      end\n    end\n    \n    mijnapp = Blurbalizer.new \"De Laatste Blurbs\"","load_code":"class Blurb;attr_accessor :tekst,:tijd,:stemming;def initialize(stemming, tekst=\"\");@tijd=Time.now;@tekst=tekst[0..39];@stemming=stemming;end;end"},
"54":{"lang":"NL","title":"De nieuwste Blurbs","chapter":"N","answer":"","ok":"","error":"","text":"Daar ben je. Denk je dat je alle Blurbify<sup>TM</sup> code hebt begrepen? Vast wel.\n\n> In de Blurbify<sup>TM</sup> klasse zitten 2 __methoden__ (voeg\\_blurb\\_toe en\n> toon\\_timeline).\n> Een klasse methode kan je buiten de klasse definitie gebruiken, net als accessors.\n\nHoog tijd om Blurbalizer<sup>TM</sup> op te starten.\nIk heb al wat Blurbs<sup>TM</sup> voor je toegevoegd, maar als je er zelf meer\ntoe wilt voegen: leef je uit.\n\nBlurbs<sup>TM</sup> maken we nu niet meer rechtstreeks, maar via de __voeg\\_blurb\\_toe__\nmethode. Hierdoor weten we zeker dat alle nieuwe Blurbs<sup>TM</sup> worden opgeslagen\nbinnen het __mijnapp__ object.\n\n    mijnapp.voeg_blurb_toe :stemming, \"Mijn Blurb tekst\"\n    \n    mijnapp.toon_timeline","load_code":"prev;class Blurbalizer;attr_reader :titel;def initialize(titel);@titel=titel;@blurbs=[];end;def voeg_blurb_toe(stemming, tekst);@blurbs << Blurb.new(stemming, tekst);@blurbs.each {|t| t.tijd -= 73};end;def toon_timeline;puts \"Blurbalizer: #{@titel} heeft #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.tijd}.reverse.each { |t| puts \"#{t.tekst.ljust(40)} #{t.tijd}\"};end;end;mijnapp = Blurbalizer.new \"De Laatste Blurbs\";mijnapp.voeg_blurb_toe :verdrietig,\"Today Mount Hood Was Stolen!\";mijnapp.voeg_blurb_toe :verward,\"I can not believe Mt. Hood was stolen!\";mijnapp.voeg_blurb_toe :verdoofd,\"I am speechless!\";mijnapp.voeg_blurb_toe :boos,\"It was stolen by a giraffe !!\";mijnapp.voeg_blurb_toe :verdrietig,\"I Left my Hoodie on the Mountain!\";mijnapp.voeg_blurb_toe :boos,\"I am never going back to that mountain.\""},
"55":{"lang":"NL","title":"De Combinatie Telt","chapter":"N","answer":":-","ok":"Stemmig !","error":"","text":"Door de eenvoudige onderdelen van Ruby te combineren kunnen hele mooie programma's\nworden gemaakt.  \nHier hebben we een klasse gebruikt die weer een andere klasse bevat. Ruby kan\nuitstekend met zo'n aanpak overweg. Dit heeft ook een naam:  \n_object georiënteerd programmeren_.\n\nWe zijn alweer bij de __laatste programmeer oefening__ van TryRuby.\nAls je zin hebt kan je nog wat meer features toevoegen aan Blurbalizer<sup>TM</sup>.\n\nMisschien is het wel leuk om de stemming ook als smiley weer te geven in de\n__toon_timeline__ methode.\nJe zou een _smiley_ methode kunnen toevoegen aan de Blurb klasse en\ndie daarna gebruiken in de _toon\\_timeline_ methode:\n\n    class Blurb\n      attr_accessor :tekst, :tijd, :stemming\n      \n      def initialize(stemming, tekst=\"\")\n        @tijd     = Time.now\n        @tekst    = tekst[0..39]\n        @stemming = stemming\n      end\n      \n      def smiley\n        if    @stemming == :verdrietig\n          return \":-(\"\n        elsif @stemming == :blij\n          return \":-)\"\n        # Voeg hier andere stemmingen toe\n        end\n        \n        # De 'standaard' stemming\n        \":-|\"\n      end\n    end\n    \n    class Blurbalizer\n      def initialize(titel)\n        @titel  = titel\n        @blurbs = []\n      end\n      \n      def voeg_blurb_toe(stemming, tekst)\n        @blurbs << Blurb.new(stemming, tekst)\n      end\n      \n      def toon_timeline\n        puts \"Blurbalizer: #{@titel} heeft #{@blurbs.count} Blurbs\"\n        \n        @blurbs.sort_by { |t|\n          t.tijd\n        }.reverse.each { |t|\n          puts \"#{t.tekst.ljust(40)} #{t.tijd}\"\n        }\n      end\n    end\n    \n    mijnapp.toon_timeline","load_code":"prev"},
"56":{"lang":"NL","title":"Samenvatting 8, De Hee-Relax-Goed gedaan Samenvatting","chapter":"Y","answer":"","ok":"","error":"","text":"Dit laatste gedeelte was best inspannend. Je kunt nu even uitrusten.\nHopelijk heb je een goede indruk gekregen hoe je Ruby in het echt kunt\ngebruiken.\n\nAls programmeren je aanspreekt zou je verder kunnen gaan met onze eigen\n<a href=\"/playground\">TryRuby Playground</a>\nof je kunt Ruby downloaden en installeren via:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a>\n\nAls je Ruby hebt geïnstalleerd op je computer kan je een tekstbestand maken,\nbijvoorbeeld: _mijn\\_eerste\\_programma.rb_.\n\nMet een text editor zet je er wat Ruby code in.  \nJe voert het uit door een commando venster te openen en dit in te voeren:\n\n    ruby mijn_eerste_programma.rb\n\nEr zijn ook allerlei tools beschikbaar die een tekst editor bevatten en de Ruby\ncode meteen kunnen uitvoeren.\n\n## Meer informatie\nOp deze website zijn een aantal artikelen te vinden met achtergrond informatie\nover software ontwikkelen en wat je na deze cursus kunt doen. Zijn wel\nallemaal in het Engels.\n\n## Feestje\nGefeliciteerd, je hebt de hele cursus afgerond. Je hebt nu wel een feestmuts en\neen groot stuk taart verdiend !","load_code":"def ruby(f);puts \"Ga naar www.ruby-lang.org om Ruby te downloaden\";end;class K;attr_reader :rb;end;mijn_eerste_programma=K.new"}}