{"1":{"lang":"UA","title":"Є 30 хвилин? Дай Ruby шанс, і він тебе здивує!","chapter":"Y","answer":"","ok":"","error":"","text":"Ruby – це мова програмування з Японії, яка створила передумови для революції у веб-розробці.\n\nКраса Ruby в її балансі між простотою і можливостями.\n\nТи можеш ввести код на Ruby в редакторі і використовувати кнопки для навігації:\n\n- __Run__ &rarr; Виконати код, що знаходиться в редакторі\n- __Copy__ &rarr; Вставити/скопіювати приклад коду в редактор\n- __Next__ &rarr; Перейти до наступного уроку\n- __Back__ &rarr; Повернутися до попереднього уроку\n- __Clear__ &rarr; Очистити редактор\n\nВикористовуй кнопку 'world' button <span aria-hidden=\"true\" class=\"glyphicon glyphicon-globe\"></span>\nщоб змінити мову TryRuby.\n\n### Натисни __Next__ для початку навчання.","load_code":""},
"2":{"lang":"UA","title":"Використання редактора","chapter":"N","answer":"^\\d{1,}$","ok":"Чудово! Ти використовуєш математику. Бачив як з'явилася відповідь?","error":"Введи 2 + 6","text":"Набирай свій код на Ruby у вікні редактора знизу, потім натисни кнопку __Run__ і подивися як це працює!\n\nНаприклад, спробуймо порахувати простий вираз:\n\n    2 + 6\n\nРезультат програми повинен відображатися у вікні вгорі. На наступному рядку буде відображатися, наскільки добре ти впорався.\n\n> Також ти можеш натиснути кнопку __Copy__ щоб скопіювати код з прикладу в редактор.","load_code":""},
"3":{"lang":"UA","title":"Числа і математика","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Добре","error":"","text":"Ruby розуміє числа і математичні операції. Спробуй дещо інше, наприклад:\n\n    4 * 10\n    5 - 12\n    30 / 4","load_code":""},
"4":{"lang":"UA","title":"Виводимо результат інакше","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Чудово!","error":"","text":"Помітив, що коли ти набираєш більше одного виразу, виводиться результат тільки останнього.\nЩо ж відбувається?\n\n> Для більш зручного використання цього сайту, я наказав Ruby копіювати результат нашої програми в поле виведення вгорі.\n> Тож коли ти набираєш вираз, результат виводиться на екран.\n> __Але тільки останній результат.__ І тільки якщо досі нічого не відображалося.\n\nТож коли ти ввів кілька виразів, Ruby показав результат тільки останнього виразу.\n\nЗвичайно, Вам хочеться побачити результат всіх! Додай __puts__ перед кожним виразом (розділяючи пробілом).\nPuts означає: *'вивести щось на екран'*.\n\nСпробуй:\n\n    puts 4 * 10\n    puts 5 - 12\n    puts 30 / 4\n\nА тепер видали puts з останньої формули і подивись, що станеться.","load_code":""},
"5":{"lang":"UA","title":"Назви своє ім'я!","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Чудово, ти створив рядок з літер свого імені","error":"","text":"Звісно комп'ютери зручні для розрахунків. Але спробуймо щось іще. Хочеш вивести своє ім'я навпаки?\n\nДля початку набери своє ім'я в лапках як тут:\n\n\"Андрій\"","load_code":""},
"6":{"lang":"UA","title":"Скажи своє ім'я навпаки","chapter":"N","answer":"\\w+","ok":"оводуЧ","error":"","text":"Рядок є набором символів, які комп'ютер може обробляти. Уявіть, що букви, які знаходяться в рядку, – як білизна на мотузці, а лапки – прищіпки, які тримають кінці цієї мотузки. Лапки позначають початок і кінець.\n\nЩоб отримати ім'я задом наперед, набери:\n\n    \"Андрій\".reverse\n\n(І не забудь точку!)","load_code":""},
"7":{"lang":"UA","title":"Підрахунок літер","chapter":"N","answer":"^\\d+$","ok":"Так. Довжина рядка це також 'метод'","error":"","text":"Ти вже спробував __метод__ reverse на своєму імені! Уклавши ім'я в лапки, ти створив рядок. Потім ти викликав метод reverse, який працює з рядками і розгортає їх задом наперед.\n\nА тепер погляньмо, скільки літер у твоєму імені:\n\n    \"Андрій\".length","load_code":""},
"8":{"lang":"UA","title":"На повторі","chapter":"N","answer":"(\\w+)","ok":"Приємно познайомитись! Приємно познайомитись! Приємно познайомитись!","error":"","text":"Зараз тобі напевно цікаво, навіщо все це потрібно.\n\nЩо ж, я впевнений, ти хоч раз помічав на сайті напис: __Ваш пароль занадто короткий!__\n\nДиви, деякі програми використовують простий код __.length__.\n\nПоглянь ще. Помнож своє ім'я на 5.\n\n    \"Андрій\" * 5","load_code":""},
"9":{"lang":"UA","title":"Підсумки #1 Вже","chapter":"Y","answer":"NoMethodError|undefined","ok":"Ні, неможливо розгорнути число. Натисни 'next'","error":"","text":"Погляньмо, що ти вже вивчив за першу хвилину.\n\n### Редактор коду\nМожна набирати код в редакторі і отримувати відповідь у вікні виводу.\n(Майже) всі програми видають відповідь.\n\n### Числа і рядки\nЧисла і рядки це математичні та текстові об'єкти Ruby.\n\n### Методи\nТи спробував методи зі слів англійською мовою reverse і length.\nА також символьний метод множення: \\* __Метод означає дію!__\n\nВ цьому суть твого навчання. Беремо базові речі, граємося ними і перетворюємо їх на щось нове.\nПочуваєшся комфортно? Сподіваюсь що так!\n\n###Добре\nСпробуймо дещо незвичайне. Спробуй розгорнути число в інший бік:\n\n    40.reverse","load_code":""},
"10":{"lang":"UA","title":"Зупинись, ти здурів!)","chapter":"N","answer":"^\\d{1,}$","ok":"Розгорнути можна тільки рядки","error":"","text":"Не можна розгорнути число задом наперед. Ти, звісно, можеш тримати монітор перед дзеркалом, але розгортання числа просто не має сенсу.\n\nRuby виведе повідомлення з помилкою. Ruby каже тобі, що не існує методу reverse для чисел.\n\nХіба може спробувати перетворити число 40 на рядок для початку:\n\n    40.to_s.reverse","load_code":""},
"11":{"lang":"UA","title":"Яблука відрізняються від апельсинів","chapter":"N","answer":"\\[\\]","ok":"Добре, це пустий список.","error":"","text":"А числа відрізняються від рядків.\n\nУ той час як використання методів може бути застосовано до всіх об'єктів Ruby, деякі методи працюють тільки з певними типами даних.\nАле ти можеш перетворити один тип на інший, використовуючи методи типу \"to\"\n\n- __to_s__ перетворює на рядки\n- __to_i__ перетворює на число\n- __to_a__ перетворює на масив\n\n__Що таке масив?!__\n\nМасив – це просто список. Набери 2 квадратні дужки:\n\n    []","load_code":""},
"12":{"lang":"UA","title":"Черга по квитки","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Чудесно","error":"Спробуй додати четверте число до списку","text":"Списки (масиви) зберігають елементи __в певній послідовності__.\n\nСхоже на чергу по квитки. Ти стоїш за кимось і навіть не мрієш його відштовхнути або пересунути, чи не так? Також хлопчина за тобою, ти пильно слідкуєш за кожним його рухом.\n\nОсь ще список. Номери лотерейних квитків:\n\n    [12, 47, 35]\n\nСпробуй додати число до масиву. Набери кому і число після 35. Пробіл не обов'язковий.","load_code":""},
"13":{"lang":"UA","title":"Перший піднімає руку","chapter":"N","answer":"^47$","ok":"Ok","error":"","text":"Список номерів лотерейних квитків. А який номер максимальний?\n\nСпробуй:\n\n    [12, 47, 35].max","load_code":""},
"14":{"lang":"UA","title":"Сховаємо список","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Заховано!","error":"","text":"Добре. Але ж незручно набирати список кожного разу, коли він потрібен, так?\n\nЗбережімо наші номери лотереї таким чином:\n\n    ticket = [12, 47, 35]","load_code":""},
"15":{"lang":"UA","title":"Тепер введи ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Видобуто!","error":"","text":"А зараз набери:\n\n    ticket","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"UA","title":"Збережено й заховано","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Ти відсортував список","error":"","text":"Ти поклав список номерів в __змінну__ з назвою ticket.\nАле будь-яке інше ім'я, як __andriilist__, теж згодиться.\n\nЗаймаючись програмуванням, ти помітиш, що це, переважно, робота зі змінними.\n\nВпорядкуймо список лотерейних квитків?\n\nВикористай:\n\n    ticket.sort!\n\nТи мав простий список. Ти його відсортував. Змінна ticket теж змінилася.\nТи помітив, що у методу __sort!__ на кінці стоїть великий знак оклику?\nТак Ruby повідомляє нам, що змінна ticket буде змінена не лише в цьому виразі, а й, також, в пам'яті.\nНічого надзвичайного, просто запам'ятай!","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"UA","title":"Елементи","chapter":"N","answer":"^(12|35|47)$","ok":"Ok","error":"Майже","text":"Ми зберегли числа в змінну, а як їх отримати назад?\n\nМи вже бачили, як ми можемо отримати максимальний елемент, використовуючи метод __max__.\nТакож ти можеш отримати __first__ (перший) або __last__ (останній) елемент списку.\nА що коли ти хочеш отримати якийсь конкретний елемент?\n\n### [ ]\nRuby використовує [], щоб націлитися на елемент.\nКвадратні дужки дуже поширені в Ruby.\nВони означають: \"Я шукаю ____\", Готовий, цілься!\n\nОтримай всі номери зі списку:\n\n    puts ticket [0]\n    puts ticket [1]\n    puts ticket [2]\n\nЧому ми використовуємо [0], [1], [2]?\n\nА не [1], [2] чи [3]? Це якийсь японський дзен? Ні, в багатьох мовах програмування відлік йде з нуля. Це не тільки особливість Ruby.\n\n>Невелике нагадування: ти можеш використовувати кнопку __Copy__.","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"UA","title":"Підсумки #2 Що тут у нас?","chapter":"Y","answer":"\\w+","ok":"Чи є хоч якась рима?)","error":"","text":"Зараз поглянемо, як минула твоя друга хвилина:\n\n### Помилки\nЯкщо ти спробуєш розгорнути число чи якусь іншу дурницю, Ruby скаже тобі про це.\n\n### Масиви\nМасиви – це списки, що зберігають елементи в певній послідовності.\nМи вже знаємо, як створити масив і отримати елементи з нього.\n\n### Змінні\nЗмінні зберігають значення і дають їм імена. Ми використали знак рівності щоб зробити це.\nЯк тут: ticket = [14, 37, 18].\n\n### 2/8\nВсього тут 8 розділів. 2 вже позаду! Не дуже й складно, так?\n\nЗмінімо напрямок. Я люблю поезію і поклав трохи в змінну poem, тож поглянь. Набери:\n\n    puts poem","load_code":"poem = \"Моя канапка випала у мене з рук. \\nІ моя канапка полетіла на Місяць. \\nТа коли я побачив її в телевізорі, \\nРазом з прапором України на кометі Галлея, \\nТоді я найбільше хотів її з'їсти\\n\""},
"19":{"lang":"UA","title":"На жаль, тобі не подобається така поезія","chapter":"N","answer":"(toast){0}","ok":"Чудово","error":"Все одно канапка","text":"Все гаразд. Всі ми різні. Редагуй цей шматочок як хочеш. Замість канапки може бути грушка або що завгодно.\nСпробуй це, щоб побачити новий варіант поеми:\n\n   poem.gsub(\"канапка\", \"грушка\")\n   \nМетод __gsub__ це скорочення global substitute (замінник). Він замінить всі збіги \"канапка\" на \"грушка\".","load_code":"prev"},
"20":{"lang":"UA","title":"Готовий, цілься!","chapter":"N","answer":"^\\nитсї'з її вітох (.+)","ok":"Звісно, увесь віршик розвернутий задом наперед","error":"","text":"Питання для тебе: що станеться?\n\n    poem.reverse","load_code":"prev"},
"21":{"lang":"UA","title":"Занадто багато слів навпаки","chapter":"N","answer":"^\\[\"Тоді я найбільше (.+)","ok":"Так, майже те що треба","error":"","text":"Що ж, вся наша поема стала задом наперед, слово за словом! Але ж я всього лише хотів зробити це для рядків.\nПеремісти перший рядок на кінець, а останній на початок. Тобто навпаки, але не так.\n\nОсь як:\n\n    poem.lines.reverse","load_code":"prev"},
"22":{"lang":"UA","title":"Ще трохи методів в ланцюжок","chapter":"N","answer":"^Тоді я найбільше (.+)","ok":"Прекрасно, друже!<br/>Метод join взяв масив рядків і з'єднав їх в один рядок'.","error":"","text":"Що ти бачиш тут? Що сталося? Ти набрав __poem.lines.reverse__ і що сталося?\n\nДві речі. Перше: ти розбив віршик на рядки, за допомогою методу lines, і отримав масив з них.\n\nПотім ти розгорнув цей список задом наперед і розгорнув кожен рядок. От і все!\n\nДодамо ще один метод в кінець:\n\n    puts poem.lines.reverse.join\n\nКомбінування методів таким чином називається __ланцюжком методів__.","load_code":"prev"},
"23":{"lang":"UA","title":"Підсумки #3 Тут і зараз","chapter":"Y","answer":"\\{\\}","ok":"Ти створив порожній словник!","error":"","text":"### Знак оклику\nМетоди можуть мати знак оклику (як і знак питання) в своєму імені.\nВони тут для більш зрозумілого пояснення, що вони роблять. Нічого страшного.\n\n### Маніпуляції з рядками\nПошук і зміна рядків\n\n### Ланцюжки\nЛанцюжки методів дозволяють зробити набагато більше. Розбити віршик, розгорнути його, об'єднати в рядок:\n__poem.lines.reverse.join__\n\nНа цьому етапі, ти можеш подивитися всі методи для рядків тут <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">here</a>.\n\nСпробуй декілька з них: poem.downcase або poem.swapcase\n\n## Готовий?\nКоли ви будеш готовий рухатися далі, набери:\n\nbooks = {}","load_code":"prev"},
"24":{"lang":"UA","title":"Порожній словник","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Yes that's a new review","error":"Use one of splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>Don't forget the colon","text":"Ми створили порожній __словник (hash)__. Словник – це як масив, тільки у кожного елемента є ім'я.\n\n>Примітка перекладача: в україномовному співтоваристві слово hash перекладається як словник. Якщо Array перекладають як масив, то Hash – словник, інколи просто >хеш. Назва hash походить від hash-функції, на основі якої працює словник, і яка дозволяє дуже швидко знаходити елемент за ключем (ім'ям). Але щоб використовувати словники, нам це знати не обов'язково.\n\nМи збираємося записати кілька мініатюрних відгуків в наш новий словник. Ось наша рейтингова система:\n\n- :splendid &rarr; витвір мистецтва\n- :quite\\_good &rarr; так, сподобалося\n- :mediocre &rarr; посередньо\n- :quite\\_not\\_good &rarr; загалом погано\n- :abysmal &rarr; жах\n\nЩоб оцінити книгу, додай назву в квадратних дужках і постав оцінку після знака дорівнює. Наприклад:\n\n    books[\"Фарбований Лис\"] = :splendid\n\n> Зараз, я вважаю за необхідне сказати, що всі уроки в TryRuby відокремлені один від одного.\n>Тож якщо ти вирішив пофестивалити і зробити дуже багато відгуків, то використовувати їх ти зможеш тільки в цьому уроці.\n>Якщо ж хочеш використати свої відгуки і в наступному уроці, то ти повинен скопіювати їх і вставити.\n>Не турбуйся про це, в кожному уроці є багато запрограмованих речей для тебе щоб гратися.","load_code":"books = {}"},
"25":{"lang":"UA","title":"Ще кілька простих відгуків","chapter":"N","answer":"[3-9]","ok":"Бачиш, метод length працює з рядками, списками і словниками.","error":"","text":"Продовжуй, заповни хеш відгуками. А якщо хочеш побачити весь список, просто набери: puts books\n\nЗнову ж, можливі оцінки: :splendid, :quite_good, :mediocre, :quite_not_good і :abysmal.\n\nЦі оцінки не є рядками. Коли ти ставиш двокрапку перед простим словом, ти отримуєш __символ (Symbol)__. Символ є дешевшим за рядок (з точки зору комп'ютерної пам'яті). Тож якщо використовуєш слово знову і знову в своїй програмі, використовуй символ. Замість того, щоб мати тисячі копій цього слова в пам'яті, Ruby буде зберігати символ тільки __один раз__.\n\nЩо важливіше, символ каже нам, що це не просто якесь слово, а таке, що має значення у нашій програмі.\n\n>Примітка перекладача: в англійській мові є два слова: Symbol і Char, і обидва перекладаються українською як \"символ\".\n>В контексті Ruby Symbol правильно було б перекласти як \"ідентифікатор\", але використовують слово символ.\n>Тому якщо в контексті Ruby ти почуєш \"символ\", то швидше за все це Symbol, ідентифікатор, який записується як :good, і є оптимізованим для пам'яті рядком.\n\nВведи ще 2 відгуки, використовуй books.length, щоб дізнатися, скільки відгуків в словнику:\n\n    books[\"Сутінки. Сага.\"] = :abysmal\n    books[\"Фарбований Лис\"] = :mediocre\n\n    puts books\n\n    puts books.length","load_code":"books = {\"Фарбований лис\" => :splendid}"},
"26":{"lang":"UA","title":"Стоп, невже я засудив Фарбованого Лиса?)","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Мені сподобалося","error":"","text":"Однією з чудесних особливостей Ruby є те, що імена часто використовуються повторно, тож менша кількість імен, які тобі треба запам'ятати.\n\nРаніше ми витягли елементи з масиву за допомогою числа:\n__puts ticket[1]__.\n\nДля словника це працює однаково, але ми використовуємо не число, щоб отримати елемент, а ім'я (ключ).\n\nОтже, якщо хочеш подивитися один зі своїх старих відгуків, знову введи назву в квадратних дужках. Але не пиши знак дорівнює. Ось так:\n\n    puts books[\"Фарбований лис\"]","load_code":"books = {\"Фарбований Лис\" => :splendid, \"Сутінки. Сага.\" => :abysmal, \"Хоббіт\" => :mediocre}"},
"27":{"lang":"UA","title":"Словники це пари","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Ти знайшов ключі","error":"","text":"Пам'ятай, що словники не зберігають елементи в послідовності. Це не їхнє завдання.\nВони створюють пару з двох елементів: __ключ (key)__ і __значення (value)__\n\nУ твоїх відгуках, назва книги це ключ, а оцінка – значення.\n\nЯкщо ж хочеш побачити всі назви книг які ти оцінив, введи:\n\n    books.keys\n\nТакож спробуй використати .values замість .keys.","load_code":"prev"},
"28":{"lang":"UA","title":"Ти суворий критик?","chapter":"N","answer":"\"mediocre\"","ok":"Ти створив свій власний рейтинг книжок","error":"","text":"Ти пишеш суворі, несправедливі відгуки? Порахуємо їх в новому словнику __ratings__:\n\nТепер ми можемо їх порахувати. Набери:Then, okay, now let's count up your reviews. Just stay with me. Type:\n\n    ratings = Hash.new {0}\n\n    books.values.each { |rate|\n      ratings[rate] += 1\n    }\n\n    puts ratings\n\nПрямою лінією в коді є символ pipe, ймовірно, розташований зверху клавіші Enter на твоїй клавіатурі.\n\nЦей рядок += 1 означає: збільшити значення на одиницю.\n\nНе турбуйся, якщо не розумієш всього, що тут відбувається. Все буде ясно пізніше.","load_code":"books = {\"Фарбований Лис\" => :splendid, \"Сутінки. Сага.\" => :abysmal, \"Хоббіт\" => :mediocre, \"Голодні ігри\" => :mediocre}"},
"29":{"lang":"UA","title":"Підрахунок","chapter":"N","answer":"\\w+","ok":"Будьмо!","error":"","text":"Одна з приголомшливих речей, яку ми щойно використали це __блок (block)__.\nМи вивчимо їх докладніше на цьому й наступному уроці. Та загалом блок – це трохи коду на Ruby, оточеного фігурними дужками.\n\nСпробуй створити інший блок:\n\n    5.times{ print \"Будьмо!\" }\n\nБлоки завжди прив'язані до методів. Як метод __times__, який бере блок і запускає код знову і знову. (В нашому прикладі: п'ять разів.)","load_code":""},
"30":{"lang":"UA","title":"Є хвилинка?","chapter":"N","answer":"^[0-9]$","ok":"Дуже вчасно!","error":"Виконай від 0 до 9","text":"Як ми бачили в першому прикладі з блоком (при підрахунку оцінок), ми можемо передати змінну блокові.\nЗначення, яке __вставляється__ визначається методом, який запускає блок.\n\nЗмінні, які __приймає__ блок, поміщаються в ім'я змінної на початку блоку, між двома символами pipe: |\n\nСпробуймо це за допомогою цього блоку:\n\n5.times {|time|\n     puts time\n}\n\nТут метод __.times__ посилає значення змінній __|time|__. Але майте на увазі, що ця змінна відома тільки всередині блоку.\n\n> Ти помітив, що можеш розділити код на декілька рядків? Так їх потім простіше читати.","load_code":""},
"31":{"lang":"UA","title":"Підводячи підсумки #4","chapter":"Y","answer":"","ok":"","error":"","text":"Цей урок був дещо довшим і ти, ймовірно, витратив на три хвилини більше на його вивчення:\n\n### Словники\nНайпростіший приклад словника: __{}__\n\n\n### Символи\nКрихітні але ефективні кодові слова з двокрапкою, наприклад: __:splendid__\n\n### Блоки\nШматочки коду, які можна прив'язати до багатьох методів Ruby.\nОсь код, який ми використовували щоб створити таблицю оцінок:  \n__books.values.each { |rate| ratings[rate] += 1 }__\n\n### Далі\nНа наступних уроках ми ще глибше зануримося в методи.","load_code":""},
"32":{"lang":"UA","title":"Бути чи не бути","chapter":"N","answer":"","ok":"","error":"","text":"Одна маленька деталь, яку ми не обговорили – це аргументи методів.\nПам'ятаєш, як ми змінили вміст поеми, використовуючи цей метод:\n__poem.gsub(\"канапка\", \"грушка\")__\n\nМетод gsub вимагає два аргументи, які ми передали як рядки в круглих дужках.\n__Аргументи кажуть методові, що саме йому робити.__\n\n### Круглі дужки\nНасправді, в більшості випадків Ruby не проти, якщо ти пропустиш дужки. Таким чином, це теж спрацює:\n__poem.gsub \"канапка\", \"грушка\"__\n\nМи також вже використовували й інший метод з параметром. Багато разів. Але це не так очевидно:\n\n    puts \"Hello\"\n    puts(\"Hello\")\n\nТак, __puts__ це теж метод. Хочеш писати puts з круглими дужками або без – для Ruby байдуже,\nале варіант без дужок простіше читати і трохи економить час набору коду!\n\n> Висновок полягає в тому, що ти можеш робити все, що завгодно з круглими дужками, поки код читається красиво.\n\n### Тож бути чи не (бути)?\n\nХочеш ще трохи Шекспіра? Читай далі.","load_code":"poem = \"Моя канапка випала у мене з рук. \\nІ моя канапка полетіла на Місяць. \\nБла, бла, бла\\n\""},
"33":{"lang":"UA","title":"Приборкання норовливої","chapter":"N","answer":"^tame","ok":"Добре добре!","error":"","text":"Ти вже знаєш, як використовувати Ruby. Я маю на увазі, ти вже збагнув основи.\nДалі тобі потрібно вивчити більше методів і спробувати більш складні блоки.\nАле ми ще дещо не обговорили. Створення власних методів. Займімося цим.\n\nУ той час, як Ruby має вбудовані методи (такі, як puts, sort, times),\nти вже можеш писати свої власні методи. Навіщо? На це є дві причини:\n\n### Зробити свою програму коротшою\nЯкщо ти використовуєш один і той же код більш ніж в одному місці, тобі буде набагато простіше,\nякщо виділити його в новий метод. Це зробить код коротшим.\n\n### Зробити свій код кращим для читання\nПрипустімо, що твоя програма повинна робити багато різних речей.\nТи __можеш__ записати весь код в один довгий текст. Але було б дуже складно прочитати і зрозуміти цей код пізніше.\n\nЗамість цього ти маєш розбити свій код на методи і дати кожному з них зрозуміле ім'я. Подякуєш собі пізніше.\n\nОтже, як ми визначаємо метод? Ось так:\n\n    def tame( number_of_shrews )\n    end","load_code":""},
"34":{"lang":"UA","title":"В Ruby, Def Leppard означає: визначити метод Leppard","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"В Ruby, Def Leppard означає: визначити метод Leppard\nДобре, ти це зробив. Ти створив свій власний метод. Почав з def, за яким іде ім'я методу. І список аргументів, які будуть потрібні методові. Це не дуже страшно і небезпечно! Все, що нам потрібно зробити, це заповнити його кодом на Ruby і закінчити з end.\n\nОсь код:\n\n    def tame( number_of_shrews )\n      number_of_shrews.times {\n        puts \"Tamed a shrew\"\n      }\n    end\n\n> __P.S.__  \n> Якщо ти не знаєш цю назву, Def Leppard це відома Британська рок-група <a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>","load_code":""},
"35":{"lang":"UA","title":"Достиглий плід твоєї праці","chapter":"N","answer":"^Приборкав норовливу","ok":"Так їм!","error":"","text":"Новий метод народжено. Спробуємо його використати:\n\n    tame 5","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"UA","title":"Давай і бери","chapter":"N","answer":"\\d+","ok":"Так","error":"","text":"Більшість методів не тільки вимагають введення деяких параметрів, але й __повернуть щось назад__.\nЯ трохи змінив наш метод, щоб він повернув нам значення. Спробуй:\n\n    def tame( number_of_shrews )\n      number_of_shrews.times {\n        puts \"Tamed a shrew\"\n      }\n      return number_of_shrews\n    end\n\n    puts tame(3)\n\n### Результат\nА оскільки ти вже настільки просунутий і компетентний, ще одна порада: можеш опустити слово __return__ з останнього рядка методу.\nRuby автоматично поверне останнє значення, яке використовувалося в методі.\n\nТак ми можемо змінити останній рядок просто на: __number\\_of\\_shrews__.\n\nАле оскільки метод __.times__ також повертає _number\\_of\\_shrews_ ми можемо стерти останній рядок цілком.\nТак що наш новий метод робить те, що ми від нього хотіли!","load_code":""},
"37":{"lang":"UA","title":"Привіт, хто тут? Підсумки #5 вітають тебе!","chapter":"Y","answer":"","ok":"","error":"","text":"Відмінно, відмінно, відмінно!\nСупер, супер, сууууупер!\n\nОсь що ми ще дізналися:\n\n### Методи\nМетоди можуть бути визначені за допомогою __def__ та мають ім'я.\nМетоди роблять нашу програму коротшою і простішою для читання.\n\n### Параметри\nМетоди можуть мати параметри.\n\n### Значення, що повертаються\nМетоди (майже) завжди повертають якесь значення.\n\n## А зараз\nБути чи не (бути) не є для тебе більше великим питанням. Ти готовий почитати ще трохи Шекспіра?","load_code":""},
"38":{"lang":"UA","title":"Світ – наша мушля","chapter":"N","answer":"^\\{\\\"William","ok":"Добре. Але важко читати.","error":"","text":"Досі ти запускав програми, які використовують тільки те, що ти набирав сам. Це класно, але зараз епоха інтернету, а значить можна використовувати ці дані.\n\nБагато, багато веб-сайтів в мережі, а значить у всіх них можна запросити інформацію. Наприклад: ця посилання дасть вам всі останні <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Новини з Гугла</a> по тематиці Ruby.\n\nВаш бравзер, можливо, відобразить це красиво. Але якщо поглянеш на сирцевий код (натисни: ctrl-U), то побачиш складний текст в форматі __rss__.\n\n### Формати\nВсього існує дуже багато форматів зі складними назвами в мережі, такі як: html, xml та json. Ага, навіть цей веб-сайт використовує декілька.\n\nЯ підготував для тебе метод, який вибере список повних робіт Вільяма Шекспіра ​​з Інтернету. (Не хвилюйся, насправді все це скачується з того ж сервера, на якому розміщений мій сайт, тому ми нікого не турбуємо.)\n\nОтримай дані за допомогою:\n\n    get_shakey","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"UA","title":"Шляхетні родичі","chapter":"N","answer":"^Два шляхетні родичі$","ok":"Так значно краще","error":"","text":"Отже, тепер у нас є список п'єс з Інтернету. Список був в форматі json. На щастя для нас Ruby люб'язно надає метод перетворення даних json на словник Ruby. Метод _get\\_shakey_ зробив це за нас.\n\nАле оскільки структура json-даних зберігається в словнику, її трохи важко читати. Тож ми напишемо метод для показу п'єс.\n\nЯкщо ти уважно вивчиш список п'єс, то побачиш, що він має наче гніздову структуру.\n(Це досить поширено в даних, які ти отримуєш з Інтернету.) Виглядає це так:\n\n<ul>\n  <li>\"William Shakespeare\"\n  <ul>\n      <li>\"1\"\n      <ul>\n        <li>\"title\": \"The Two Gentlemen of Verona\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>\"2\"\n      <ul>\n        <li>\"title\": \"The Taming of the Shrew\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>...</li>\n  </ul>\n  </li>\n</ul>\n\nЩоб перерахувати п'єси, нам спочатку потрібно отримати доступ до верхнього елементу словника \"Вільям Шекспір\" по його назві.\nПотім ми повинні __iterate (\"крокувати\")__ по кожному елементу за ним.\n\nRuby має метод для ітерації. Він називається __each__. Ми бачили це раніше, коли створювали нашу систему рейтингу книжок.\n\nВсе, що повертає метод __each__, передається блокові:\n\n    s = get_shakey\n\n    s[\"William Shakespeare\"].each { |key, val|\n      puts val[\"title\"]\n    }","load_code":"prev"},
"40":{"lang":"UA","title":"Всі разом","chapter":"N","answer":"^4$","ok":"Так, Шекспір написав 4 п'єси' в 1591","error":"Відповідь для року 1591 має бути 4","text":"Тепер припустімо, що ми хочемо знати імена і кількість п'єс, написаних Шекспіром протягом певного року.\n\nRuby дозволяє нам __виводити__ значення зі словника.\nМетод select використовує блок, який дозволяє нам визначити, що вибрати і повернути знайдене.\n\nПотім ми можемо використовувати результати, які повертаються через __select__ в методі __each__, як і раніше, просто додаючи його після блоку select. Це ще один приклад ланцюжка методів, який ми бачили раніше, коли розгортали віршик задом наперед.\n\nЯ підготував для тебе метод __count\\_plays__. Побачимо, чи зможеш ти порахувати кількість п'єс, написаних Шекспіром в __1591__:\n\n    def count_plays(year)\n      s = get_shakey\n\n      s[\"William Shakespeare\"]\n        .select { |k, v|\n          v[\"finished\"] == year\n        }.each { |key, val|\n          puts val[\"title\"]\n        }.count\n    end\n\n    puts count_plays(0)\n\n    Ти помітив, що я додав метод count в самому кінці кожного методу. Так ми отримаємо значення, що повертається методу __count\\_plays__.\n\n    Є й інший спосіб вибудовування ланцюжка. Бачиш самотній рядок __s = get_shakey__.\n    Ти можеш додати __[\"William Shakespeare\"].select{ |k, v|__ в кінець get_shakey (але не обов'язково тут).","load_code":"prev"},
"41":{"lang":"UA","title":"Все добре, що добре закінчується","chapter":"N","answer":"Все добре, що добре закінчується","ok":"True","error":"Використовуй 1605 як другий параметр","text":"Добре, ми отримали деякі дані з Інтернету, ми вибрали те, що хотіли, і роздрукували це.\nЩо ще поліпшити? Ми могли б надрукувати результати трохи гарніше. Як додати рік і вирівняти назви і роки.\n\nЦе означає потрібно друк декількох значень на одному рядку. Ruby має зручний спосіб зробити це.\nЦе схоже на друк рядка типу: __puts \"Привіт, мене звуть Андрій\"__. Але замість літерного значення __Андрій__ ми використовуємо значення змінної.\n\nСпочатку заміни __Андрій__ на __#{}__. Якщо Ruby бачить символ #, а за ним символ {то шукає змінні між цими дужками}.\nТож ми можемо використати: __\"Привіт, мене звуть #{name}\"__.\n\nЗмінимо наш код трохи:\n\n    def print_plays(year_from, year_to)\n      get_shakey[\"William Shakespeare\"]\n        .select { |k, v|\n          year_from <= v[\"finished\"] &&\n          year_to   >= v[\"finished\"]\n        }.each { |k, v|\n          puts \"#{v[\"title\"].ljust(30)} #{v[\"finished\"]}\"\n        }\n    end\n    print_plays(1600, 1605)\n\nЯ додав __.ljust(30)__ до заголовку. В такому випадку заголовок має відступ мінімум 30 символів. Так рік виглядає охайніше :)\n\nПодивися, чи зміниться вихід програми так, щоб вона показувала такі п'єси: __1600 -> As You Like It__\n\n__Все добре, що добре занчується?__ Гей, ми ще не закінчили, але кінець вже близько!","load_code":"prev"},
"42":{"lang":"UA","title":"Якби я знав, як прийняти рішення","chapter":"N","answer":"","ok":"","error":"","text":"Робити вибір в житті буває важко, але не в Ruby.\nТут є зручні способи приймати рішення.\n\n    if 1 < 2\n      puts \"Це правда: 1 менше 2\"\n    end\n\nКлючове слово __if (якщо)__. If можна ставити і до, і після методу, як тут:\n\n    puts \"Це правда: 1 менше 2\" if 1 < 2\n\n__If__ це метод, який вимагає 1 параметра. Цим параметром може бути будь-який вираз, який ти хочеш перевірити.\nРезультат виразу може бути __true (правда)__ або __false (брехня)__. Ось кілька прикладів:\n\n    5     <= 10     # => true\n    'abc' == 'def'  # => false\n    true            # => true\n    123456          # => true\n    0               # => true\n    nil             # => false\n    'xyz'.empty?    # => false\n    'a' > 5         # => error:\n                    # comparison of String with\n                    # Numeric failed\n\nВираз if може мати багато видів: порівнювати значення (1 < 2), змінні (a < 1) і повертатися значення методів ('xyz'.empty?).","load_code":""},
"43":{"lang":"UA","title":"І на останок","chapter":"N","answer":"не дорівнює 100$","ok":"Це краще","error":"Так не може бути","text":"Бачиш подвійне дорівнює __'abc' == 'def'__?\n\nЦе __==__ означає __перевірка на рівність__. Одиночне дорівнює використовується для __надання значення змінній__.\n\nЩоб трохи тебе заплутати: можеш використати присвоювання як аргумент методу if:\n\n    a = 0\n\n    if a = 100\n      puts \"Вираз вірний, але а зараз дорівнює: #{a}\"\n    else\n      puts \"#{a} не дорівнює 100\"\n    end\n\nПоміняй = на == і подивися, що станеться.\n\nЯ гарантую, що ти будеш часто забувати поставити подвійне дорівнює, я теж забуваю інколи.\n\n### Інакше (else)\nУ коді я використав else, що виконується у разі якщо __if тестовий_вираз__ обчислюється як брехня (false).\n\n> Більше інформації ти можеш отримати <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">тут.</a>","load_code":""},
"44":{"lang":"UA","title":"Я голодний","chapter":"N","answer":"^Я не голодний","ok":"Так","error":"Я не голодний о 10 ранку!","text":"Це прекрасно, це прості речі, але пам'ятай, що ти __не знав Ruby__ всього 15 хвилин тому!\n\nТож тепер об'єднаємо всі наші отримані навички: визначимо 2 методи:\n\n    def hungry?(time_of_day_in_hours)\n      puts \"Я голодний\"\n      true\n    end\n\n    def eat_an(what)\n      puts \"Я їм #{what}\\n\"\n    end\n\n    eat_an 'яблуко' if hungry?(14)\n\n    eat_an 'яблуко' if hungry?(10)\n\n    Спробуй змінити метод __hungry?__ так, щоб він друкував __\"Я не голодний\"__ і повертав false коли час буде менше 12-ї.","load_code":""},
"45":{"lang":"UA","title":"Підсумки #6 Ми пройшли довгий шлях","chapter":"Y","answer":"\\{\\}","ok":"Це порожній словник","error":"","text":"Ти 6-го рівня Ruby клірик. Тобто відмінна робота! Підіб'ємо підсумки:\n\n\n### Дані\nТи завантажив трохи даних з інтернету, пройшовся по них і вибрав значення.\n\n### Iterating (крокування)\nТи пройшов по всіх елементах словника, а також створив ланцюжок методів.\n\n### Гарний друк\nІ якщо цього недостатньо, то ти форматував і вивів кілька даних щоб їх було зручно прочитати людям.\n__Ти зробив справжню програму!__\n\n### Якщо (If)\nТи навчився використовувати оператори розгалуження __if__ та __else__\n\n## Тож\nЩо може бути далі? Що ти, можливо, повинен дізнатися зараз? Ха, це найкраща частина.\nТи пройшов довгий шлях, тож пора вивчити класи. Ще два коротких уроки, і все готово.\n\nРаніше ми створювали словник так:\n\n    Hash.new","load_code":""},
"46":{"lang":"UA","title":"Не шкільний клас, а робітничий","chapter":"N","answer":"","ok":"","error":"","text":"Як бачиш порожні фігурні дужки {} це скорочення для Hash.new. Метод new використовується, щоб створювати об'єкти певного класу. Сприймай \"class\" в сенсі \"робітничий клас\" &mdash; якась особлива група, що робить одну роботу і в однакових футболках.\nДля чого використовуються класи?\n\n\n### Blurbalizer<sup>TM</sup>\nТи маєш чудову ідею для нової програми. Це буде чергова платформа для обміну повідомленнями. Ти хочеш додаток, де люди будуть обмінюватися короткими повідомленнями. Ти називаєш ці повідомлення Blurbs<sup>TM</sup>. Blurb<sup>TM</sup> має максимальну довжину 40 символів. До роботи.\n\n### Де почати?\nТи можеш зберегти записи Blurbs<sup>TM</sup> в json-файлі, так?\nАле як би ти відстежував зміст запису і час публікації? І коли ти завантажиш файл, як він буде виглядати в Ruby?\nЦе буде словник? Або масив? Або масив масивів? Або щось інше?\n\n### Клас\nЯ впевнений, що ти хотів би використати клас. Ти вже знаєш деякі з них: словник (Hash), масив (Array), рядок (String).\n\nСтворімо новий клас (нічого не повертаючи):\n\n    class Blurb\n    end","load_code":""},
"47":{"lang":"UA","title":"Те з чого робляться додатки","chapter":"N","answer":"","ok":"","error":"","text":"Ми відкрили новий Blurb<sup>TM</sup> class. клас. Чим наповнений ваш блог?\nТак, змістом! Також часом, коли Blurb<sup>TM</sup> був опублікований. І настроєм.\n\nДобре, тож у нас є перший рядок класу, ось решта:\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n    end\n\nІмена класів завжди починаються з великої літери (і знову ж, нічого не повертається).","load_code":""},
"48":{"lang":"UA","title":"Аксесори це кінцівки","chapter":"N","answer":"Blurb:","ok":"Мій перший Blurb","error":"","text":"Чудово. У тебе є новий Blurb<sup>TM</sup> клас.\n\nУ визначенні класу ти використав метод, який називається attr\\_accessor (аксесор).\nВзагалі є багато атрибутів класу, які так чи інакше його змінюють. Атрибути – це всього лише змінні пов'язані з класом.\n\nДумайте так. Клас – це людина. Це людська істота у формі зірки.\nА атрибути – це її кінцівки, різні частини збираються в тіло, а інші люди можуть взяти цю людину за руку і привітатися.\n\n### Зараз\nЩоб створити Blurb<sup>TM</sup> і наповнити даними напиши:\n\n    blurb1 = Blurb.new\n    puts blurb1\n    blurb1.content = \"Today Mount Hood Was Stolen!\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"UA","title":"Об'єкт, цей акуратний маленький пакет","chapter":"N","answer":"Blurb:","ok":"Blurb оновлено","error":"","text":"А тепер змінимо атрибути нашого Blurb<sup>TM</sup>:\n\n    blurb1.time = Time.now\n    blurb1.mood = :sick\n\n    puts blurb1","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"UA","title":"Прискорюємося","chapter":"N","answer":"^\\d{4}","ok":"Відмічено","error":"","text":"Круто, новий додаток просто блискучий. А як щодо спростити?\nТи не захочеш ставити час свого Blurb<sup>TM</sup> кожного разу коли постиш, чи не так?\n\nТи просто хочеш записати свої контент і настрій?\n\nДодамо метод ініціалізації __initialize__ в наш клас.\nЦей метод буде завжди викликатися, коли ти створюєш новий Blurb<sup>TM</sup>.\nТакож ми можемо встановити максимальну довжину Blurb<sup>TM</sup> контенту в 40 символів.\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n\n      def initialize(mood, content=\"\")\n        @time    = Time.now\n        @content = content[0..39]\n        @mood    = mood\n      end\n    end\n\n    Blurb.new.time\n\n(Цей параметр __content=\"\"__ використовується, щоб нам було відомо, що контент це рядок і ніякий інший параметр не може ініціювати його.)","load_code":""},
"51":{"lang":"UA","title":"Ти навчив свій додаток відкидати непотрібні речі","chapter":"N","answer":"Blurb:","ok":"Blurb додано","error":"","text":"Ти помітив, як ми використовуємо символ собачки \"всередині класу\"? (@time).\n\n__Ззовні__ класу ми використовуємо аксесор:\n\n> __blurb.time = Time.now__\n\nале __всередині__ ми використовуємо змінні об'єкта:\n\n> __@time = Time.now__\n\nЦе одне і те саме, але може використовуватися в різних місцях твоєї програми.\n\n### Створімо інший Blurb<sup>TM</sup>\nКоли інший Blurb<sup>TM</sup> створений, метод ініціалізації використовується для перевірки будь-якого аргументи до методу new.\n\nОй, потрібно ще 2 аргументи:\n\n    Blurb2 = Blurb.new :confused, \"Не можу повірити, Мавнт-Худ вкрали!\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"UA","title":"А жирафа на місці Підсумки #7","chapter":"Y","answer":"","ok":"","error":"","text":"Ага, ти тут. І все ще вчишся.\nМи як і раніше будемо робити твій додаток реальним, але поки що погляньмо на результати, гаразд?\n\n\n### Класи\nВсе в Ruby – це об'єкти. Класи пояснюють об'єкти, як певний об'єкт працює.\nНаприклад, ти створив кілька Blurb<sup>TM</sup> об'єктів, а ці об'єкти поводяться так само як будь-який об'єкт класу Blurb.\nІншими словами: ти називаєш їх Blurb об'єктами. Ти можеш використовувати класи щоб (начебто) моделювати реальне життя.  \n\n### Аксесори\nАксесори – це змінні, пов'язані з класом, але використовуються ззовні об'єкта.\n\n(blurb2.time = Time.now)\n\n### Змінні об'єкта\nЦе те ж саме, що й аксесори, але вони використовуються __всередині__ об'єкта.\n(@time = Time.now)","load_code":"prev;blurb2=Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"UA","title":"Твій власний терен","chapter":"N","answer":"Blurbalizer:","ok":"Додаток створено","error":"","text":"Гаразд, закругляймося, хлопче. Ось останній розділ епічної історії пізнання Try Ruby!\nТепер, коли у тебе є розуміння, як все це працює, як ти збираєшся його використовувати?\nТи чудова людина (один з моїх улюбленців), але тобі потрібне керівництво.\n\n### Закінчимо наш додаток\nУ нас є записи додатків, але може бути відсутня програма.\nЯк і раніше потрібно ім'я, місце, де можна зберігати всі Blurbs<sup>TM</sup> і впорядкувати їх.\n\nМи збираємося використовувати інший клас. Я дав весь код для нового класу за раз. Тільки __не поспішай, вивчи його__.\nЯ не поспішаю, я буду чекати тебе на наступному уроці.\n\n    class Blurbalizer\n      def initialize(title)\n        @title  = title\n        @blurbs = [] # Порожній масив\n                     # для зберігання Blurbs\n      end\n\n      def add_a_blurb(mood, content)\n        # The << means add to the end of the array\n        @blurbs << Blurb.new(mood, content)\n      end\n\n      def show_timeline\n        puts \"Blurbify: #{@title} has #{@blurbs.count} Blurbs\"\n\n        @blurbs.sort_by { |t|\n          t.time\n        }.reverse.each { |t|\n          puts \"#{t.content.ljust(40)} #{t.time}\"\n        }\n      end\n    end\n\n    myapp = Blurbalizer.new \"The Big Blurb\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"UA","title":"То про що цей Blurb?","chapter":"N","answer":"Сьогодні","ok":"Додай blurbs","error":"","text":"І ось результат. Ти зрозумів, що робить код у класі Blurbalizer<sup>TM</sup>?\n\n> У Blurbalizer<sup>TM</sup> є 2 методи (add\\_a\\_blurb та show\\_timeline). Можеш використовувати метод поза класом, так як і з аксесорами.\n\nСаме час щоб почати використовувати Blurbalizer<sup>TM</sup>. Я вже завантажив кілька Blurbs<sup>TM</sup> для тебе, але можеш додати ще свій.\n\nМи більше не створюємо Blurbs<sup>TM</sup> directly, безпосередньо, а використовуємо метод add\\_a\\_blurb з класу Blurbalizer<sup>TM</sup>.\nТепер ми можемо бути певні, що всі наші  Blurbs<sup>TM</sup> зберігаються в об'єкті myapp.\n\n    myapp.add_a_blurb :moody, \"Додай Blurb сюди\"\n\n    myapp.show_timeline","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"UA","title":"Про комбінування","chapter":"N","answer":":-","ok":"Moody!","error":"","text":"Деякі цікаві речі можна зробити за допомогою простих частин Ruby, особливо коли ти їх поєднуєш разом в дещо нове. Тут ми маємо додаток, що складається з класу, що містить інший клас. Це називається об'єктно-орієнтоване програмування (ООП).\n\nМи приступаємо до __останнього завдання__ на TryRuby. Якщо хочеш, то можеш додати більше цікавого в Blurbalizer<sup>TM</sup>.\n\nМоже ти захочеш вивести усміхнений смайлик в методі __show\\_timeline__.\nТи маєш додати _moodify_ метод в клас Blurb<sup>TM</sup> і потім використати цей метод в __show\\_timeline__:\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n\n      def initialize(mood, content=\"\")\n        @time    = Time.now\n        @content = content[0..39]\n        @mood    = mood\n      end\n\n      def moodify\n        if    @mood == :sad\n          return \":-(\"\n        elsif @mood == :happy\n          return \":-)\"\n        # Додай інший смайлик сюди\n        end\n\n        # Смайлик за замовчуванням\n        \":-|\"\n      end\n    end\n\n    class Blurbalizer\n      def initialize(title)\n        @title  = title\n        @blurbs = []\n      end\n\n      def add_a_blurb(mood, content)\n        @blurbs << Blurb.new(mood, content)\n      end\n\n      def show_timeline\n        puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\"\n\n        @blurbs.sort_by { |t|\n          t.time\n        }.reverse.each { |t|\n          puts \"#{t.content.ljust(40)} #{t.time}\"\n        }\n      end\n    end\n\n    myapp.show_timeline","load_code":"prev"},
"56":{"lang":"UA","title":"Підсумки #8 Розслабся, ти добре постарався!","chapter":"Y","answer":"","ok":"","error":"","text":"Цей останній розділ потрібен, щоб дати тобі кілька вказівок про те, як ти можеш використовувати Ruby.\n\nЯкщо тобі сподобалося, то можеш продовжити в <a href=\"/playground\">TryRuby Playground</a>\nабо завантажити та встановити Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a>\n\nКоли встановиш Ruby, створи новий файл _my\\_first\\_progam.rb_, використовуючи текстовий редактор, додай трохи коду,\nпотім відкрий термінал або командний рядок і набери:\n\n    ruby my_first_progam.rb\n\nІснує багато (вільних) середовищ розробки, які поєднують редактор коду, переглядач файлів і середовище Ruby.\nУ професіоналів попитом користуються Ruby Mine, VS Code, Atom, Sublime Text, Vim.\n\n## Святкуй!\nТи дійсно заслуговуєш двошаровий торт з подвійною глазур'ю і музиканта, що грає на одній з тих крутих подвійних гітар.\nТи закінчив, ти дійсно зробив це! Не сумнівайтеся в собі! Продовжуй вивчати цю прекрасну мову програмування – Ruby!\n\n## Більше інформації\nНа цьому сайті є ще статті, в яких ти можеш знайти щось корисне для себе.","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_progam=K.new"}}