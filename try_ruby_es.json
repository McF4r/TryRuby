{"1":{"lang":"ES","title":"¿Tienes 30 minutos? ¡Prueba Ruby ahora mismo!","chapter":"Y","answer":"","ok":"","error":"","text":"Ruby es un lenguaje de programación de Japón que está revolucionando el desarrollo de software.\n\nLa belleza de Ruby está en el equilibrio entre simplicidad y potencia.\n\nEscribe código Ruby en el editor y usa estos botones para navegar:\n\n- __Run__ &rarr; Ejecuta el código en el editor\n- __Copy__ &rarr; Copia el ejemplo al editor\n- __Next__ &rarr; Avanza a la siguiente lección\n- __Back__ &rarr; Retrocede a la lección anterior\n- __Clear__ &rarr; Borra el editor\n\nUsa el botón 'Mundo' de arriba <span aria-hidden=\"true\" class=\"glyphicon glyphicon-globe\"></span>\npara cambiar el idioma de Try Ruby.\n\n### Pulsa __Next__ para empezar a aprender.","load_code":""},
"2":{"lang":"ES","title":"Usando el editor","chapter":"N","answer":"^\\d{1,}$","ok":"¡ Bien ! Has hecho algo de matemáticas. ¿Has visto cómo apareció la respuesta?","error":"Escribe 2 + 6 en el editor","text":"La ventana del editor, abajo, es donde escribes tu código Ruby. Pulsa el botón __Run__ y mira cómo se ejecuta.\n\nPor ejemplo, prueba a escribir algo de matemáticas, como:\n\n    2 + 6\n\nLa salida de tu programa debería aparecer en la ventana de Resultado (\"Output\"), arriba.\nDebería aparecer también una línea explicando si lo has hecho bien o mal.\n\n\n> También puedes pulsar el botón __Copy__ para copiar el ejemplo al editor.","load_code":""},
"3":{"lang":"ES","title":"Números y Matemáticas","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Bien","error":"","text":"Ruby reconoce números y símbolos matemáticos. Prueba otras operaciones como:\n\n    4 * 10\n    5 - 12\n    30 / 4","load_code":""},
"4":{"lang":"ES","title":"Mostrándolo diferente","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Bien dicho","error":"","text":"¿Has notado que si escribes más de una fórmula, solo ves la respuesta de la última?\n¿Qué pasa?\n\n\n> Para hacer esta web más sencilla de usar, le he dicho a Ruby que copie el resultado de tu programa en la pantalla \n> output de arriba. Para que cuando escribas una fórmula veas los resultados.\n> __Pero solo el último resultado__. Y solo si la pantalla output está vacía.\n\nAsí que cuando introdujiste dos o más fórmulas, Ruby solamente mostró el resultado de la última.\n\n¡Por supuesto, tienes la capacidad de controlar la pantalla! Simplemente escribe __puts__ antes de cada fórmula\n(dejando un espacio entre ellos). Puts significa: *'pon algo en la pantalla'\n\nPrueba esto:\n\n    puts 4 * 10\n    puts 5 - 12\n    puts 30 / 4\n\nAhora quita el puts de la última fórmula y mira qué pasa.","load_code":""},
"5":{"lang":"ES","title":"Di tu nombre","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Perfecto, has formado un string con las letras de tu nombre.","error":"","text":"Claro, los ordenadores son prácticos y rápidos para las matemáticas. Sigamos. ¿Quieres ver tu nombre al revés?\n\nPrimero, teclea tu nombre entre comillas, así:\n\n    \"Juan\"","load_code":""},
"6":{"lang":"ES","title":"Di tu nombre al revés","chapter":"N","answer":"\\w+","ok":"neiB","error":"","text":"Un string es un conjunto de caracteres que el ordenador puede procesar. Imagina que las letras están\nen la cuerda de la colada, y que las comillas son las pinzas que sujetan los extremos. Las comillas marcan el principio y el final.\nPara dar la vuelta a tu nombre, teclea:\n\n    \"Juan\".reverse\n\n(¡No te olvides del punto!)","load_code":""},
"7":{"lang":"ES","title":"Contando letras","chapter":"N","answer":"^\\d+$","ok":"Sí, length también es un 'método'","error":"","text":"Has usado el __método__ reverse en tu nombre. Has hecho un string escribiendo tu nombre entre comillas. Luego has llamado al método reverse, que trabaja con strings para darle la vuelta a todas las letras.\n\nAhora, veamos cuántas letras tiene tu nombre:\n\n    \"Juan\".length","load_code":""},
"8":{"lang":"ES","title":"Las Repeticiones","chapter":"N","answer":"(\\w+)","ok":"Encantado de conocerte.Encantado de conocerte.Encantado de conocerte.","error":"","text":"Probablemente te estés preguntando para qué vale todo esto.\n\nBueno, seguro que has ido a un sitio web que te ha gritado: __¡Eh, tu contraseña es demasiado corta!__\n\nAlgunos programas usan ese simple código: __.length__\n\nMira esto. Multiplica tu nombre por 5:\n\n    \"Juan\" * 5","load_code":""},
"9":{"lang":"ES","title":"Ey, Sumario #1 Ya","chapter":"Y","answer":"NoMethodError|undefined","ok":"Nop, no es posible dar la vuelta a un número. Pulsa 'next'","error":"","text":"Echemos un vistazo a lo que has aprendido en el primer minuto.\n\n### El editor\nEscribir código en el editor y pulsar __run__ te da una respuesta en la ventana de resultado.\n(Casi) todo código da una respuesta.\n\n### Números y strings (cadenas de texto)\nLos números y los strings (las cadenas de texto) son los objetos de Ruby para las mates y los textos.\n\n### Métodos\nYa has usado métodos de lenguaje como dar la __vuelta__ (reverse) o __tamaño__ (length). Y también métodos simbólicos como la multiplicación: \\*  \n__Los Métodos significan acción!__\n\nEsta es la esencia de tu aprendizaje. Coger cosas simples, jugar con ellas y convertirlas en cosas nuevas. ¿Te sientes cómodo? Seguro que sí.\n\n## De acuerdo\n\nHagamos algo incómodo. Intenta darle la vuelta a un número:\n\n    40.reverse","load_code":""},
"10":{"lang":"ES","title":"Para, estás loco de atar!","chapter":"N","answer":"^\\d{1,}$","ok":"Sólo a strings (cadenas de texto) se les puede dar la vuelta","error":"","text":"No puedes darle la vuelta al número cuarenta. Imagino que puedes poner tu monitor delante del espejo, pero darle la vuelta a un número no tiene sentido.\n\nRuby ha lanzado un mensaje de error que te dice que no hay un método para dar la vuelta a un número.\n\nQuizás, si conviertes antes el número en string:\n\n    40.to_s.reverse","load_code":""},
"11":{"lang":"ES","title":"Las Naranjas son diferentes de las Manzanas","chapter":"N","answer":"\\[\\]","ok":"Genial, eso es una lisa vacía","error":"","text":"Y los números son distintos de las letras.\n\nEn Ruby puedes usar métodos sobre cualquier objeto, pero algunos métodos solo funcionan con cierto tipo de cosas.\n\nLo bueno es que siempre puedes convertir algo en otro tipo de cosa usando los métodos \"to\" de Ruby.\n\n\n- __to_s__ convierte cosas en  __s__trings (cadenas de texto)\n- __to_i__ convierte cosas en  __i__ntegers (numeros enteros)\n- __to_a__ convierte cosas en  __a__rrays (listas)\n\n__¿Qué son las arrays?__\n\nSon listas. Escribe un par de corchetes:\n\n    []","load_code":""},
"12":{"lang":"ES","title":"En la cola","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Excelente","error":"Prueba a añadir un cuarto número a la lista","text":"Las listas (arrays) guardan cosas __en algún orden__.\n\nComo estar en la cola para comprar palomitas de maíz. Estás detrás de alguien y no se te ocurriría empujare a un lado, no? Además tienes a alguien detrás de tí, y no le pierdes de vista, correcto?\n\nAquí hay una lista para tí. Números de lotería:\n\n    [12, 47, 35]\n\n\nPrueba a añadir un número a esta lista: pon una coma detrás del 35 y a continuación un número, el espacio es opcional.","load_code":""},
"13":{"lang":"ES","title":"Uno Levanta la Mano","chapter":"N","answer":"^47$","ok":"Correcto","error":"","text":"Una lista de números de lotería. ¿Cuál es el mayor?\n\nPrueba: \n\n    [12, 47, 35].max","load_code":""},
"14":{"lang":"ES","title":"Guardando una Lista","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"¡Guardada!","error":"","text":"Bien, bien. Pero es molesto tener que teclear esa lista cada vez que la necesitas, ¿verdad?\n\nVamos a guardar nuestros números en un boleto, así:\n\n    boleto = [12, 47, 35]","load_code":""},
"15":{"lang":"ES","title":"Ahora Teclea Ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"¡Recuperado!","error":"","text":"Ahora, escribe:\n\n    boleto","load_code":"boleto = [12, 47, 35]"},
"16":{"lang":"ES","title":"Salvado, Guardado","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Has ordenado la lista","error":"","text":"Has almacenado tus números de la loto, guardándolos en una __variable__ llamada boleto.\nCualquier otro nombre, como _listadejuan_ hubiera funcionado también.\n\nProgramar, te darás cuenta, consiste principalmente en trabajar con variables.\n\n¿Qué te parece si ordenamos los números de la lotería?\n\nUsa: \n\n    boleto.sort!\n    \nTenías una lista. La has ordenado. La variable boleto ha cambiado. \n¿Has notado que el método _sort! tiene una gran, brillante exclamación al final?\nMuchas veces los métodos de Ruby te gritan así si modifican una variable.\nNo es nada especial, sólo una marca.","load_code":"boleto = [12, 47, 35]"},
"17":{"lang":"ES","title":"Elemental","chapter":"N","answer":"^(12|35|47)$","ok":"Correcto","error":"Casi","text":"Hemos almacenado nuestros números de lotería en la variable boleto. ¿Qué tal si los sacamos otra vez?\n\nYa hemos visto que podemos obtener el número más alto con __max__. De igual modo, podemos\nobtener el primer (__first__) o último (__last__) elemento de la lista.\nPero, ¿y si queremos un elemento concreto?\n\n\n\n### [ ]\nRuby usa los paréntesis cuadrados [ ] para apuntar a un elemento.\nLos paréntesis cuadrados son muy comunes en Ruby.\nSon como una mirilla para apuntar a un objetivo. Exactamente.\nEstos paréntesis significan: \"Estoy buscando a ___\". Preparados, apunten.\n\nObtengamos todos nuestros números de lotería:\n\n    puts boleto[0]\n    puts boleto[1]\n    puts boleto[2]\n\n¿Por qué usamos [0], [1], [2] y no [1], [2] y [3]? \n¿Es algún tipo de idea Zen japonesa?\nNo, a nosotros los programadores nos gusta empezar a contar desde cero. No es solo una cosa de Ruby,\nen la mayoría de lenguajes de programación los índices de este tipo suelen empezar en cero.\n\n> Un pequeño recordatorio: puedes usar el botón __Copy__ para copiar el ejemplo al editor.","load_code":"boleto = [12, 47, 35]"},
"18":{"lang":"ES","title":"El Resumen #2 está con Nosotros","chapter":"Y","answer":"\\w+","ok":"¿Rima?","error":"","text":"Ahora, mira cómo fue nuestro segundo minuto:\n\n\n### Errores\nSi tratas de darle la vuelta a un número o hacer algo sospechoso, Ruby te lo dice.\n\n### Arrays\nLos arrays son listas para almacenar cosas en orden.\nTambién sabemos cómo crear arrays y obtener elementos de arrays.\n\n### Variables\nLas variables almacenan una cosa y le dan un nombre, usamos el signo igual para hacerlo. Así:\nboleto = [14, 37, 18].\n\n### 2/8\nEn total hay ocho secciones. ¡Ya llevas dos octavos del camino! Por ahora son cosas simples, \n¿no crees? Las cosas interesantes te esperan más adelante.\n\nCambiemos de dirección por un momento. He metido un poco de poesía para ti en una variable. \nEcha un vistazo. Escribe:\n\n    puts poema","load_code":"poema = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"ES","title":"Desafortunadamente, odias la poesía sobre tostadas","chapter":"N","answer":"(toast){0}","ok":"Excelente","error":"Me sigue oliendo a tostada","text":"Mira, no importa. No tiene por qué gustarte. Arréglalo, por favor. En lugar de toast (tostada), \nprueba con un melón o algo. Prueba esto para ver el nuevo poema:\n\n    poema.gsub(\"toast\", \"honeydew\")\n\nEl método __gsub__  es un diminutivo de \"global substitute\" (sustitución global). Reemplaza todas las ocurrencias de \"toast\" con\n\"honeydew\" (melón chino).","load_code":"prev"},
"20":{"lang":"ES","title":"Apunten. Fuego","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"De acuerdo, sí. Se ha dado la vuelta el poema entero.","error":"","text":"Pregunta: ¿qué pasa si le damos la vuelta a todo este poema?\n\n    poema.reverse","load_code":"prev"},
"21":{"lang":"ES","title":"Demasiado giro","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"Sí, casi lo que queremos","error":"","text":"Así que el poema entero se ha dado la vuelta, letra a letra. Pero yo solamente quería dar la vuelta a las líneas.\nMover la última línea al principio y la primera al final.\n\nAl revés, pero no __tan__ al revés.\n\nAsí es como se haría:\n\n    poema.lines.reverse","load_code":"prev"},
"22":{"lang":"ES","title":"Tirabuzón de Métodos en Cadena","chapter":"N","answer":"^More still did (.+)","ok":"Bien hecho, amigo mío.<br/>El método join cogió el array de líneas y las puso juntas en un string.","error":"","text":"¿Qué ves? ¿Qué ha pasado? Has escrito __poema.lines.reverse__ y ¿qué ha pasado?\n\nHan pasado dos cosas. Has convertido el poema en una lista usando lines.\nLines decide la forma en la que un string se divide y lo convierte en un Array.\n\nLuego, has dado la vuelta a esa lista. Tenías cada una de las líneas. Les diste la vuelta. Eso es todo.\n\nAñadamos un nuevo método al final de la cadena:\n\n    puts poema.lines.reverse.join\n\nCombinar métodos así se llama _encadenar métodos_.","load_code":"prev"},
"23":{"lang":"ES","title":"De Todos los Resúmenes, #3 Ya Está Aquí","chapter":"Y","answer":"\\{\\}","ok":"¡Has creado un Hash vacío!","error":"","text":"### Exclamaciones\nLos métodos pueden tener exclamaciones (y también interrogaciones) en el nombre.\nSolamente están ahí para explicar mejor su función. Nada importante.\n\n### Manipulación de Strings\nBuscar y modificar strings\n\n### Encadenar\nEncadenar métodos te permite hacer mucho más trabajo. Partir un poema, darle la vuelta, volverlo a ensamblar:\n\n__poema.lines.reverse.join__\n\nEn este punto, puedes jugar con el poema un poco más. Puedes encontrar <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">aquí</a> una lista completa de todos los métodos de String.\n\nAdelante, prueba algunos de ellos como: poema.downcase o poema.swapcase\n\n## ¿Listo?\nCuando estés listo para seguir, teclea:\n\n    libros = {}","load_code":"prev"},
"24":{"lang":"ES","title":"Un Diminuto Libro En Blanco","chapter":"N","answer":"^(esplendido|muy_bueno|mediocre|malo|abismal)$","ok":"Sí, eso es una nueva reseña","error":"Usa uno de :esplendido, :muy_bueno, :mediocre, :malo, :abismal.<br/>No te olvides los dos puntos.","text":"Has creado un __hash__ vacío. Un hash es como un array, salvo que cada uno de sus elementos tiene un nombre.\n\nVamos a meter algunas mini-reseñas de libros en nuestro nuevo hash. Aquí está nuestro sistema de puntuación:\n\n- :esplendido &rarr; una obra maestra\n- :muy\\_bueno &rarr; lo he disfrutado, sí\n- :mediocre &rarr; genial y terrible a partes iguales\n- :malo &rarr; notablemente malo\n- :abismal &rarr; siniestro total\n\nPara puntuar un libro, pon el título entre paréntesis cuadrados y la puntuación después del igual. Por ejemplo:\n\n    libros[\"El Arco Iris de Gravedad\"] = :esplendido\n\n> Es momento de contarte que las lecciones de TryRuby son independientes unas de otras.\n> Así que si te vuelves loco escribiendo reseñas ahora, solo las podrás usar en esta lección.\n> Si quieres usar tus reseñas en la siguiente lección, te recomiendo que las copies y las pegues.\n> Pero no te preocupes demasiado, cada lección tiene suficiente contenido predefinido para que juegues con él.","load_code":"libros = {}"},
"25":{"lang":"ES","title":"Más mini-reseñas","chapter":"N","answer":"[3-9]","ok":"Ves, el método length funciona con strings, arrays y hashes.","error":"","text":"Sigue, rellénalo con reseñas. Y, si quieres ver la lista entera, teclea: __puts libros__\n\nLas puntuaciones son: :esplendido, :muy_bueno, :mediocre, :malo y :abismal\n\nEstas puntuaciones no son strings. Cuando pones dos puntos delante de una palabra, obtienes un __símbolo__.\nLos símbolos son más baratos que los strings (en cuanto a memoria del ordenador). Si usas una palabra muchas veces\na lo largo de tu programa, mejor usa un símbolo. En lugar de tener miles de copias de esa palabra en memoria, \nel ordenador solamente almacenará el símbolo __una vez__.\n\nY más importante, un símbolo indica que no se trata de una palabra cualquiera, sino de algo que tiene significado para tu programa.\n\nIntroduce 2 reseñas más, usa __libros.length__ para ver cuántas reseñas tienes en el hash:\n\n    libros[\"El fin profundo\"]  = :abismal\n    libros[\"Colores vivientes\"] = :mediocre\n    \n    puts libros\n    \n    puts libros.length","load_code":"libros = {\"El Arco Iris de Gravedad\" => :esplendido}"},
"26":{"lang":"ES","title":"Espera, ¿me gustó El Arco Iris de Gravedad?","chapter":"N","answer":"^(esplendido|muy_bueno|mediocre|malo|abismal)$","ok":"Me gustó mucho","error":"","text":"Una gran cosa de Ruby es que normalmente se reutilizan los nombres, lo que significa que hay menos nombres que memorizar.\n\nRecuerda cómo se obtenían elementos de un array usando un número:\n__puts boleto[1]__.\n\nPara un hash, funciona igual, excepto que no usamos un número para obtener un elemento, sino un nombre.\n\nAsí que si quieres consultar una de tus antiguas reseñas, pon el título en el cuadrado. Pero no pongas un igual.\nAsí:\n\n    puts libros[\"El Arco Iris de Gravedad\"]","load_code":"libros = {\"El Arco Iris de Gravedad\" => :esplendido, \"El fin profundo\" => :abismal, \"Colores vivientes\" => :mediocre}"},
"27":{"lang":"ES","title":"Hashes como Parejas","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Encontraste las claves","error":"","text":"Ten en cuenta que los hashes no guardan las cosas en orden. Ese no es su trabajo. Simplemente emparejan dos cosas: una __clave__ y un __valor__.\n\nEn tus reseñas, el título del libro es la clave, y la puntuación es el valor.\n\nSi quieres ver solo los títulos de todos los libros que has reseñado:\n\n    libros.keys\n\nPuedes probar también con .values en lugar de .keys","load_code":"prev"},
"28":{"lang":"ES","title":"¿Eres severo?","chapter":"N","answer":"\"mediocre\"","ok":"¡Genial! Has hecho un marcador de puntuaciones.","error":"","text":"¿Estás siendo severo e injusto con tus puntuaciones? Hagamos la cuenta con un nuevo hash __puntuaciones__:\n\nVeamos, contemos tus reseñas. Sigue conmigo. Teclea:\n\n    puntuaciones = Hash.new {0}\n    \n    libros.values.each { |puntuacion|\n      puntuaciones[puntuacion] += 1\n    }\n    \n    puts puntuaciones\n\nLa linea vertical en el código es el carácter \"pipe\", probablemente lo encontrarás en la tecla del 1 (pulsa Alt gr y el 1).\n\nEl _+=1_ significa: incrementa el valor en 1.\n\nNo te preocupes si no entiendes todo lo que está pasando. Todo será explicado en su momento.","load_code":"libros = {\"El Arco Iris de Gravedad\" => :esplendido, \"El fin profundo\" => :abismal, \"Colores vivientes\" => :mediocre, \"Abejorros\" => :mediocre}"},
"29":{"lang":"ES","title":"El Total","chapter":"N","answer":"\\w+","ok":"¡Requeteolé!","error":"","text":"Una de las impresionantes novedades que acabamos de usar es un __bloque__. Vamos a explorar \nun poco más en esta lección y en la siguiente. Pero básicamente, un bloque es un poco de código Ruby\nrodeado de llaves ({}).\n\nProbemos otro bloque:\n\n    5.times { print \"¡Olé! \" }\n\nLos bloques siempre se asocian a métodos. Por ejemplo el método __times__, que coge el bloque y ejecuta el código muchas veces (en nuestro ejemplo: cinco veces).","load_code":""},
"30":{"lang":"ES","title":"¿Quién da la vez?","chapter":"N","answer":"^[0-9]$","ok":"Perfecto, justo a tiempo.","error":"Ejecuta el bloque entre 0 y 9 veces.","text":"Como vimos en el primer ejemplo de un bloque (contando puntuaciones), podemos pasar una variable al bloque.\nQué valores __se le pasan__ es algo que determina el método que ejecuta el bloque.\n\nLos valores __recibidos__ por el bloque se colocan en la variable que aparece al principio del bloque, entre las barras verticales: |\n\nProbémoslo con este bloque:\n\n    5.times { |vez|\n      puts vez\n    }\n\nAquí, el método __.times__ envía un valor a la variable __|vez|__. Pero date cuenta que la variable vez solo se conoce dentro del bloque.\n\n> ¿Te has dado cuenta de que puedes partir el código en varias líneas? Lo hace más fácil de leer.","load_code":""},
"31":{"lang":"ES","title":"Llegando al resumen #4","chapter":"Y","answer":"","ok":"","error":"","text":"Esta última lección ha sido un poco más larga. Probablemente habrás usado hasta tres minutos aprendiendo acerca de:\n\n### Hashes\nEl pequeño diccionario con las páginas curvas: __{}__\n\n### Símbolos\nPequeñas y eficientes palabras clave, con dos puntos, como __:esplendido__\n\n### Bloques\nTrozos de código que se pueden añadir a muchos métodos de Ruby. Aquí está el código que usaste para calcular la cuenta de puntuaciones:\n__libros.values.each { |puntuacion| puntuaciones[puntuacion] += 1 }__\n\n### Siguiente\nEn la siguiente leccion ahondaremos un poco más en los métodos.","load_code":""},
"32":{"lang":"ES","title":"to (be) or not to (be)","chapter":"N","answer":"","ok":"","error":"","text":"Otra pequeña cosa sobre la que no hemos hablado abiertamente: los argumentos de los métodos.\n¿Recuerdas cuando cambiamos el poema un poco? Usamos:\n__poema.gsub(\"toast\", \"honeydew\")__\n    \nEl método gsub necesita dos argumentos, que le pasamos incluyendo dos strings entre paréntesis.\n_Los argumentos le dicen al método exactamente qué hacer._\n\n### Paréntesis\nDe hecho, la mayoría de las veces a Ruby no le importa si omites los paréntesis. Esto también habría funcionado:\n\n__poema.gsub \"toast\", \"honeydew\"__\n\nYa hemos usado también otro método con un parámetro. Muchas veces, de hecho, aunque no era demasiado obvio:\n\n    puts \"Hola\"\n    puts(\"Hola\")\n    \nSí, __puts__ también es un método. Para Ruby es lo mismo usar puts con o sin paréntesis, pero la versión sin paréntesis es un poco más fácil de leer. ¡ Y ahorra tiempo !\n\n> Así que la conclusión es que puedes hacer lo que quieras con los paréntesis,\n> mientras tu código se lea fácilmente.\n\n### to (be) or not to (be)\nSi _to_ es un método y _be_ es un argumento, ahora sabemos la respuesta a esta pregunta milenaria.\nEs una cuestión de preferencia si quieres _to be_ or _to(be)_.\n\n¿Tienes ganas de más Shakespeare? Sigue leyendo.","load_code":"poema = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nYada yada yada\\n\""},
"33":{"lang":"ES","title":"La fierecilla domada","chapter":"N","answer":"^domar","ok":"Bien, bien.","error":"","text":"Ya sabes cómo usar Ruby totalmente. Quiero decir que tienes controlado lo esencial.\nSimplemente tienes que conocer más métodos y probar bloques más complejos.\n\nPero hay una parte de Ruby que no hemos tratado: cómo hacer tus propios métodos.\n__¡Ejem!__ Pongámonos a ello, pues.\n\nAdemás de usar los métodos predefinidos por Ruby (como puts, sort, times), puedes definir\ntus propios métodos. ¿Por qué es una buena idea? Por dos razones:\n\n### Para hacer tu programa más corto\nSi tienes que hacer la misma cosa en más de una parte de tu código, es más fácil poner ese trozo de código en un método aparte.\nDe esta manera, tu código será más corto.\n\n### Para hacer tu código más fácil de leer\nSupón que tu programa necesita hacer muchas cosas distintas.\n__Podrías__ meter tódo el código en una sola pieza, pero sería muy difícil de leer y entender después.\n\nEn su lugar deberías dividir tu código en distintos métodos y darle a cada uno un nombre fácil de entender.\nTe lo agradecerás a ti mismo después.\n\n¿Cómo se define un método? Así:\n\n    def domar( numero_de_fierecillas )\n    end","load_code":""},
"34":{"lang":"ES","title":"En Ruby, Def Leppard significa: define el método Leppard","chapter":"N","answer":"^Domé","ok":"Domar no es aburrido","error":"","text":"Estupendo, lo has hecho. Estás haciendo tu propio método. Se empieza por def, seguido del nombre del método.\nY una lista de los argumentos que el método va a necesitar. ¡ No suena nada difícil ni peligroso !\nLo único que falta es rellenarlo con Ruby y terminarlo con end.\n\nAquí está el código:\n\n    def domar( numero_de_fierecillas )\n      numero_de_fierecillas.times {\n        puts \"Domé una fierecilla\"\n      }\n    end\n\n> __P.D.__  \n> Si no has entendido el título:\n> <a href=\"http://es.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\n> es el nombre de, una vez famoso, grupo británico.","load_code":""},
"35":{"lang":"ES","title":"The Ripened Fruit of Your Own Creation","chapter":"N","answer":"^Domé una fierecilla","ok":"Así aprenderán esas fierecillas.","error":"","text":"Ha nacido un nuevo método. Usémoslo:\n\n    domar 5","load_code":"def domar(numero_de_fierecillas); numero_de_fierecillas.times {puts \"Domé una fierecilla\"}; end;"},
"36":{"lang":"ES","title":"Dar y recibir","chapter":"N","answer":"\\d+","ok":"Perfecto.","error":"","text":"La mayoría de los métodos no solo reciben parametros de entrada, pero también __devolverán algo__.\nHe cambiado tu método un poco para que te devuelva un valor. Pruébalo:\n\n    def domar( numero_de_fierecillas )\n      numero_de_fierecillas.times {\n        puts \"Domé una fierecilla\"\n      }\n      return numero_de_fierecillas\n    end\n\n    puts domar(3)\n\n### Return\nY cómo te estás volviendo tan experto y avanzado, una consejo más:\npuedes omitir la palabra __return__ de la última línea del método.\nRuby automágicamente devolverá el último valor que se haya usado dentro del método.\n\nAsí que podemos cambiar la última línea a esto: __numero\\_de\\_fierecillas__.\n\nPero como el método __.times__ también devuelve el __numero\\_de\\_fierecillas__ podemos eliminar la última línea completamente.\n¡ Resulta que nuestra versión original del método ya era la que queríamos !","load_code":""},
"37":{"lang":"ES","title":"¿Hola, quién está ahí? ¡ Y el resumen #5 agita su sombrero !","chapter":"Y","answer":"","ok":"","error":"","text":"Bien hecho, bien hecho, bien hecho, ¡ bien hecho !\n\nDe verdad, de verdad, de verdad, ¡ de verdaaaaaaaaaad !\n\nAquí hay un resumen de los últimos minutos de tu vida:\n\n### Métodos\nLos métodos se pueden definir con __def__ y tienen un nombre. Los métodos hacen tu programa más corto y fácil de leer.\n\n### Parámetros\nLos métodos pueden recibir parámetros.\n\n### Valor de retorno\nLos métodos (casi) siempre devuelven un valor.\n\n## Ahora\n\"To (be) or not to (be)\" ya no es una incógnita para ti. ¿Listo para más Shakespeare?","load_code":""},
"38":{"lang":"ES","title":"El mundo es nuestro","chapter":"N","answer":"^\\{\\\"William","ok":"Bien. Un poco difícil de leer","error":"","text":"Hasta ahora hemos ejecutado programas que usan solamente cosas que hemos tecleado nosotros mismos.\nLo cual está bien, quiero decir, todos esos \"Olé\" fueron épicos, pero esto es la era de Internet, así que\nya es hora de incluir el resto del mundo en nuestros esfuerzos.\n\nHay muchos, muchos, muchos sitios web a los que les puedes pedir información. Por ejemplo\neste enlace te dará todos los <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Feeds de noticias de Google</a> sobre Ruby.\n\nTu navegador probablemente te lo muestra muy bonito. Si miras al código fuente de la ṕágina (Ctrl+U)\nverás una larga cadena de texto extrañamente formateado. En el ejemplo de Google, está en el formato __rss__.\n\n### Formatos\nHay muchos otros formatos, con nombres extraños, disponibles y que se usan en la web, como:\nhtml, xml y json. Sí, incluso este mismo sitio web utiliza un par de ellos.\n\nHe preparado un método para ti que recogerá una lista de las obras completas de William\nShakespeare de internet. (No te preocupes, de hecho proviene del mismo servidor donde se ejecuta este sitio web, así que no estamos molestando a nadie.)\n\nObtén la información con:\n\n    get_shakey","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"titulo\\\": \\\"Los dos hidalgos de Verona\\\", \\\"terminado\\\": 1591},\\\"2\\\": {\\\"titulo\\\": \\\"La fierecilla domada\\\", \\\"terminado\\\": 1591},\\\"3\\\": {\\\"titulo\\\": \\\"Enrique VI, Parte 2\\\", \\\"terminado\\\": 1591},\\\"4\\\": {\\\"titulo\\\": \\\"Enrique VI, Parte 3\\\", \\\"terminado\\\": 1591},\\\"5\\\": {\\\"titulo\\\": \\\"Enrique VI, Parte 1\\\", \\\"terminado\\\": 1592},\\\"6\\\": {\\\"titulo\\\": \\\"Tito Andrónico\\\", \\\"terminado\\\": 1592},\\\"7\\\": {\\\"titulo\\\": \\\"Ricardo III\\\", \\\"terminado\\\": 1593},\\\"8\\\": {\\\"titulo\\\": \\\"Eduardo III\\\", \\\"terminado\\\": 1593},\\\"9\\\": {\\\"titulo\\\": \\\"La comedia de las equivocaciones\\\", \\\"terminado\\\": 1594},\\\"10\\\": {\\\"titulo\\\": \\\"Trabajos de amor perdidos\\\", \\\"terminado\\\": 1595},\\\"11\\\": {\\\"titulo\\\": \\\"Trabajos de amor ganados\\\", \\\"terminado\\\": 1596},\\\"12\\\": {\\\"titulo\\\": \\\"Ricardo II\\\", \\\"terminado\\\": 1595},\\\"13\\\": {\\\"titulo\\\": \\\"Romeo y Julieta\\\", \\\"terminado\\\": 1595},\\\"14\\\": {\\\"titulo\\\": \\\"El sueño de una noche de verano\\\", \\\"terminado\\\": 1595},\\\"15\\\": {\\\"titulo\\\": \\\"El rey Juan\\\", \\\"terminado\\\": 1596},\\\"16\\\": {\\\"titulo\\\": \\\"El mercader de Venecia\\\", \\\"terminado\\\": 1597},\\\"17\\\": {\\\"titulo\\\": \\\"Enrique IV, Parte 1\\\", \\\"terminado\\\": 1597},\\\"18\\\": {\\\"titulo\\\": \\\"Las alegres comadres de Windsor\\\", \\\"terminado\\\": 1597},\\\"19\\\": {\\\"titulo\\\": \\\"Enrique IV, Parte 2\\\", \\\"terminado\\\": 1598},\\\"20\\\": {\\\"titulo\\\": \\\"Mucho ruido y pocas nueces\\\", \\\"terminado\\\": 1599},\\\"21\\\": {\\\"titulo\\\": \\\"Enrique V\\\", \\\"terminado\\\": 1599},\\\"22\\\": {\\\"titulo\\\": \\\"Julio Cesar\\\", \\\"terminado\\\": 1599},\\\"23\\\": {\\\"titulo\\\": \\\"Como gustéis\\\", \\\"terminado\\\": 1600},\\\"24\\\": {\\\"titulo\\\": \\\"Hamlet\\\", \\\"terminado\\\": 1601},\\\"25\\\": {\\\"titulo\\\": \\\"La decimosegunda noche\\\", \\\"terminado\\\": 1601},\\\"26\\\": {\\\"titulo\\\": \\\"Troilo y Crésida\\\", \\\"terminado\\\": 1602},\\\"27\\\": {\\\"titulo\\\": \\\"Tomás Moro\\\", \\\"terminado\\\": 1604},\\\"28\\\": {\\\"titulo\\\": \\\"Medida por medida\\\", \\\"terminado\\\": 1604},\\\"29\\\": {\\\"titulo\\\": \\\"Otelo\\\", \\\"terminado\\\": 1604},\\\"30\\\": {\\\"titulo\\\": \\\"A buen fin no hay mal tiempo\\\", \\\"terminado\\\": 1605},\\\"31\\\": {\\\"titulo\\\": \\\"El rey Lear\\\", \\\"terminado\\\": 1606},\\\"32\\\": {\\\"titulo\\\": \\\"Timón de Atenas\\\", \\\"terminado\\\": 1606},\\\"33\\\": {\\\"titulo\\\": \\\"Macbeth\\\", \\\"terminado\\\": 1606},\\\"34\\\": {\\\"titulo\\\": \\\"Antonio y Cleopatra\\\", \\\"terminado\\\": 1606},\\\"35\\\": {\\\"titulo\\\": \\\"Pericles\\\", \\\"terminado\\\": 1608},\\\"36\\\": {\\\"titulo\\\": \\\"Coriolano\\\", \\\"terminado\\\": 1608},\\\"37\\\": {\\\"titulo\\\": \\\"Cuento de invierno\\\", \\\"terminado\\\": 1611},\\\"38\\\": {\\\"titulo\\\": \\\"Cimbelino\\\", \\\"terminado\\\": 1610},\\\"39\\\": {\\\"titulo\\\": \\\"La tempestad\\\", \\\"terminado\\\": 1611},\\\"40\\\": {\\\"titulo\\\": \\\"Cardenio\\\", \\\"terminado\\\": 1613},\\\"41\\\": {\\\"titulo\\\": \\\"Enrique VIII\\\", \\\"terminado\\\": 1613},\\\"42\\\": {\\\"titulo\\\": \\\"Los dos nobles caballeros\\\", \\\"terminado\\\": 1614}}}\");end;"},
"39":{"lang":"ES","title":"Nobles caballeros","chapter":"N","answer":"^Los dos nobles caballeros$","ok":"Mucho mejor","error":"","text":"Bien, ahora tenemos una lista de obras obtenidas de internet. Esta lista estaba en el formato json.\nAfortunadamente para nosotros, Ruby amablemente nos ofrece un método para convertir datos en json a un hash de Ruby.\nEl método _get\\_shakey_ hace eso por nosotros.\n\nPero como la estructura de los datos en json se mantiene en el hash, sigue siendo un poco difícil de leer.\nEscribamos un método para mostrar las obras más adecuadamente.\n\nSi miras detenidamente la lista de obras, verás que sigue una especie de estructura anidada\n(esto es bastante frecuente en los datos que se obtienen de internet).\nSe parece a esto:\n\n<ul>\n  <li>\"William Shakespeare\"\n  <ul>\n      <li>\"1\"\n      <ul>\n        <li>\"titulo\": \"Los dos hidalgos de Verona\"</li>\n        <li>\"terminado\": 1591</li>\n      </ul>\n      </li>\n      <li>\"2\"\n      <ul>\n        <li>\"titulo\": \"La fierecilla domada\"</li>\n        <li>\"terminado\": 1591</li>\n      </ul>\n      </li>\n      <li>...</li>\n  </ul>\n  </li>\n</ul>\n\nPara listas las obras, primero tenemos que acceder al elemento de primer nivel del hash \"William Shakespeare\" por su nombre.\nDespués tenemos que __iterar__ todos los elementos bajo él.\n\nRuby tiene un método para iterar. Se llama __each__. Lo hemos visto antes, \ncuando creamos el sistema de reseñas de libros.\n\nTodo lo que el método __each__ devuelve se le pasa a un bloque:\n\n    s = get_shakey\n    \n    s[\"William Shakespeare\"].each { |key, val|\n      puts val[\"titulo\"]\n    }","load_code":"prev"},
"40":{"lang":"ES","title":"Todo en conjunto","chapter":"N","answer":"^4$","ok":"Sí, Shakespeare escribió 4 obras en 1591","error":"La respuesta correcta para el año 1591 es 4","text":"Supongamos que queremos saber los nombres y el número de obras escritas por Shakespeare en un año concreto.\n\nRuby nos permite seleccionar (__select__) valores de un hash. El método select utiliza un bloque\npara definir qué tiene que seleccionar, y nos devuelve lo que encuentre.\n\nPodemos entonces utilizar los resultados devueltos por __select__ en el metodo __each__ como antes\nsimplemente añadiendolo después del bloque para el select. Esto es otro ejemplo de encadenar métodos, \nque vimos con anterioridad al darle la vuelta al poema.\n\nHe preparado el método __cuenta\\_obras__ para ti. Mira a ver si puedes averiguar cuántas obras\nescribió Shakespeare en el año __1591__. Prueba esto:\n\n    def cuenta_obras(anyo)\n      s = get_shakey\n      \n      s[\"William Shakespeare\"]\n        .select { |k, v|\n          v[\"terminado\"] == anyo\n        }.each { |key, val|\n          puts val[\"titulo\"]\n        }.count\n    end\n    \n    puts cuenta_obras(0)\n\n¿Te has dado cuenta de cómo he encadenado el método count al final del método each?\nEsto nos da un valor de retorno para el método __cuenta\\_obras__.\n\nHay otra posibilidad de encadenar. ¿Ves esa solitaria linea: __s = get_shakey__?\n\nPodrías añadir el __[\"William Shakespeare\"].select { |k, v|__ a continuación de get_shakey\n(no se necesita punto en este caso).\n\n> Nota: en Ruby podrías escribir año con la ñ, pero parece que Opal, lo que usamos para ejecutar Ruby en el navegador tiene problemas con estos caracteres.","load_code":"prev"},
"41":{"lang":"ES","title":"A buen fin no hay mal tiempo","chapter":"N","answer":"A buen fin no hay mal tiempo","ok":"Cierto","error":"Usa 1605 como segundo parámetro","text":"Bien, tenemos ciertos datos de internet, hemos seleccionado lo que queríamos y lo hemos imprimido en pantalla.\n¿Qué queda por mejorar? Podríamos poner más bonitos los resultados. Por ejemplo,\nañadir el año, y alinear los títulos y años.\n\nEso implica imprimir varios valores en una línea. Ruby tiene una manera muy limpia de hacerlo.\nEs como imprimir un string como: __puts \"Hola, me llamo Juan\"__.\nPero en lugar del valor literal _Juan_ podemos usar el valor de una variable.\n\nPrimero, reemplazamos __Juan__ con __#{}__. Si Ruby ve un símbolo de almohadilla # seguido de una llave de abrir {, buscará una variable entre la primera llave y la siguiente llave de cerrar }.\nAsí que podríamos usar esto: __\"Hola, me llamo #{nombre}\"__.\n\nCambiemos nuestro código un poco:\n\n    def imprimir_obras(anyo_desde, anyo_hasta)\n      get_shakey[\"William Shakespeare\"]\n        .select { |k, v|\n          anyo_desde <= v[\"terminado\"] &&\n          anyo_hasta   >= v[\"terminado\"]\n        }.each { |k, v|\n          puts \"#{v[\"titulo\"].ljust(30)} #{v[\"terminado\"]}\"\n        }\n    end\n    imprimir_obras(1600, 1605)\n\nHe añadido __.ljust(30)__ al título. De este modo, el título se _justifica a la izquierda_ con una longitud mínima de 30 caracteres, para que los años se alineen y quede más bonito.\n\nA ver si puedes cambiar la salida del programa para que las obras se muestren así: __1600 -> Como gustéis__\n\n__¿A buen fin no hay mal tiempo?__ Todavía no hemos terminado, pero !la meta está a la vista!","load_code":"prev"},
"42":{"lang":"ES","title":"Si supiera cómo tomar decisiones","chapter":"N","answer":"","ok":"","error":"","text":"La toma de decisiones, en la vida real esto puede suponer un gran problema. No para nosotros.\nRuby hace que tomar decisiones sea muy fácil.\n\n    if 1 < 2\n      puts \"Es cierto: 1 es menor que 2\"\n    end\n\nLa palabra clave el __if__. If se puede situar antes o después de los métodos, así:\n\n    puts \"Es cierto: 1 es menor que 2\" if 1 < 2\n\n__If__ es un método que requiere un parámetro. Ese parámetro puede ser cualquier expresión que\nquieras verificar. El resultado de la expresión tiene que ser __true__ or __false__ (verdadero o falso).\nComo ejemplo unas cuantas expresiones y su resultado:\n\n    5     <= 10     # => true\n    'abc' == 'def'  # => false\n    true            # => true\n    123456          # => true\n    0               # => true\n    nil             # => false\n    'xyz'.empty?    # => false\n    'a' > 5         # => error:\n                    # comparison of String with\n                    # Numeric failed\n\nLa _expresión del if_ puede tomar muchas formas. Puede comparar valores literales (1 < 2), \nvariables (a < 1) y el valor de retorno de un método ('xyz'.empty?).","load_code":""},
"43":{"lang":"ES","title":"Y ahora para la sorprendente conclusión","chapter":"N","answer":"no es igual a 100$","ok":"Eso está mejor","error":"Eso no puede estar bien","text":"¿Has visto los dos símbolos de igual en __'abc' == 'def'__?\n\nEl __==__ significa __es igual a__.\n\nUn único símbolo de igual (que hemos visto anteriormente) significa __asigna un valor a esta variable__.\n\nPara hacer más confuso, puedes usar la asignación después de un if, así:\n\n    a = 0\n    \n    if a = 100\n      puts \"La expresión es true, pero a ahora es: #{a}\"\n    else\n      puts \"#{a} no es igual a 100\"\n    end\n\nCambia el = por == y mira qué pasa.\n\nTe garantizo que se te olvidará teclear el segundo símbolo de igual con bastante frecuencia. Yo mismo me olvido a veces.\n\n### else\nEn el código de arriba he añadido una expresión else. Esta es la parte que se ejecutará cuando la __expresión del if__ se evalua a false.\n\n> Hay más variantes de este if-then-else. Puedes leer más\n> <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">aquí</a>.","load_code":""},
"44":{"lang":"ES","title":"Tengo hambre","chapter":"N","answer":"^No tengo hambre","ok":"Sí","error":"¡ No es posible tener hambre a las 10 AM !","text":"Bien, esto va avanzando maravillosamente. Esto te puede parecer simple, pero recuerda que ¡ no sabías __nada de nada de Ruby__ hace 15 minutos !\n\nUltimo paso. Juntémoslo todo, ¿de acuerdo? Hagamoslo repicar todo como un conjunto de brillantes campanas en la playa bajo una gloriosa luz del sol.\n\nDefinamos dos métodos y luego tomaremos una decisión:\n\n    def hambre?(hora_del_dia)\n      puts \"Tengo hambre\"\n      true\n    end\n    \n    def come(que)\n      puts \"Me como un #{que}\\n\"\n    end\n    \n    come 'manzana' if hambre?(14)\n    \n    come 'manzana' if hambre?(10)\n\nMira a ver si puedes cambiar el método __hambre?__ para que muestre __\"No tengo hambre\"__ y devuelva false, si es antes de las 12.","load_code":""},
"45":{"lang":"ES","title":"Resumen #6 Que Significa Que Has Llegado Lejos","chapter":"Y","answer":"\\{\\}","ok":"Bien, es un hash vacío","error":"","text":"Ya eres un clérigo de Ruby de nivel 6. Quiero decir que has hecho un gran trabajo. Revisemos:\n\n### Datos\nHas cargado algunos datos de internet, recorrido una estructura de datos, y seleccionado valores.\n\n### Interando\nHas iterado todos los elementos de un hash y has encadenado algunos métodos más.\n\n### Impresion bonita\nSi eso no fuera suficiente, has formateado e imprimido algunos valores de una manera fácil de leer para humanos.\nDe hecho __¡has hecho un programa real!__\n\n### If\nHas aprendido a controlar tus programas con declaraciones __if__ y __else__.\n\n## Así que\n¿Qué puede venir a continuación? ¿Qué podrás aprender ahora?\nJa, esa es la mejor parte. Has llegado tan lejos que ahora vamos a descubrir las clases.\nDos lecciones cortas más y habremos terminado.\n\nAnteriormente, hemos creado un hash así:\n\n    Hash.new","load_code":""},
"46":{"lang":"ES","title":"No una Clase del Colegio, sino una Clase Trabajadora","chapter":"N","answer":"","ok":"","error":"","text":"Las llaves {} sin nada dentro, son un atajo para decir Hash.new. Este método new se usa para crear objetos\nde una cierta clase. Piensa en \"clase\" como en \"clase trabajadora &mdash; un grupo específico de objetos\nque son similares, tienen los mismos trabajos, lo mismos uniformes.\n¿Para qué se usan las clases?\n\n### Blurbalizer<sup>TM</sup>\nHas tenido una idea brillante para una nueva aplicación. Va a ser __la__ siguiente plataforma de \nmensajería instantánea. Quieres una aplicación con la que la gente se pueda enviar mensajes cortos entre sí.\nLlamas a esos mensajes Blurbs<sup>TM</sup>. Un Blurb<sup>TM</sup> tiene una longitud máxima de 40 caracteres.\nTengamos también la posibilidad de definir un estado de ánimo.\n\n<!---Internet realmente ha sacado de la bancarrota a los monigotes de palos y a los smileys. __¡A sentir!__-->\n\n### Por dónde empezar\nBueno, puedes guardar los Blurbs<sup>TM</sup> en un fichero json, ¿verdad?\nPero ¿cómo mantener un registro del contenido de la entrada y la hora a la que se publicó?\nY cuando cargues el fichero, ¿cómo será en Ruby?\n¿Será un Hash? ¿O un Array? ¿O un Array de Arrays? ¿U otra cosa?\n\n### Clase\nRealmente pienso que necesitarás usar una clase. Ya estás familiarizado con muchas clases:\nHash, Array, String.  \nHagamos una nueva (no tiene salida en pantalla):\n\n    class Blurb\n    end","load_code":""},
"47":{"lang":"ES","title":"Las Cosas de las que están hechas las Aplicaciones","chapter":"N","answer":"","ok":"","error":"","text":"Has abierto una nueva clase Blurb<sup>TM</sup>. ¿De qué estan hechas tus entradas del blog?\nEl contenido, por supuesto. También la hora a la que el Blurb<sup>TM</sup> se publicó. Y un estado de ánimo.\n\nBien, ya tienes la primera línea de la clase. Aquí está el resto:\n\n    class Blurb\n      attr_accessor :contenido, :tiempo, :animo\n    end\n\nLos nombres de clases empiezan por mayúscula.\n\n(Todavía no hay salida en la pantalla)","load_code":""},
"48":{"lang":"ES","title":"Los 'Accessors' son las extremidades colgantes","chapter":"N","answer":"Blurb:","ok":"Mi primer Blurb","error":"","text":"Buena clase, amigo. Tienes una nueva clase Blurb<sup>TM</sup>.\n\nEn la definición de la clase, usaste un método llamado attr\\_accessor.\nHay muchos métodos de __attr__ibutos como este que añaden pequeños ajustes.\nEstos atributos son simplemente variables adjuntadas a una clase.\n\nPienslo de esta manera. Una clase es como una persona. Esa cosa humana con forma de estrella de ahí.\nY los atributos son las extremidades colgantes, las diferentes partes que forman el cuerpo y con las que otras\npersonas pueden extrecharle las manos.\n\n### Ahora\nPara crear un Blurb<sup>TM</sup> y fijar su contenido:\n\n    blurb1 = Blurb.new\n    puts blurb1\n    blurb1.contenido = \"¡El Everest ha sido robado!\"","load_code":"class Blurb;attr_accessor :contenido,:tiempo,:animo;end"},
"49":{"lang":"ES","title":"El Objeto, ese Genial Pequeño Paquete","chapter":"N","answer":"Blurb:","ok":"Blurb actualizado","error":"","text":"Ve y fija la hora y el ánimo del Blurb<sup>TM</sup>:\n\n    blurb1.tiempo = Time.now\n    blurb1.animo = :enfermo\n    \n    puts blurb1","load_code":"prev;blurb1=Blurb.new;blurb1.contenido=\"¡El Everest ha sido robado!\""},
"50":{"lang":"ES","title":"Acelerandolo todo","chapter":"N","answer":"^\\d{4}","ok":"Apuntado","error":"","text":"Genial, tu aplicación es impresionante. Vamos a hacer las cosas un poco más fáciles para ti.\nNo vas a querer fijar la hora así cada vez que publiques un Blurb<sup>TM</sup>.\n\nSimplemente quieres escribir el contenido y fijar el estado de ánimo, ¿verdad?\n\nAñadamos un método __initialize__ a nuestra clase. Este método se llama cada vez que se crea un nuevo Blurb<sup>TM</sup>.\nA la misma vez podemos limitar la longitud del contenido del Blurb<sup>TM</sup> a 40 caracteres.\n\n    class Blurb\n      attr_accessor :contenido, :tiempo, :animo\n\n      def initialize(animo, contenido=\"\")\n        @tiempo    = Time.now\n        @contenido = contenido[0..39]\n        @animo    = animo\n      end\n    end\n    \n    Blurb.new.tiempo\n\n(Ese parámetro __contenido=\"\"__ está ahí para asegurarnos de que tenemos un string como contenido, aunque no le pasemos nada al método initialize).","load_code":""},
"51":{"lang":"ES","title":"Has Enseñado a tu Aplicación a Rechazar Cosas Sin Valor","chapter":"N","answer":"Blurb:","ok":"Blurb añadido","error":"","text":"¿Has visto cómo dentro de la clase usamos el símbolo arroba (@tiempo).\n\n__Fuera__ de la clase, usamos los accessors:\n\n> __blurb.tiempo = Time.now__\n\npero __dentro__ usamos las __variables del objeto__:\n\n> __@tiempo = Time.now__\n\nSon exactamente la misma cosa, pero expresada en dos sitios diferentes de tu programa.\n\n### Crea otro Blurb<sup>TM</sup>\nCuando se crea un nuevo Blurb<sup>TM</sup>, se usa el método initialize para chequear los argumentos de new.\n\nEh, necesitamos dos argumentos:\n\n    Blurb2 = Blurb.new :confuso, \"¡No puedo creer que hayan robado el Everest!\"","load_code":"class Blurb;attr_accessor :contenido,:tiempo,:animo;def initialize(animo, contenido=\"\");@tiempo=Time.now;@contenido=contenido[0..39];@animo=animo;end;end;blurb1=Blurb.new(:enfermo,\"¡El Everest ha sido robado!\")"},
"52":{"lang":"ES","title":"Ninguna Jirafa Ha Robado el Resumen #7","chapter":"Y","answer":"","ok":"","error":"","text":"Ah, estás aquí. Y de una pieza. Todavía tenemos que hacer realidad tu aplicación,\npero mientras tanto, revisemos, ¿de acuerdo?\n\n### Clases\nTodas las cosas en Ruby son un tipo de objeto. Las clases explican los objetos, cómo funciona un cierto objeto.\nPor ejemplo, has creado unos cuantos objetos Blurb<sup>TM</sup> y esos objetos están explicados en la clase Blurb.\nDicho de otro modo: los llamamos objetos Blurb.\nPuedes usar clases para modelar (en cierto modo) los objetos de la vida real.\n\n### Accessors\nLos Accessors son variables adjuntas a un objetos que se pueden usar desde __fuera__ del objeto.\n(blurb2.tiempo = Time.now)\n\n### Variables de objetos\nLas variables de objetos son las mismas variables que estás usando como accessors, pero __dentro__ del objeto.\n(@tiempo = Time.now)","load_code":"prev;blurb2=Blurb.new :confuso, ¡No puedo creer que hayan robado el Everest!\""},
"53":{"lang":"ES","title":"Tu Propio Territorio","chapter":"N","answer":"Blurbalizer:","ok":"Aplicación creada.","error":"","text":"Bien, cerremos todo esto, chico. !Este es el último capítulo de la FASCINANTE y épica historia de Try Ruby !\nAhora que has probado un poco cómo funciona todo, ¿cómo lo vas a usar en tu casa y en la nevera de la frutería?\nEres una gran persona (una de mis favoritas), pero todavía necesitas que te guíe.\n\n### Completemos la aplicación\nTienes entradas de tu aplicación, pero una aplicación real.\nTodavía necesita un título, algún lugar para almacenar todos los Blurbs<sup>TM</sup> y una cronología, para que todo funcione bien.\n\nAdivina, vamos a usar otra clase. He puesto todo el código para la nueva clase de golpe.\n__Tómate tu tiempo__ para estudiarlo.\nNo tengo prisa, te espero en la siguiente lección.\n\n    class Blurbalizer\n      def initialize(titulo)\n        @titulo  = titulo\n        @blurbs = [] # Un array nuevo y vacío para almacenar Blurbs\n      end\n      \n      def crear_un_blurb(animo, contenido)\n        # El << significa añadir al final del array\n        @blurbs << Blurb.new(animo, contenido)\n      end\n      \n      def mostrar_cronologia\n        puts \"Blurbalizer: #{@titulo} tiene #{@blurbs.count} Blurbs\"\n        \n        @blurbs.sort_by { |t|\n          t.tiempo\n        }.reverse.each { |t|\n          puts \"#{t.contenido.ljust(40)} #{t.tiempo}\"\n        }\n      end\n    end\n    \n    mi_app = Blurbalizer.new \"El Gran Blurb\"","load_code":"class Blurb;attr_accessor :contenido,:tiempo,:animo;def initialize(animo, contenido=\"\");@tiempo=Time.now;@contenido=contenido[0..39];@animo=animo;end;end"},
"54":{"lang":"ES","title":"¿De qué va todo ese Blurb?","chapter":"N","answer":"Han","ok":"Trae los blurbs","error":"","text":"Aquí estás. ¿Pudiste descifrar todo lo que hace el código de la clase Blurbalizer<sup>TM</sup>?\n\n> El la clase Blurbalizer<sup>TM</sup> hay dos __métodos__ (crear\\_un\\_blurb y mostrar\\_cronologia).\n> Puedes usar los métodos desde fuera de la clase, tal como hicimos con los accessors.\n\nHora de usar Blurbalizer<sup>TM</sup>. He cargado ya unos Blurbs<sup>TM</sup> para ti, pero puedes añadir los tuyos propios si quieres.\n\nYa no estamos creando Blurbs<sup>TM</sup> directamente, sino que usamos el __método__ crear\\_un\\_blurb de la clase\nBlurbalizer<sup>TM</sup>. De este modo, nos aseguramos de que todos los Blurbs<sup>TM</sup> quedan almacenados \nen el objeto mi_app.\n\n    mi_app.crear_un_blurb :malhumorado, \"Añade un blurb aqui\"\n    \n    mi_app.mostrar_cronologia","load_code":"prev;class Blurbalizer;attr_reader :titulo;def initialize(titulo);@titulo=titulo;@blurbs=[];end;def crear_un_blurb(animo, contenido);@blurbs << Blurb.new(animo, contenido);@blurbs.each {|t| t.tiempo -= 73};end;def mostrar_cronologia;puts \"Blurbalizer: #{@titulo} tiene #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.tiempo}.reverse.each { |t| puts \"#{t.contenido.ljust(40)} #{t.tiempo}\"};end;end;mi_app = Blurbalizer.new \"El Gran Blurb\";mi_app.crear_un_blurb :enfermo,\"¡Han robado el Everest!\";mi_app.crear_un_blurb :confuso,\"¡No me puedo creer que hayan robado el Everest!\";mi_app.crear_un_blurb :aturdido,\"¡Me he quedado sin palabras!\";mi_app.crear_un_blurb :de_locos,\"¡¡Lo robó una jirafa!!\";mi_app.crear_un_blurb :triste,\"¡Me había dejado mi sudadera en la montaña!\";mi_app.crear_un_blurb :rabioso,\"Jamás volveré a esa montaña.\""},
"55":{"lang":"ES","title":"Todo es combinar","chapter":"N","answer":":-","ok":"Ánimo cambiante !","error":"","text":"Se pueden hacer cosas preciosas con las partes simples de Ruby, especialmente cuando las combinas y creas cosas nuevas.  \nAquí tenemos un programa que está hecho con una clase que contiene otra clase. Y, la verdad, a Ruby se le dan muy bien este tipo de criaturas. Se llama programación orientada a objetos.\n\nHemos llegado al __último ejercicio de programación__ de TryRuby. Si quieres, puedes añadir más características a \nBlurbalizer<sup>TM</sup>\n\nQuizás quieres mostrar el ánimo con un smiley en el método __mostrar\\_cronologia__. Podrías incluso añadir un método __smiley\\_para\\_animo__ a la clase Blurb<sup>TM</sup> y usarlo en el método __mostrar\\_cronologia__:\n\n    class Blurb\n      attr_accessor :contenido, :tiempo, :animo\n      \n      def initialize(animo, contenido=\"\")\n        @tiempo    = Time.now\n        @contenido = contenido[0..39]\n        @animo    = animo\n      end\n      \n      def smiley_para_animo\n        if    @animo == :triste\n          return \":-(\"\n        elsif @animo == :alegre\n          return \":-)\"\n        # Añade otros animos aqui\n        end\n\n        # Animo por defecto\n        \":-|\"\n      end\n    end\n    \n    class Blurbalizer\n      def initialize(titulo)\n        @titulo  = titulo\n        @blurbs = []\n      end\n      \n      def crear_un_blurb(animo, contenido)\n        @blurbs << Blurb.new(animo, contenido)\n      end\n      \n      def mostrar_cronologia\n        puts \"Blurbalizer: #{@titulo} tiene #{@blurbs.count} Blurbs\"\n        \n        @blurbs.sort_by { |t|\n          t.tiempo\n        }.reverse.each { |t|\n          puts \"#{t.contenido.ljust(40)} #{t.tiempo}\"\n        }\n      end\n    end\n    \n    mi_app.mostrar_cronologia","load_code":"prev"},
"56":{"lang":"ES","title":"Sumario #8, El Sumario Ey-Relájate-Lo-Hiciste-Bien","chapter":"Y","answer":"","ok":"","error":"","text":"Esta última sección se tomó un momento para relajarse, y darte algunas pistas de cómo puedes usar Ruby.\n\nSi has disfrutado, puedes seguir con la zona de juegos <a href=\"/playground\">TryRuby Playground</a>\no descargarte e instalar Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a>\n\nUna vez que tengas Ruby instalado, con un editor de textos puedes crear un archivo, digamos _mi\\_primer\\_programa.rb_, escribir algo de código Ruby y ejecutarlo abriendo una ventana de comandos y escribiendo:\n\n    ruby mi_primer_programa.rb\n\nHay un montón de herramientas de desarrollo disponibles (libres) que combinan un editor, un navegador de archivos y un intérprete de Ruby.\n\n## Celebrar\nTe mereces una tarta doble-capa con doble glaseado extra y un tipo tocando una de esas guitarras dobles.\nQuiero decir, lo has conseguido, de verdad lo hiciste, has terminado! No hay ninguna duda, eres un __rojo-maniaco listillo certificado!__\n\n## Más Información\nHay un par de artículos en esta web que pueden darte pistas de cómo seguir a partir de aquí.","load_code":"def ruby(f);puts \"Ve a www.ruby-lang.org para descargar Ruby\";end;class K;attr_reader :rb;end;mi_primer_programa=K.new"}}