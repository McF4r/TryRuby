{"1":{"lang":"MK","title":"Имаш 30 минути? Започни со програмирање во Ruby веднаш!","chapter":"Y","answer":"","ok":"","error":"","text":"Ruby е програмски јазик од Јапонија кој го револуционизира софтверскиот развој.\n\nУбавината на Ruby е во неговиот баланс помеѓу едноставноста и моќта.\n\nМожеш да пишуваш Ruby код во едиторот и можеш да ги користиш овие копчиња за навигација:\n\n- __Run__ &rarr; Го извршува кодот напишан во едиторот\n- __Copy__ &rarr; Го копира пример кодот напишан во едиторот\n- __Next__ &rarr; Те носи на следната лекција\n- __Back__ &rarr; Ти дозволува да се вратиш на претходната лекција\n- __Clear__ &rarr; Го брише кодот од едиторот\n\nКористи го **world** копчето <span aria-hidden=\"true\" class=\"glyphicon glyphicon-globe\"></span>\nпогоре за да го смениш јазикот на TryRuby.\n\n### Кликни __Next__ да започнеш со учење.","load_code":""},
"2":{"lang":"MK","title":"Користење на едиторот","chapter":"N","answer":"^\\d{1,}$","ok":"Одлично! Употреби малку математика. Примети ли како одговорот се прикажа одма?","error":"Напиши 2 + 6 во едиторот","text":"Едитор (анг. **Editor**) прозорецот во долниот десен агол е место за твојот Ruby код. Кликни на __Run__  копчето за го извршиш кодот!\n\nМожеш да започнеш со малку математика. На пример:\n\n    2 + 6\n\nРезултатот на твојата програма треба да се прикаже во прозорецот за резултат (анг. **Output**), сместен во горниот десен агол.\nТаму исто така треба да има бројка која ти покажува кој е резултатот од кодот.\n\n> Како алтернатива, можеш да кликнеш на __Copy__ за да го ископираш код примерокот во едиторот.","load_code":""},
"3":{"lang":"MK","title":"Броеви и Математика","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Одлично","error":"","text":"Ruby препознава броеви и математички симболи. Можеш да пробаш и други операции, како:\n\n    4 * 10\n    5 - 12\n    30 / 4","load_code":""},
"4":{"lang":"MK","title":"Со други зборови","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Супер направено","error":"","text":"Дали забележа дека доколку напишеш повеќе од една формула ќе го видиш само резултатот од последната напишана линија код.\nШто се случува?\n\n> Со цел да ја направиме оваа веб страна полесна за користење му посочив на Ruby да го ископира резултатот од твојата програма во\n> **Output** прозорецот на врвот. Па така, кога ќе напишеш формула, исто така ќе имаш можност да го видиш и резултатот.\n> __Но, само последниот резултат.__ И само ако резултат прозорецот е сеуште празен.\n\nПа така, кога внесе 2 или повеќе формули, Ruby го прикажа само резултатот од последната формула.\n\nСе разбира ти можеш да го контролираш резултатот! Само напиши __puts__ пред секоја формула \n(со празно место помеѓу нив). Puts значи: *'прикажи (стави) нешто на екранот'*.\n\nПробај го следново:\n\n    puts 4 * 10\n    puts 5 - 12\n    puts 30 / 4\n\nСега отстрани го зборот puts од послената формула и види што ќе се случи.","load_code":""},
"5":{"lang":"MK","title":"Кажи ни го твоето име","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Совшрено, ти формираше стринг од буквите на твоето име","error":"","text":"Секако, компјутерите се корисни и брзи во математика. Ајде да продолжиме. Сакаш да го видиш твоето име напишано во обратен редослед? \n\nПрво напиши го твоето име во наводници, како во примерот:\n\n    \"Jimmy\"","load_code":""},
"6":{"lang":"MK","title":"Кажи ни го твоето име во обратен редослед","chapter":"N","answer":"\\w+","ok":"репуС","error":"","text":"Стрингот (анг. **String**) е сет од карактери кои компјутерот може да ги процесира. Замисли дека буквите се обесени на жица за алишта и наводниците се штипалки кои ги држат краевите. Наводниците го означуваат почетокот и крајот. \n\nЗа да го видиш твоето име во обратен редослед, напиши го следното:\n\n    \"Jimmy\".reverse\n\n(Немој да ја заборавиш точката!)","load_code":""},
"7":{"lang":"MK","title":"Броење на Букви","chapter":"N","answer":"^\\d+$","ok":"Да. Length е исто така 'метод'","error":"","text":"Го искористи reverse __методот__ за твоето име! Со ставање на твоето име во наводници ти направи стринг. Потоа, го повика \nreverse методот, кој фунцкионира за стрингови и ги подредува буквите во обратен редослед.\n\nСега, ајде да видиме од колку букви се содржи твоето име:\n\n    \"Jimmy\".length","load_code":""},
"8":{"lang":"MK","title":"Повторувања","chapter":"N","answer":"(\\w+)","ok":"Мило ми е што те запознав.Мило ми е што те запознав.Мило ми е што те запознав.","error":"","text":"Сега, сигурно се прашуваш за што служи сето ова.\n\nПа, сигурно си посетил страна која скоро и да викала, __Извинете, вашата лозинка е премногу кратка!__\n\nГледаш, некои програми користат многу едноставен __.length__ код.\n\nПогледни го ова. Ајде да го помножиме твоето име со бројот 5.\n\n    \"Jimmy\" * 5","load_code":""},
"9":{"lang":"MK","title":"Резиме на делот #1. Толку брзо?!","chapter":"Y","answer":"NoMethodError|undefined","ok":"Не, не е можно да го прикажеш бројот во обратен редослед. Кликни 'Next'","error":"","text":"Ајде да погледнеме што сѐ научи во овие неколку воведни минути.\n\n### Едитор\nПишувањето на код во едиторот и кликање на копчето Run ти го дава одговорот во прозорот насловен  Output (мкд. резултат).\n(Скоро) секој код дава некаков резултат/одговор.\n\n### Броеви и стрингови\nБроевите и стринговите претставуваат математички и текст објекти во Ruby.\n\n### Методи\nТи користеше методи чие име е блиско на Англискиот-јазик, и тоа: reverse и length. И симболички методи како што е\nметодот за множење: \\* \n__Методите значат извршување на некаква активност!__\n\nОва е основата за твоето учење. Земање на едноставни работи, манипулирање со нив и нивна трансформација во \nнови работи. Се чувствуваш комфортно, нели? Ти ветувам дека си.\n\n## Во ред,\nАјде да направиме нешто некомфортно. Пробај да го прикажеш бројот во обратен редослед.\n\n    40.reverse","load_code":""},
"10":{"lang":"MK","title":"Стоп, ова е апсурдно!","chapter":"N","answer":"^\\d{1,}$","ok":"Само стринговите можат да бидат прикажани во обратен редослед","error":"","text":"Не можеш да го прикажеш бројот четириесет во обратен редослед. Можеш да го држиш мониторот пред огледало, но прикажување на број во обратен редослед едноставно нема смисла. \n\nRuby прикажа порака која ја објаснува грешката. Преку таа порака, Ruby ти кажува дека нема метод наречен reverse за броеви.\n\nМожеби ако прво го модифицираш бројот да биде стринг:  \n\n    40.to_s.reverse","load_code":""},
"11":{"lang":"MK","title":"Јаболката се различни од портокалите","chapter":"N","answer":"\\[\\]","ok":"Одлично, ова е празна листа","error":"","text":"И броевите се различни од стринговите.\n\nИако можеш да користиш методи врз било кој објект во Ruby, сепак некои методи единствено функционираат само за одредени типови.\nНо, секогаш можеш да извршиш конверзија помеѓу разни типови користејќи ги **to** методите во Ruby.\n\n- __to_s__ врши конверзија во стрингови (__s__ trings)\n- __to_i__ врши конверзија во цели броеви (__i__  ntegers)\n- __to_a__ врши конверзија во низи (__a__ rrays)\n\n__Што се низи?!__\n\nНизите се листи. Напиши пар од загради:\n\n    []","load_code":""},
"12":{"lang":"MK","title":"Чекање во ред","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Одлично","error":"Пробај да додадеш четврти број во низата","text":"Низите (листите) чуваат работи __во одреден редослед__.\n\nКако стоење во ред за пуканки. Ти си позади некој, и не ни помислуваш да го истуркаш на страна,\nнели? Исто, ја приметуваш личноста која стои позади тебе, нели?\n\nЕве листа за тебе. Броеви за лотарија: \n\n    [12, 47, 35]\n\nПробај да додадеш уште еден број во низата: стави запирка после 35 проследена со некој број. Празното место е опционално.","load_code":""},
"13":{"lang":"MK","title":"Некој нека крене рака","chapter":"N","answer":"^47$","ok":"Супер","error":"","text":"Низа со броеви за лотарија. Кој од нив е најголем?\n\nПробај го следново: \n\n    [12, 47, 35].max","load_code":""},
"14":{"lang":"MK","title":"Совладување на низи","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Зачувано!","error":"","text":"Ова е супер. Но, сигурно е здодевно да ја пишуваш повторно и повторно истата низа секогаш кога ќе ти притреба, нели?\n\nАјде да ги зачуваме броевите внатре во **ticket**, како во примерот:\n\n    ticket = [12, 47, 35]","load_code":""},
"15":{"lang":"MK","title":"Сега, напиши Ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Низата е уште тука!","error":"","text":"Сега, напиши\n\n    ticket","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"MK","title":"Зачувано и складирано","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Ти ја подреди листата","error":"","text":"Сѐ до сега се придржуваше до твоите лото броеви, ставајќи ги во __променлива__ (анг. variable), наречена ticket.\nНо и било кое друго име, како _jimmyslist_, можеш да ставиш и би било валидно исто така.\n\nВо програмирањето, ќе откриеш дека најголем дел се состои во работа со променливи.\n\nАјде да ги подредиме твоите лото броеви во редослед, може?\n\nНапиши: \n\n    ticket.sort!\n\nИмаше низа. Ја подреди низата. Сега променливата ticket е изменета.\nДали примети дека _sort!_ методот има голем впечатлив извичник на крајот?\nЧесто методите во Ruby имаат извичник ако сакаат да извршат промена врз истата променлива.\nНема ништо посебно во тоа, тоа е само знак.","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"MK","title":"Елементарно","chapter":"N","answer":"^(12|35|47)$","ok":"ОК","error":"Скоро до целта","text":"Па, ги зачувавме нашите лото броеви во променливата ticket. Како сега да ги извадиме повторно надвор?\n\nВеќе видовме дека можеме да го извадиме најголемиот број од низата со методот __max__. Слично, можеш да \nго извадиш __првиот__ или __последниот__ елемент од низата.\nНо, што ако сакаш да извадиш некој конкретен елемент?\n\n### [ ]\nRuby користи [ ] загради за да таргетира елемент.\nЗаградите се многу чести во Ruby.\nТие се како знаци кои се користат за да пронајдеш мета. Буквално.\nТие загради значат, \"Јас барам ____\". Подготвен, нишани!\n\nАјде да ги издвоиме сите лото броеви:\n\n    puts ticket[0]\n    puts ticket[1]\n    puts ticket[2]\n\nЗошто користиме [0], [1], [2]?\n\nА не користиме [1], [2] и [3]? Да не е ова некаква Јапонска Зен работа?\nНе, ние компјутерџиите сакаме да започнеме со броење од нула. Тоа всушност не е само во Ruby,\nиндексирањето _базирано на нула_ се користи во повеќето програмски јазици.\n\n> Мало потсетување: можeш да го користиш __Copy__ копчето за да го копираш код примерокот во едиторот.","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"MK","title":"Резимето на делот #2 е тука","chapter":"Y","answer":"\\w+","ok":"Се римува ли?","error":"","text":"Сега, погледни како твојата втора минута помина:\n\n### Грешки (анг. Errors)\nДоколку пробаш да прикажеш број во обратен редослед или да направиш нешто некоректно, Ruby ќе ти укаже на тоа.\n\n### Низи (анг. Arrays)\nНизите се листи кои зачувуваат работи во некаков редослед.\nЗнаеме како да креираме низа и како да извадиме елементи од низата.\n\n### Променливи (анг. Variables)\nПроменливите зачувуваат работи и им даваат име. Го употреби знакот за еднакво за да го направиш тоа. На пример,\nticket = [14, 37, 18].\n\n### 2/8\nСѐ на сѐ има 8 секции. Ти си две-осмини од целта. Ова се прилично едноставни работи, нели? \nУште подобри работи следат!\n\nАјде да смениме насока за момент. Зачував поезија за тебе во одредена променлива.\nПогледни. Напиши:\n\n    puts poem","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"MK","title":"За жал, Toast поезијата не ти се допаѓа","chapter":"N","answer":"(toast){0}","ok":"Прекрасно","error":"Сеуште ми мириса на toast мене","text":"Види, во ред е. Не мора да ти се допаѓа. Промени го, ако баш и сакаш. Наместо toast, оди по \nлубеница или нешто друго. Пробај го следново за да ја видиш новата поема:\n\n    poem.gsub(\"toast\", \"honeydew\")\n\n__gsub__ методот е скатено за глобална замена (анг. **global substitute**). Ги заменува сите прикажување на \"toast\" со\n\"honeydew\".","load_code":"prev"},
"20":{"lang":"MK","title":"Подготвен, нишани","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"Во ред. Целата поема е прикажана во обратен редослед.","error":"","text":"Прашање: што ќе се случи кога ќе ја прикажеме во обратен редослед целата поема?\n\n    poem.reverse","load_code":"prev"},
"21":{"lang":"MK","title":"Премногу пресврти","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"Да, скоро до тоа што го посакуваме","error":"","text":"Значи, целата поема е прикажана во обратен редослед, буква по буква. Јас само сакав да ги прикажам \nредиците во обратен редослед.\nДа ги променам местата на последната редица со првата.\n\nДа наназад, но не __толку__ назад.\n\nЕве како:\n\n    poem.lines.reverse","load_code":"prev"},
"22":{"lang":"MK","title":"Прстени од врзување на методи","chapter":"N","answer":"^More still did (.+)","ok":"Добра претстава, мој пријателе!<br/>join методот ја зеде низата од редици стихови и ги спои сите заедно во стринг.","error":"","text":"Па, што гледаш? Што се случи таму? Ти напиша __poem.lines.reverse__ и што се случи?\n\nСе случија две работи. Ти ја претвори поемата во низа со помош на редовите стихови.\nРедовите стихови одлучија на кој начин стрингот ќе биде поделен и го претвори во Низа.\n\nПотоа, ја прикажа низата во обратен редослед. Ја имаше секоја редица стих. Ги прикажа во обратен редослед. И, тоа е тоа.\n\nАјде да додадеме уште еден метод на крајот:\n\n    puts poem.lines.reverse.join\n\nКомбинирањето, односно врзувањето на методи на ваков начин е наречен _method chaining_.","load_code":"prev"},
"23":{"lang":"MK","title":"Од вкупниот број на Резимеа, #3 е тука","chapter":"Y","answer":"\\{\\}","ok":"Одлично! Ти направи празен hash!","error":"","text":"###  Извичници\nМетодите можат да содржат извичници (и прашалници) во нивното име.\nТоа е само заради подобро објаснување на нивната функционалност. Ништо страшно.\n\n### Манипулација на стрингови\nПребарување и промена на стрингови\n\n### Поврзување (анг. chaining)\nПоврзувањето на методи помага кога треба да извршиш повеќе операции врз еден објект. Можеш: да ја поделиш поемата, да ја прикажеш во обратен редослед, и на крај па пак да ја склопиш:\n__poem.lines.reverse.join__\n\nВо овој момент, можеби сакаш уште да си играш со поемата. Комплетната листа со методи за \nманипулација со Стрингови можеш да ја најдеш <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">тука</a>.\n\n\nПовели и пробај нови методи, како на пример: __poem.downcase__ или __poem.swapcase__\n\n## Подготвен?\nКога ќе се почувствуваш спремен за следната лекција, напиши:\n\n    books = {}","load_code":"prev"},
"24":{"lang":"EN","title":"Мала празна книга","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Да, ти само што додаде нов ранг","error":"Use one of splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>Don't forget the colon","text":"Креираше празен __hash__. Нash-от е како низа, со таа разлика што секој од елементите во hash-от има име.\n\nЌе направиме минијатурни оцени за книгата во нашиот нов hash. Ова е нашиот систем за рангирање:\n\n- :splendid &rarr; ремек-дело\n- :quite\\_good &rarr; релативно добра\n- :mediocre &rarr; ист број на добри и лоши делови\n- :quite\\_not\\_good &rarr; релативно лоша\n- :abysmal &rarr; премногу лоша\n\nЗа да рангираш книга, стави го насловот во __[ ]__ наводници и стави го рангот после знакот за еднакво. На пример,\n\n    books[\"Gravitys Rainbow\"] = :splendid\n\n> Бидејќи стигна до тука, фер е да ти кажам дека сите лекции во TryRuby се одвоени една од друга.\n> Па така, ако се разигра со рангирањето на книги, шансата ти е само во оваа лекција.\n> Доколку сакаш да ги користиш твоите рангирања во наредната лекција, мораш да им направиш copy/paste.\n> Не грижи се за ова премногу, секоја лекција има многу предефинирани работи со кои можеш да играш.","load_code":"books = {}"},
"25":{"lang":"MK","title":"Уште оцени!","chapter":"N","answer":"[3-9]","ok":"Само што откри дека методот length одговара за стрингови, низи и hash-ови","error":"","text":"Продолжи со одличната работа и наполни ги книгите со оцени. И, ако сакаш да ја видиш целата листа само напиши: __puts books__ \n\nИ повторно, рангирањето е: :splendid, :quite\\_good, :mediocre, :quite\\_not\\_good and :abysmal.\n\nОвие рангови не се стрингови. Кога ќе ставиш две-точки **:** пред прост збор, добиваш __симбол__.\nСимболите се „поевтини“ од стринговите (во конотација на компјутерска меморија). Доколку сакаш да користиш еден збор на повеќе места во твојата програма, користи симбол. Наместо да имаш илјадници копии од истиот збор во меморија, компјутерот ќе го зачува симболот само __еднаш__.\n\nУште поважно, симболот ти кажува дека не е само било кој стар збор, туку има значење во твојата програма.\n\nВнеси уште 2 оцени за книги, и напиши __books.length__ за да видиш колку оцени има во hash-от:\n\n    books[\"The deep end\"]  = :abysmal\n    books[\"Living colors\"] = :mediocre\n    \n    puts books\n    \n    puts books.length","load_code":"books = {\"Gravitys Rainbow\" => :splendid}"},
"26":{"lang":"MK","title":"Чекај малку, ја оценив ли книгата Gravity's Rainbow?","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Многу ми се допаѓа","error":"","text":"Една од прекрасните работи во Ruby е тоа што имињата се често повторно употребливи, а тоа значи помалку имиња за паметење.\n\nСе сеќаваш ли како издвојувавме елементи од низа, со користење на број:  \n__puts ticket[1]__.\n\nКај hash-от ова фунцкионира на ист начин, со таа разлика што кај hash-от не користиме број за да го издвоиме елементот, туку користиме име.\n\nПа така, ако сакаш да издвоиш некој од твоите постари оцени, повторно стави го насловот во __[ ]__ наводници. Но, изостави го знакот за еднакво.\nИсто како во примерот:\n\n    puts books[\"Gravitys Rainbow\"]","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre}"},
"27":{"lang":"MK","title":"Hash-овите како Парови","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Ги пронајде клучевите","error":"","text":"Имај на ум дека hash-овите не ги чуваат работите во редослед. Тоа не е нивна работа. Нивната работа е \nсамо да направат пар од две работи: __клуч__ (анг. key) и __вредност__ (анг. value).\n\nВо твоите оцени, името на книгата претставува клуч, а рангот претставува вредност.\n\nДоколку сакаш да ги видиш само насловите од сите книги што си ги оценил, напиши:\n\n    books.keys\n\nМожеш да го пробаш истово и со .values, наместо со .keys.","load_code":"prev"},
"28":{"lang":"MK","title":"Дали си строг при оценувањето на книгите?","chapter":"N","answer":"\"mediocre\"","ok":"Одлично, браво! Ти само што направи карта со твои оцени.","error":"","text":"Даваш строги, нефер оцени? Ајде, да го зачуваме резултатот во нов hash __ratings__:\n\nПотоа, може да ги изброиме твоите оцени. Остани со мене. Напиши:\n\n    ratings = Hash.new {0}\n    \n    books.values.each { |rate|\n      ratings[rate] += 1\n    }\n    \n    puts ratings\n\n\nПравата линија во кодот се вика **pipe character**, која најверојатно се наоѓа над копчето Enter\nна твојата тастатура.\n\nДелот **+= 1** од код линијата **ratings[rate] += 1** значи: зголеми ја вредноста за 1.\n\nНе грижи се ако не разбираш сѐ што се случува тука. Ќе ти биде јасно подоцна.","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre, \"Bumblebees\" => :mediocre}"},
"29":{"lang":"MK","title":"Сума","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"Една од прекрасните нови работи кои сега ги искористивме е __блокот__ (анг. block). Ќе дознаеш повеќе за ова и во следната лекција. Но, во основа, блокот е мал Ruby код опкружен со __{ }__ наводници.\n\nАјде да пробаме друг блок:\n\n    5.times { print \"Odelay! \" }\n\nБлоковите се секогаш поврзани за методи. Како кај __times__ методот, кој го зема блокот и го извршува\nодново и одново. (Во нашиот пример, пет пати.)","load_code":""},
"30":{"lang":"MK","title":"Дали имаш уште време?","chapter":"N","answer":"^[0-9]$","ok":"Одлично го примени .times методот!","error":"Изврши го кодот во блокот 0 до 9 пати","text":"Како што видовме во првиот пример со блок (при броењето на рангови) може да испратиш вредност (анг. value) на блокот. \nКои вредности се __испратени__ е одредено со методот кој го управува блокот.\n\nВредностите кои се __примени__ од блокот се сместени во променлива, која се испраќа на почетокот на блокот,\nпомеѓу два симболи: __|име на променлива|__\n\nАјде да го пробаме тоа во следниов блок:\n\n    5.times { |time|\n      puts time\n    }\n\nТука, методот __.times__ праќа вредност на променливата __|time|__. При тоа, запомни дека променливата time е валидна само \nво рамки на блокот.\n\n> Примети ли дека можеш да го делиш кодот на повеќе линии. Тоа го прави полесен за читање.","load_code":""},
"31":{"lang":"MK","title":"Стигнавме до Резиме #4","chapter":"Y","answer":"","ok":"","error":"","text":"Последнава лекција беше малку подолга. Најверојатно ти требаа три минути за да научиш:\n\n### Hash-ови\nСиноним за малиот речник (анг. dictionary) со округли страни: __{ }__\n\n### Симболи (анг. symbols)\nМал, ефективен код од зборови, пред кои се ставаат две-точки, како: __:splendid__\n\n### Блокови (анг. blocks)\nДелови код кој може да се прикачи на многу методи во Ruby. Следниот код го искористи за да го зачуваш резултатот: \n__books.values.each { |rate| ratings[rate] += 1 }__\n\n### Следно\nВо следната лекција ќе учиме подетално за методи.","load_code":""},
"32":{"lang":"MK","title":"Да се биде или не","chapter":"N","answer":"","ok":"","error":"","text":"Другата работа за која до сега немавме шанса да ја разгледаме се: аргументите, односно параметрите (анг. parameters), во методите.\nСе сеќаваш кога ја изменивме пемата? Користевме:\n__poem.gsub(\"toast\", \"honeydew\")__\n\ngsub-методот има два агрументи кои ги пративме преку два стрингови одделени со запирка, во загради.\n_Аргументите им кажуваат на методите што точно да прават._\n\n### Загради\nВсушност, за многу од методите во Ruby не се задолжителни заградите, па дури и да ги испуштиш некаде методот ќе функционира. Па така, следниот код ќе функционираше и вака:\n__poem.gsub \"toast\", \"honeydew\"__\n\nИсто така, искористивме и друг метод со параметри. Всушност, многу пати искористивме параметри иако не беше \nмногу очигледно:\n\n    puts \"Hello\"\n    puts(\"Hello\")\n\nДа, __puts__ исто така е метод. Дали ќе користиш загради или не кога го применуваш методот puts, за\nRuby е исто, со таа разлика што верзијата без загради е малку полесна за читање. И ти заштедува значително време\nво пишувањето на кодот!\n\n> Па, сметам дека заклучокот е дека можеш да правиш што сакаш со заградите се додека твојот код\n> се чита убаво.\n\n### Да се биде или не / to (be) or not to (be)\nЗначи, ако _to_ е метод и _be_ е параметар сега знаеме како да одговориме на прашањето старо со години.\nНавистина станува збор само за лична преференција дали сакаш да биде _to be_ или _to(be)_.\n\nДали си расположен за Шекспир? Продолжи со читање.","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nYada yada yada\\n\""},
"33":{"lang":"MK","title":"Припитомување на итрицата (Шекспирово дело)","chapter":"N","answer":"^tame","ok":"Многу добро!","error":"","text":"Сега знаеш многу добро како да го користиш програмскиот јазик Ruby. Мислам, ги помина основите.\nСега, треба само да продолжиш да изучуваш што повеќе методи и да пробуваш што повеќе комплекси блокови.\n\nНо, има една страна од Ruby за која не зборувавме. Дефинирање на твои методи.\n__Точно така!__ Ајде да ги совладаме и нив.\n\n\nПокрај тоа што можеш да ги користиш веќе дефинираните Ruby методи (како puts, sort, times), можеш\nда дефинираш твои методи. Зошто тоа е добра идеја? Две причини:\n\n### Да си ја направиш програма пократка\nАко една иста работа ти се повторува во повеќе делови од твојот код, полесно е\nистиот тој код да се стави во посебен метод. Твојот код ќе биде пократок.\n\n### Твојот код ќе биде лесен за читање\nПретпостави си дека твојата програма треба да прави многу различни работи.\nДа, ти __можеш__ да го ставиш кодот во една целина. Но, ќе биде многу тешко \nза разбирање и читање на истиот код подоцна.\n\nНаместо тоа, можеш да го поделиш кодот на повеќе методи, при тоа да му дадеш\nиме од Англискиот јазик кое ќе биде лесно за разбирање. Ќе бидеш благодарен на себе за тоа подоцна.\n\nПа, како дефинираме метод? Како во следниот пример:\n\n    def tame( number_of_shrews )\n    end","load_code":""},
"34":{"lang":"MK","title":"Во Ruby, def leppard значи: дефинирање на метод со име Leppard","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"Одлично! Веќе дефинираш твои методи. Започна со def, па следува името на методот.\nИ листа со параметри кои ќе му бидат потребни на самиот метод. Ова не е ништо страшно ниту пак опасно!\nСѐ што треба да направиш е да го пополниш методот со Ruby код и на крај да го ставиш резервираниот (анг. reserved) збор end.\n\nОва е кодот:\n\n    def tame( number_of_shrews )\n      number_of_shrews.times {\n        puts \"Tamed a shrew\"\n      }\n    end\n    \n> __П.С.__  \n> Доколку не го сфати насловот на оваа лекција,\n> <a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\n> е име на некогаш познатиот Англиски рок бенд.","load_code":""},
"35":{"lang":"MK","title":"Зрелите плодови на твојата креација","chapter":"N","answer":"^Tamed a shrew","ok":"That'll show those shrews","error":"","text":"Нов метод е дефиниран. Ајде сега да го примениме:\n\n    tame 5","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"MK","title":"Дај и земи","chapter":"N","answer":"\\d+","ok":"Само така. Браво.","error":"","text":"Повеќето методи не само што бараат некои параметри како инпут (анг. input), туку и ќе дадат __нешто назад__.\nНаправив мала измена во методот со цел да ти врати некоја вредност. Пробај:\n\n    def tame( number_of_shrews )\n      number_of_shrews.times {\n        puts \"Tamed a shrew\"\n      }\n      return number_of_shrews\n    end\n\n    puts tame(3)\n\n### Return\nПа, бидејќи си толку способен и напреден, повели уште еден совет:\nможеш да го испуштиш клучниот збор __return__ од последната линија код во методот.\nRuby автоматски ќе ја врати последната вредност што се употребила во методот.\n\nПа така, последната линија код може да се прикаже вака: __number\\_of\\_shrews__.\n\nНо, бидејќи методот __.times__ исто така ќе го врати _бројот на shrews_ може да\nја избришеме целата последна линија. Всушност, оригиналниот метод веќе го направи тоа што го баравме цело време!","load_code":""},
"37":{"lang":"MK","title":"Здраво, кој е таму? Тука е Резимето #5!","chapter":"Y","answer":"","ok":"","error":"","text":"Многу добро сторено, многу добро сторено, многу добро сторено, многу добро сторено!\n\n\nНавистина, навистина, навистина, навистина, навистинаааааа!\n\nОва се последните минути од твојот живот во ретроспектива:\n\n### Методи\nМетодите се дефинираат со резервираниот збор __def__ и имаат име. Методите ја прават твојата\nпрограма пократка и полесна за читање.\n\n### Параметри\nМетодите може да имаат параметри.\n\n### Return вредности\nМетодите (скоро) секогаш враќаат вредност.\n\n## Сега\n_Да се биде или не_ не е повеќе прашање за тебе. Дали си подготвен за прикажување \nповеќе од Шекспир?","load_code":""},
"38":{"lang":"MK","title":"Светот е нашата школка (Извадок од Шекспирово дело)","chapter":"N","answer":"^\\{\\\"William","ok":"Добро. Малку потешко за читање.","error":"","text":"Сѐ до сега извршувавме програми кои користат работи што сами ги пишувавме.\nШто е добро, иако _Odelaying_ беше епска, ова е интернет ера и е веќе време да го приклучиме \nостатокот од светот во нашите напори за програмирање.\n\nМногу, многу, многу веб страни се достапни за да ги прашаш за одредени информации. На пример,\nследниот линк ќе ти ги даде сите моментални <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">новости на Google</a> поврзани со Ruby.\n\nТвојот веб прелистувач најверојатно ќе ти ги прикаже во средена верзија за тебе. \nАко погледнеш во изворот (type: control-U)\nќе видиш долг стринг формиран од чудни карактери. Примерот на Google е во __rss__ формат.\n\n### Формати\nИма многу други формати, со чудни имиња, кои се достапни и се користат на веб, како:\nhtml, xml и json. Да, дури и оваа веб страна користи некои од нив.\n\nПодготвив метод за тебе кој, ќе земе и ќе достави низа со комплетната работа на \nВилијам Шекспир од интернет.\n(Не грижи се, најверојатно доаѓа од истиот сервер на кој што оваа веб страна работи, \nпа така не досадуваме на никого.)\n\nПреземи ги податоците со следната команда:\n\n    get_shakey","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"MK","title":"Двајцата благородни земјаци","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Ова е многу подобро","error":"","text":"Супер, сега имаме низа со претстави од интернет. Оваа низа е во json формат.\nЗа наша среќа, Ruby има метод со кој ќе направиме конверзија на json податоците во hash.\nМетодот _get\\_shakey_ веќе го направи тоа за нас.\n\nБидејќи структурата на json податоците е ставена во hash, сеуште е потешка за читање.\nАјде да напишеме метод со кој ќе ги прикажеме претставите во читлив формат.\n\n\nДоколку направиш инспекција на низата од претстави, ќе забележиш дека има вградена структура.\n(Ова всушност е многу честа појава кај податоци кои ги преземаш од интернет.)\nИзгледа како во примерот:\n\n<ul>\n  <li>\"William Shakespeare\"\n  <ul>\n      <li>\"1\"\n      <ul>\n        <li>\"title\": \"The Two Gentlemen of Verona\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>\"2\"\n      <ul>\n        <li>\"title\": \"The Taming of the Shrew\"</li>\n        <li>\"finished\": 1591</li>\n      </ul>\n      </li>\n      <li>...</li>\n  </ul>\n  </li>\n</ul>\n\nСо цел да ги прикажеме претставите, прво треба да пристапиме до најгорниот hash елемент \"William Shakespeare\" преку неговото име.\nПотоа треба да __поминеме__ низ секој елемент под него.\n\nRuby има метод за повторување. Се вика __each__. Овој метод го сретнавме кога креиравме\nсопствен рејтинг систем за книги.\n\nСѐ што методот __each__ враќа се испраќа во блок:\n\n    s = get_shakey\n    \n    s[\"William Shakespeare\"].each { |key, val|\n      puts val[\"title\"]\n    }","load_code":"prev"},
"40":{"lang":"MK","title":"Сите заедно сега","chapter":"N","answer":"^4$","ok":"Да, Шекспир напишал 4 претстави во 1591","error":"Одговорот за годината 1591 треба да биде 4","text":"Сега претпостави дека сакаме да ги знаеме имињата и бројот на претстави напишани\nод Шекспир само за одредена година.\n\nRuby ни дозволува да __селектираме__ вредности од hash. Методот select користи блок преку кој\nни дозволува да дефинираме што сакаме да селектираме и ни го враќа она што го пронашол.\n\nПотоа, може да го искористиме резултатот добиен од __select__  методот во __each__ методот (како претходно) со тоа што ќе го додадеме после select блокот. Ова е друг пример за поврзување на методи,\nкој го сретнавме претходно кога ја прикажувавме поемата во обратен редослед.\n\nГо подготвив методот __count\\_plays__ за тебе. Пробај да видиш дали можеш да најдеш колку претстави\nсе напишани од Шекспир во годината __1591__. Пробај го следново:\n\n    def count_plays(year)\n      s = get_shakey\n      \n      s[\"William Shakespeare\"]\n        .select { |k, v|\n          v[\"finished\"] == year\n        }.each { |key, val|\n          puts val[\"title\"]\n        }.count\n    end\n    \n    puts count_plays(0)\n\n\nДали забележа дека го поврзав count методот на крајот на секој each метод. Ова ни ја враќа\nвредноста од _count\\_plays__ методот.\n\nТука, има и друга можност за поврзување на методи. Ја гледаш таа осамена линија код __s = get_shakey__.\nМожеш да додадеш __[\"William Shakespeare\"].select { |k, v|__ на крајот од get_shakey\n(не е потребно за овој случај).","load_code":"prev"},
"41":{"lang":"MK","title":"Сѐ е добро штом добро ќе заврши","chapter":"N","answer":"Сѐ е добро штом добро ќе заврши","ok":"True","error":"Стави 1605 како втор параметар","text":"Добро, имаме податоци од интернет, селектиравме што сакавме и ги прикажавме резултатите.\nШто остана за подобрување? Може да ги прикажеме резултатите во подобра верзија. Како на пример\nда ја додадеме годината и да ги израмнеме насловите и годините.\n\nТоа значи прикажување на неколку вредности во една линија. Ruby има елегантен начин\nза тоа. Тоа е исто како прикажување на стринг: __puts \"Hi, my name is Jimmy\"__.\nНо, наместо да ја користиме буквалната вредност _Jimmy_, ние ќе ја користиме вредноста на променливата.\n\nПрво, замени го __Jimmy__ со __#{}__. Ако Ruby забележи дека имаш hash симбол проследен со { } наводници\n{ бара променлива која се наоѓа меѓу отворената заграда и затворената заграда }.\nТака, може да се искористи следното: __\"Hi, my name is \\#{name}\"__.\n\nАјде малку да го промениме кодот\n\n    def print_plays(year_from, year_to)\n      get_shakey[\"William Shakespeare\"]\n        .select { |k, v|\n        year_from <= v[\"finished\"] &&\n        year_to   >= v[\"finished\"]\n      }.each { |k, v|\n        puts \"#{v[\"title\"].ljust(30)} #{v[\"finished\"]}\"\n      }\n    end\n    print_plays(1600, 1605)\n\nДодадов __.ljust(30)__ на насловот. На овој начин, насловот е порамент од лева страна (анг. _left justified_) со минимум 30 карактери\nза годината да се порамни убаво.\n\nЗначи, пробај да видиш дали ќе можеш да го промениш аутпутот на програмата за да ја прикаже претставата како во примерот:\n__1600 -> As You Like It__\n\n__Сѐ е добро штом добро ќе заврши?__ Не, сеуште не сме готови, но крајтот се гледа!","load_code":"prev"},
"42":{"lang":"МК","title":"Кога само би знаел како да донесам одлука","chapter":"N","answer":"","ok":"","error":"","text":"Донесувањето на одлуки (анг. decision making) во реалниот живот може да биде вистински проблем. Но не и за нас.\nRuby значително го олеснува донесувањето на одлуки.\n\n    if 1 < 2\n      puts \"Тоа е точно: 1 е помал од 2\"\n    end\n\nТука, резервираниот збор е __if__. Овој збор може да биде ставен пред некој метод или после него, како на следниов пример:\n\n    puts \"Тоа е точно: 1 е помал од 2\" if 1 < 2\n\n__If__ е метод кој бара еден параметар. Тој параметар може да биде било кој услов што сакаш да го тестираш. Резултатот од условот мора да биде или __true__ или __false__.\nТука имаме неколку примери на услови и нивните резултати:\n\n    5     <= 10     # => true\n    'abc' == 'def'  # => false\n    true            # => true\n    123456          # => true\n    0               # => true\n    nil             # => false\n    'xyz'.empty?    # => false\n    'a' > 5         # => error:\n                    # компарацијата на Стринг со\n                    # Број (анг. Numeric) не успеа\n\n _if_ условот може да има повеќе форми. Може да врши споредба на буквални вредности (1 < 2),\nпроменливи (a < 1) и на повратна вредност од метод ('xyz'.empty?).","load_code":""},
"43":{"lang":"МК","title":"И сега, зачудувачкиот крај","chapter":"N","answer":"не е еднакво 100$","ok":"Тоа е супер!","error":"Ова не може да биде точно","text":"Дали ги виде двата знаци за еднакво во изразот __'abc' == 'def'__?\n\nОвој знак __==__ значи: _е еднакво на_ (анг. __is equal to__).\nДодека, еден знак за еднакво, што го сретнавме и претходно, значи доделување вредност на променлива (анг. __assign a value to a variable__).\n\nЗа да биде уште позбунувачки, доделувањето на вредност може да се изврши и после if метод, како на пример:\n\n    a = 0\n    \n    if a = 100\n      puts \"Изразот е точен, но променливата a сега е: #{a}\"\n    else\n      puts \"#{a} не е еднакво на 100\"\n    end\n\nЗнакот за еднакво = промени го во == и види што ќе се случи.\n\nТи гарантирам дека често ќе забораваш да додадеш и втор знак за еднакво. И јас го заборавам понекогаш.\n\n### else\nВо кодот погоре јас додадов и else израз. Овој дел ќе се изврши кога резултатот од\n__if тест-изразот__ ќе биде неточен, односно false.\n\n> Има повеќе варијации на if-then-else тема. Можеш да прочиташ повеќе\n> <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">тука</a>.","load_code":""},
"44":{"lang":"МК","title":"Јас гладен","chapter":"N","answer":"^Јас не гладен","ok":"Yes","error":"Нема шанси да сум гладен во 10 часот наутро!","text":"Во ред, сѐ се вклопува одлично. Ова се едноставни работи за тебе, но запомни дека пред само 15 минути __немаше појма за Ruby__!\n\nПоследен чекор. Ајде да сврземе сѐ заедно, може?\n\nПрво ќе дефинираме два методи, а потоа ќе донесеме одлука:\n\n    def hungry?(time_of_day_in_hours)\n      puts \"Me hungry\"\n      true\n    end\n\n    def eat_an(what)\n      puts \"Me eat #{what}\\n\"\n    end\n\n    eat_an 'apple' if hungry?(14)\n\n    eat_an 'apple' if hungry?(10)\n\nСега, пробај да го смениш методот __hungry?__ да прикаже __\"Јас не гладен\"__ и да врати false кога времето е порано од 12 часот.","load_code":""},
"45":{"lang":"МК","title":"Резиме #6, што значи дека дојде многу далеку","chapter":"Y","answer":"\\{\\}","ok":"Во ред, тоа е празен hash","error":"","text":"Ти си на 6то ниво од Ruby туторијалот. Прекрасна работа заврши. Ајде да видиме:\n\n\n### Data\nВчита (анг. loading) податоци од интернет, разгледа структура на податоци (анг. data structure) и направи манипулација со избрани вредности.\n\n### Iterating\nТи минуваше (анг. iterating) низ сите елементи во hash-от и поврза некои методи.\n\n### Прикажување текст то читлива форма (анг. pretty printing)\nИ тоа не е сѐ, ти форматираше и прикажа вредности на начин кој е лесен за читање. Всушност, __ти направи вистинска програма!__\n\n### If\nНаучи како да ја контролираш твојата програма со __if__ и __else__ изрази.\n\n## Па..\nПа, што може да биде следно? Што може да се научи сега?\nОва е најдобриот дел. Ти помина толку голем пат, што ние ќе те запознаеме со Класи. Уште две кратки лекции и ти си готов!\n\nПретходно, ние креиравме hash како на примерот:\n\n    Hash.new","load_code":""},
"46":{"lang":"МК","title":"Not a School Class, a Working Class","chapter":"N","answer":"","ok":"","error":"","text":"Како што виде, празните загради {} се кратенка за Hash.new. Методот _new_ се користи за инстанцирање објекти\nод одредена класа (анг. Class). Размислувај за „класа“ како на „работничка класа“ &mdash; специфична група објекти кои \nсе слични меѓу себе, имаат иста работа, исти маици.\nОд каква корист е класата?\n\n### Blurbalizer<sup>TM</sup>\nТи само што добри брилијантна идеја за нова апликација. Тоа ќе биде следната инстант платформа за пораки.\nТи сакаш апликација каде луѓето можат да си праќаат едни на други кратки пораки. Овие пораки \nќе ги наречеме Blurbs<sup>TM</sup>. Еден Blurb<sup>TM</sup> ќе има максимална должина од само 40 карактери. \nИсто така ќе направиме перформанс за расположение (анг. mood setting). \n\n<!---The Internet has really brought back stick people and smileys out of bankruptcy. __Emote!__-->\n\n### Од каде да започнеш\nПа, една опција е твоите Blurbs<sup>TM</sup> елементи да ги ставиш во json фајл, нели?\nНо, како ќе водиш евиденција за содржината од елементот и времето кога е постиран?\nИ кога ќе го вчиташ фајлот, како ќе изгледа во Ruby?\nЌе биде Hash? Или низа? Или низа од низи? Или пак нешто друго?\n\n### Класа (анг. Class)\nЈас навистина мислам дека ќе сакаш да користиш класа. Ти си веќе запознаен со многу класи:\nHash, Array, String.\nАјде да креираме нова класа (која не враќа никаков резултат):\n\n    class Blurb\n    end","load_code":""},
"47":{"lang":"МК","title":"Работите кои ги сочинуваат апликациите","chapter":"N","answer":"","ok":"","error":"","text":"Ти отвори нова Blurb<sup>TM</sup> класа. Од што се состои твојот елемент?\nСодржина (анг. content), се разбира. Исто така, треба да го зачуваш \nвремето (анг. time) кога Blurb<sup>TM</sup> е креиран. И, расположение (анг. mood).\n\nВо ред, веќе ја имаш првата линија код од класата, еве го остатокот:\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n    end\n\nИмето на класата секогаш започнува го голема буква.\n\n(Сеуште немаме резултат)","load_code":""},
"48":{"lang":"МК","title":"Accessors може да се споредат со екстремитетите на човечко тело","chapter":"N","answer":"Blurb:","ok":"Мојот прв Blurb","error":"","text":"Супер дефинирана класа, читателу. Ти сега имаш нова Blurb<sup>TM</sup> класа.\n\nПри дефинирање на класата, ти користеше метод наречен attr\\_accessor.\nИма многу __attr__ibute методи како на пример методот која додава мали преференци на класата.\nОвие атрибути (анг. attributes) се само променливи прикачени за класа.\n\nРазмислувај на овој начин. Класата е како човек. А, атрибутите се различните делови\nод кои е направено човечкото тело, како на пример рака чија една од функционалностите е \nракување со друг човек.\n\n### Сега\nЗа да креираш Blurb<sup>TM</sup> и да ставиш содржина погледни го примерот:\n\n    blurb1 = Blurb.new\n    puts blurb1\n    blurb1.content = \"Today Mount Hood Was Stolen!\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"МК","title":"Објект, тоа мало убаво пакување","chapter":"N","answer":"Blurb:","ok":"Blurb е ажуриран","error":"","text":"Те охрабрувам да пробаш да ставиш време и расположение на  Blurb<sup>TM</sup>:\n\n    blurb1.time = Time.now\n    blurb1.mood = :sick\n    \n    puts blurb1","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"МК","title":"Ајде малку да забрзаме","chapter":"N","answer":"^\\d{4}","ok":"Забележано","error":"","text":"Супер, твојата апликација е прекрасна. Ајде малку да ти ги олесниме работите.\nТи сигурно не сакаш да го ставаш времето на овој начин секогаш кога креираш или ажурираш Blurb<sup>TM</sup>.\n\nТи само сакаш да внесеш содржина и да го поставиш расположението, нели?\n\nАјде да додадеме __initialize__ метод на нашата класа. Овој метод се повикува секогаш кога е креиран нов Blurb<sup>TM</sup>.\nВо исто време може да ставиме лимит за должината на содржината на Blurb<sup>TM</sup> да биде 40 карактери.\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n\n      def initialize(mood, content=\"\")\n        @time    = Time.now\n        @content = content[0..39]\n        @mood    = mood\n      end\n    end\n    \n    Blurb.new.time\n\n(Параметарот __content=\"\"__ е тука за да нѐ потсетува дека содржината е од тип Стринг,\nиако параметер со содржина не е пуштен во initialize методот.)","load_code":""},
"51":{"lang":"МК","title":"Ти ја научи апликацијата да ги одбива непотребните работи","chapter":"N","answer":"Blurb:","ok":"Blurb е додаден","error":"","text":"Дали забележа дека внатре во класата ние користевме at-симболи (@time).\n\n__Надвор__ од класата, ние искористивме accessors:\n\n> __blurb.time = Time.now__\n\nно, __внатре__ ги користиме __променливите од објектот__:\n\n> __@time = Time.now__\n\nТие се едно исто, но прикажани на две различни места во твојата програма.\n\n### Креирај нов Blurb<sup>TM</sup>\nКога нов Blurb<sup>TM</sup> е креиран, initialize методот се користи за да провери дали има нови параметри.\n\nВо овој случај, нам ни требаат два параметри:\n\n    Blurb2 = Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"МК","title":"Жирафа не го украде Резимето #7","chapter":"Y","answer":"","ok":"","error":"","text":"Браво, успеа да стигнеш до тука. Твојата апликација ќе ја направиме да биде реална, но прво да направиме резиме, може? \n\n### Класи\nСѐ во Ruby е некаков вид на објект. Класите ги објаснуваат објектите, односно како тие функционираат.\nНа пример, ти направи неколку Blurb<sup>TM</sup> објекти и тие се објаснети во Blurb класата.\nСо други зборови: ние ги викаме Blurb објекти.\nМожеш да ги користиш класите за (речиси) да моделираш објекти од реалниот свет.\n\n### Accessors\nAccessors се променливи прикачени на објект кои можат да се користат __надвор__ од објектот.\n(blurb2.time = Time.now)\n\n### Објект променливи\nОбјект променливи се истите променливи што ти ги користиш како accessors, но __внатре__ во самиот објект.\n(@time = Time.now)","load_code":"prev;blurb2=Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"МК","title":"Твојата сопствена територија","chapter":"N","answer":"Blurbalizer:","ok":"myapp е креирана","error":"","text":"Тука може да ги привршуваме работите, читателу. Тука е последното поглавје од епската приказна на TryRuby!\nСега кога имаш ориентација како сѐ работи, како ќе ги искористиш за твојата куќа и за твојот замрзнувач? \nТи си прекрасна личност, дури и една од моите омилени, но сепак ти треба насочување.\n\n### Ајде да ја завршиме твојата апликација\nТи имаш елементи, но немаш вистинска програма.\nСеуште треба наслов, некое место за да ги зачуваме сите Blurbs<sup>TM</sup> и времеплов (анг. timeline) со цел да функционира.\n\nПогоди што? Ние ќе користиме уште една класа. Во следниот пример е прикажан целиот код од новата класа во една целина.\nДозволи си онолку време колку што ти треба за да го проучиш.\nЈас не сум во брзање, ќе те причекам во следната лекција. \n\n    class Blurbalizer\n      def initialize(title)\n        @title  = title\n        @blurbs = [] # Нова празна низа \n                     # за зачувување Blurbs\n      end\n      \n      def add_a_blurb(mood, content)\n        # Овој знак << значи додај го елементот на крајот од низата\n        @blurbs << Blurb.new(mood, content)\n      end\n      \n      def show_timeline\n        puts \"Blurbify: #{@title} has #{@blurbs.count} Blurbs\"\n        \n        @blurbs.sort_by { |t|\n          t.time\n        }.reverse.each { |t|\n          puts \"#{t.content.ljust(40)} #{t.time}\"\n        }\n      end\n    end\n    \n    myapp = Blurbalizer.new \"The Big Blurb\"","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"МК","title":"Што се работи во Blurb?","chapter":"N","answer":"Денес","ok":"Bring on the blurbs","error":"","text":"Одлично, пристина до уште една нова лекција! Дали сфати што прави кодот во  Blurbalizer<sup>TM</sup> класата?\n\n> Во Blurbalizer<sup>TM</sup> има два __методи__ (add\\_a\\_blurb and show\\_timeline).\n> Ти можеш да користиш метод надвор од класата, на ист начин како што направивме со accessors.\n\nВреме е да почнеме да ја користиме Blurbalizer<sup>TM</sup>. Јас веќе вчитав (анг. loaded) неколку \nBlurbs<sup>TM</sup> за тебе, но чувствувај се слободно да додадеш твои нови.\n\nНие сега не креираме Blurbs<sup>TM</sup> директно, туку користиме add\\_a\\_blurb __метод__ од \nBlurbalizer<sup>TM</sup> класата. На овој начин, може да се осигураме дека сите наши Blurbs<sup>TM</sup>\nсе зачувани во myapp објектот.\n\n    myapp.add_a_blurb :moody, \"Додај Blurb тука\"\n\n    myapp.show_timeline","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"МК","title":"Сѐ е до комбинирањето","chapter":"N","answer":":-","ok":"Moody!","error":"","text":"Некои убави работи можат да бидат направени со едноставни делови од Ruby, посебно кога ќе ги\nискомбинираш заедно за да креираш нови работи.\n\nТука, ние имаме апликација направена од класа која содржи друга класа. И, всушност, Ruby навистина добро\nфункционира со ваквите вгнездувања. Тоа се нарекува објектно ориентирано програмирање.\n\nНие стигнавме до __последната вежба за програмирање__ од TryRuby. Доколку сакаш, можеш да додадеш\nи други карактеристики (анг. features) на Blurbalizer<sup>TM</sup>.\n\nМожеби ти сакаш да го прикажеш расположението преку емотикони во __show_timeline__ методот. Можеш \nда додадеш _moodify_ во Blurb<sup>TM</sup> класата и тогаш да го искористиш тој метод во \n _show\\_timeline_ методот:\n\n    class Blurb\n      attr_accessor :content, :time, :mood\n\n      def initialize(mood, content=\"\")\n        @time    = Time.now\n        @content = content[0..39]\n        @mood    = mood\n      end\n\n      def moodify\n        if    @mood == :sad\n          return \":-(\"\n        elsif @mood == :happy\n          return \":-)\"\n        # Add other moods here\n        end\n\n        # The default mood\n        \":-|\"\n      end\n    end\n\n    class Blurbalizer\n      def initialize(title)\n        @title  = title\n        @blurbs = []\n      end\n\n      def add_a_blurb(mood, content)\n        @blurbs << Blurb.new(mood, content)\n      end\n\n      def show_timeline\n        puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\"\n\n        @blurbs.sort_by { |t|\n          t.time\n        }.reverse.each { |t|\n          puts \"#{t.content.ljust(40)} #{t.time}\"\n        }\n      end\n    end\n\n    myapp.show_timeline","load_code":"prev"},
"56":{"lang":"МК","title":"Резиме #8, или опушти-се-издржа","chapter":"Y","answer":"","ok":"","error":"","text":"Оваа последна лекција ја искористивме малку да забавиме и да потенцираме неколку работи како ти\nможеш да го користиш Ruby програмскиот јазик.\n\nДоколку уживаше, можеш да продолжиш со <a href=\"/playground\">TryRuby Playground</a>\nили преземи го и инсталирај Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a>\n\nШтом ќе завршиш со инсталација на Ruby, можеш да креираш фајл, на пример _my\\_first\\_progam.rb_,\nво текст едитор каде ќе напишеш Ruby код. Потоа кодот ќе го извршиш со отворање на терминал (или командна линија) и пишување\nна следнава команда:\n\n    ruby my_first_progam.rb\n\nИма многу (бесплатни) алатки за развој на софтвер (анг. software development) кои се комбинираат во едитор, file browser и 'ruby-runner'.\n\n## Прослави\nТи навистина заслужи двослојна торта со двослоен прелив и некој да ти засвири на гитара.\nТи ги совлада сите делови од овој туторијал! Нема сомнеж за тоа, ти си сега __certified red-blooded smartiac!__\n\n## Нешто повеќе\nИма повеќе статии на оваа веб страна. Таму ќе добиеш насоки каде да продолжиш да се\nдвижиш штом завршиш тука.","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_progam=K.new"}}